)F Function -

 This help member was created from the Bruce Koss skeletons that
 are part of the Edit Models for the Rexx language that he developed.

=ABBREV (Abbreviation)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--ABBREV(information,info---------------)------------------------->< |
|                                +-,length-+                             |
|                                                                        |
+------------------------------------------------------------------------+

Returns 1 if info is equal to the leading characters of information
and the length of info is not less than length.    Returns 0 if either
of these conditions is not met.

If you specify length, it must be a positive whole number or zero.
The default for length is the number of characters in info.

Here are some examples:

    ABBREV('Print','Pri')      ->    1
    ABBREV('PRINT','Pri')      ->    0
    ABBREV('PRINT','PRI',4)    ->    0
    ABBREV('PRINT','PRY')      ->    0
    ABBREV('PRINT','')         ->    1
    ABBREV('PRINT','',1)       ->    0

Example:    A null string always matches if a length of 0 (or the
default) is used.    This allows a default keyword to be selected
automatically if desired; for example:

    say 'Enter option:';   pull option .
    select  /* keyword1 is to be the default */
      when abbrev('keyword1',option) then ...
      when abbrev('keyword2',option) then ...
      ...
      otherwise nop;
    end;
=ABS (Absolute Value)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--ABS(number)----------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the absolute value of number.    The result has no sign and is
formatted according to the current NUMERIC settings.

Here are some examples:

    ABS('12.3')       ->    12.3
    ABS(' -0.307')    ->    0.307
=ADDRESS
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--ADDRESS-----------------------------------;--------------------->< |
|                +-environment-----------------|                         |
|                |             +-expression-+  |                         |
|                +------------expression1------+                         |
|                   +-VALUE-+                                            |
|                                                                        |
+------------------------------------------------------------------------+

ADDRESS temporarily or permanently changes the destination of
commands.    Commands are strings sent to an external environment.
You can send commands by specifying clauses consisting of only an
expression or by using the ADDRESS instruction.

How to enter commands to the host and the different host command
environments TSO/E provides are described in "Commands to External
Environments"    in item -CMD-EXT-ENVIR.

To send a single command to a specified environment, code an
environment, a literal string or a single symbol, which is taken to
be a constant, followed by an expression.    (The environment name is
the name of an external procedure or process that can process
commands.) The expression is evaluated, and the resulting string is
routed to the environment to be processed as a command.    (Enclose in
quotation marks any part of the expression you do not want to be
evaluated.) After execution of the command, environment is set back
to whatever it was before, thus temporarily changing the destination
for a single command.    The special variable RC is set, just as it
would be for other commands.  Errors and
failures in commands processed in this way are trapped or traced as
usual.

Example:

    ADDRESS LINK "routine p1 p2"       /*   TSO/E   */

If you specify only environment, a lasting change of destination
occurs:    all commands that follow (clauses that are neither REXX
instructions nor assignment instructions) are routed to the
specified command environment, until the next ADDRESS instruction is
processed.    The previously selected environment is saved.

Example:

    Address MVS
    "QBUF"
    "MAKEBUF"

Similarly, you can use the VALUE form to make a lasting change to
the environment.    Here expression1 (which may be simply a variable
name) is evaluated, and the result forms the name of the
environment.    You can omit the subkeyword VALUE if expression1 does
not begin with a literal string or symbol (that is, if it starts
with a special character, such as an operator character or
parenthesis).

Example:

    ADDRESS ('ENVIR'||number)
    /* Same as ADDRESS VALUE 'ENVIR'||number */

With no arguments, commands are routed back to the environment that
was selected before the previous lasting change of environment was
made, and the current environment name is saved.    After changing the
environment, repeated execution of ADDRESS alone, therefore,
switches the command destination between two environments
alternately.

The two environment names are automatically saved across internal
and external subroutine and function calls.    See the CALL
instruction in item CALL for more details.

The address setting is the currently selected environment name.    You
can retrieve the current address setting by using the ADDRESS
built-in function.    See this item

TSO/E REXX provides several host command environments that you can
use with the ADDRESS instruction.    The environments allow you to use
different TSO/E, MVS, and ISPF services.    See "Host Commands and
Host Command Environments"    in item -HOST-CMDS

You can provide your own environments or routines that handle
command processing in each environment.    For more information, see
"Host Command Environment Table"    in item -HCE-TABLE

ADDRESS

+------------------------------------------------------------------------+
|                                                                        |
| >>--ADDRESS()------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the name of the environment to which commands are currently
being submitted.    See the ADDRESS instruction (see this item ) for
more information.    Trailing blanks are removed from the result.
Here are some examples:

    ADDRESS()    ->    'TSO'        /* default under TSO/E  */
    ADDRESS()    ->    'MVS'        /* default under MVS    */
=ARG
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--ARG-------------------;----------------------------------------->< |
|           +-template_list-+                                            |
|                                                                        |
+------------------------------------------------------------------------+

ARG retrieves the argument strings provided to a program or internal
routine and assigns them to variables.    It is a short form of the
instruction:

>>--PARSE UPPER ARG-------------------;--><
                      +-template_list-+

The template_list is often a single template but can be several
templates separated by commas.    If specified, each template is a
list of symbols separated by blanks or patterns or both.

Unless a subroutine or internal function is being processed, the
strings passed as parameters to the program are parsed into
variables according to the rules described in "Parsing"    in item
-PARSING.

If a subroutine or internal function is being processed, the data
used will be the argument strings that the caller passes to the
routine.

In either case, the language processor translates the passed strings
to uppercase (that is, lowercase a-z to uppercase A-Z) before
processing them.    Use the PARSE ARG instruction if you do not want
uppercase translation.

You can use the ARG and PARSE ARG instructions repeatedly on the
same source string or strings (typically with different templates).
The source string does not change.    The only restrictions on the
length or content of the data parsed are those the caller imposes.

Example:

    /* String passed is "Easy Rider"  */
    Arg adjective noun .
    /* Now:  ADJECTIVE  contains 'EASY'           */
    /*       NOUN       contains 'RIDER'          */

If you expect more than one string to be available to the program or
routine, you can use a comma in the parsing template_list so each
template is selected in turn.

Example:

    /* Function is called by  FRED('data X',1,5)    */
    Fred:  Arg string, num1, num2
    /* Now:   STRING  contains 'DATA X'             */
    /*        NUM1    contains '1'                  */
    /*        NUM2    contains '5'                  */

Notes:

1.    The ARG built-in function can also retrieve or check the
      argument strings to a REXX program or internal routine.  See
      this item

2.    The source of the data being processed is also made available on
      entry to the program.  See the PARSE instruction (SOURCE option)
      on item PARSE for details.

ARG (Argument)

+------------------------------------------------------------------------+
|                                                                        |
| >>--ARG(----------------------)------------------------------------->< |
|             +-n--------------+                                         |
|                 +-,option-+                                            |
|                                                                        |
+------------------------------------------------------------------------+

Returns an argument string or information about the argument strings
to a program or internal routine.

If you do not specify n, the number of arguments passed to the
program or internal routine is returned.

If you specify only n, the nth argument string is returned.    If the
argument string does not exist, the null string is returned.    The n
must be a positive whole number.

If you specify option, ARG tests for the existence of the nth
argument string.    The following are valid options.  (Only the
capitalized and highlighted letter is needed; all characters
following it are ignored.)

Exists      returns 1 if the nth argument exists; that is, if it was
            explicitly specified when the routine was called.  Returns
            0 otherwise.

Omitted     returns 1 if the nth argument was omitted; that is, if it
            was not explicitly specified when the routine was called.
            Returns 0 otherwise.

Here are some examples:

    /*  following "Call name;" (no arguments) */
    ARG()         ->    0
    ARG(1)        ->    ''
    ARG(2)        ->    ''
    ARG(1,'e')    ->    0
    ARG(1,'O')    ->    1
    /*  following "Call name 'a',,'b';" */
    ARG()         ->    3
    ARG(1)        ->    'a'
    ARG(2)        ->    ''
    ARG(3)        ->    'b'
    ARG(n)        ->    ''    /* for n>=4 */
    ARG(1,'e')    ->    1
    ARG(2,'E')    ->    0
    ARG(2,'O')    ->    1
    ARG(3,'o')    ->    0
    ARG(4,'o')    ->    1

Notes:

1.    The number of argument strings is the largest number n for which
      ARG(n,'e') would return 1 or 0 if there are no explicit argument
      strings.  That is, it is the position of the last explicitly
      specified argument string.

2.    Programs called as commands can have only 0 or 1 argument
      strings.  The program has 0 argument strings if it is called
      with the name only and has 1 argument string if anything else
      (including blanks) is included with the command.

3.    You can retrieve and directly parse the argument strings to a
      program or internal routine with the ARG or PARSE ARG
      instructions.  (See this item, item PARSE, and item -PARSING )
=BITAND (Bit by Bit AND)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--BITAND(string1--------------------------------)----------------->< |
|                       +-,------------------------+                     |
|                           +-string2-+  +-,pad-+                        |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string composed of the two input strings logically ANDed
together, bit by bit.    (The encoding of the strings are used in the
logical operation.) The length of the result is the length of the
longer of the two strings.    If no pad character is provided, the AND
operation stops when the shorter of the two strings is exhausted,
and the unprocessed portion of the longer string is appended to the
partial result.    If pad is provided, it extends the shorter of the
two strings on the right before carrying out the logical operation.
The default for string2 is the zero length (null) string.

Here are some examples:

    BITAND('12'x)                  ->    '12'x
    BITAND('73'x,'27'x)            ->    '23'x
    BITAND('13'x,'5555'x)          ->    '1155'x
    BITAND('13'x,'5555'x,'74'x)    ->    '1154'x
    BITAND('pQrS',,'BF'x)          ->    'pqrs'      /* EBCDIC  */
=BITOR (Bit by Bit OR)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--BITOR(string1--------------------------------)------------------>< |
|                      +-,------------------------+                      |
|                          +-string2-+  +-,pad-+                         |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string composed of the two input strings logically
inclusive-ORed together, bit by bit.    (The encoding of the strings
are used in the logical operation.) The length of the result is the
length of the longer of the two strings.    If no pad character is
provided, the OR operation stops when the shorter of the two strings
is exhausted, and the unprocessed portion of the longer string is
appended to the partial result.    If pad is provided, it extends the
shorter of the two strings on the right before carrying out the
logical operation.    The default for string2 is the zero length
(null) string.

Here are some examples:

    BITOR('12'x)                  ->    '12'x
    BITOR('15'x,'24'x)            ->    '35'x
    BITOR('15'x,'2456'x)          ->    '3556'x
    BITOR('15'x,'2456'x,'F0'x)    ->    '35F6'x
    BITOR('1111'x,,'4D'x)         ->    '5D5D'x
    BITOR('Fred',,'40'x)          ->    'FRED'       /* EBCDIC      */
=BITXOR (Bit by Bit Exclusive OR)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--BITXOR(string1--------------------------------)----------------->< |
|                       +-,------------------------+                     |
|                           +-string2-+  +-,pad-+                        |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string composed of the two input strings logically
eXclusive-ORed together, bit by bit.    (The encoding of the strings
are used in the logical operation.) The length of the result is the
length of the longer of the two strings.    If no pad character is
provided, the XOR operation stops when the shorter of the two
strings is exhausted, and the unprocessed portion of the longer
string is appended to the partial result.    If pad is provided, it
extends the shorter of the two strings on the right before carrying
out the logical operation.    The default for string2 is the zero
length (null) string.

Here are some examples:

    BITXOR('12'x)                     ->  '12'x
    BITXOR('12'x,'22'x)               ->  '30'x
    BITXOR('1211'x,'22'x)             ->  '3011'x
    BITXOR('1111'x,'444444'x)         ->  '555544'x
    BITXOR('1111'x,'444444'x,'40'x)   ->  '555504'x
    BITXOR('1111'x,,'4D'x)            ->  '5C5C'x
    BITXOR('C711'x,'222222'x,' ')     ->  'E53362'x  /* EBCDIC */
=Logical (Boolean)
)F Function -
A character string is taken to have the value false if it is 0, and
true if it is 1.    The logical operators take one or two such values
(values other than 0 or 1 are not allowed) and return 0 or 1 as
appropriate:

&           AND

            Returns 1 if both terms are true.

|           Inclusive OR

            Returns 1 if either term is true.

&&          Exclusive OR

            Returns 1 if either (but not both) is true.

Prefix \,^ Logical NOT

            Negates; 1 becomes 0, and 0 becomes 1
=B2X (Binary to Hexadecimal)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--B2X(binary_string)---------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string, in character format, that represents binary_string
converted to hexadecimal.

The binary_string is a string of binary (0 or 1) digits.    It can be
of any length.    You can optionally include blanks in binary_string
(at four-digit boundaries only, not leading or trailing) to aid
readability; they are ignored.

The returned string uses uppercase alphabetics for the values A-F,
and does not include blanks.

If binary_string is the null string, B2X returns a null string.    If
the number of binary digits in binary_string is not a multiple of
four, then up to three 0 digits are added on the left before the
conversion to make a total that is a multiple of four.

Here are some examples:

    B2X('11000011')    ->   'C3'
    B2X('10111')       ->   '17'
    B2X('101')         ->   '5'
    B2X('1 1111 0000') ->   '1F0'

You can combine B2X with the functions X2D and X2C to convert a
binary number into other forms.    For example:

    X2D(B2X('10111'))  ->   '23'   /* decimal 23 */
=CALL
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
|                    <-,--------------+                                  |
| >>--CALL----name-----------------------------------;---------------->< |
|             |        +-expression-+               |                    |
|             +-OFF---ERROR-------------------------|                    |
|             |     +-FAILURE-|                     |                    |
|             |     +-HALT----+                     |                    |
|             +-ON---ERROR--------------------------+                    |
|                  +-FAILURE-|  +-NAME--trapname-+                       |
|                  +-HALT----+                                           |
|                                                                        |
+------------------------------------------------------------------------+

CALL calls a routine (if you specify name) or controls the trapping
of certain conditions (if you specify ON or OFF).

To control trapping, you specify OFF or ON and the condition you
want to trap.    OFF turns off the specified condition trap.  ON turns
on the specified condition trap.    All information about condition
traps is contained in "Conditions and Condition Traps"    in item
-CONDS-TRAPS.

To call a routine, specify name, a literal string or symbol that is
taken as a constant.    The name must be a symbol, which is treated
literally, or a literal string.    The routine called can be:

An internal routine A function or subroutine that is in the same
                      program as the CALL instruction or function call
                      that calls it.

A built-in routine    A function (which may be called as a subroutine)
                      that is defined as part of the REXX language.

An external routine A function or subroutine that is neither
                      built-in nor in the same program as the CALL
                      instruction or function call that calls it.

If name is a string (that is, you specify name in quotation marks),
the search for internal routines is bypassed, and only a built-in
function or an external routine is called.    Note that the names of
built-in functions (and generally the names of external routines,
too) are in uppercase; therefore, you should uppercase the name in
the literal string.

The called routine can optionally return a result, and when it does,
the CALL instruction is functionally identical with the clause:

                    <-,--------------+
>>--result=name(----------------------)--;--><
                      +-expression-+

If the called routine does not return a result, then you will get an
error if you call it as a function (as previously shown).

If the subroutine returns a result, the result is stored in the REXX
special variable RESULT, not the special variable RC.    The REXX
special variable RC is set when you enter host commands from a REXX
program, but RC is not set when you use the
CALL instruction.

TSO/E supports specifying up to 20 expressions, separated by
commas.    The expressions are evaluated in order from left to right
and form the argument strings during execution of the routine.    Any
ARG or PARSE ARG instruction or ARG built-in function in the called
routine accesses these strings rather than any previously active in
the calling program, until control returns to the CALL instruction.
You can omit expressions, if appropriate, by including extra
commas.

The CALL then causes a branch to the routine called name, using
exactly the same mechanism as function calls.    (See "Functions"  in
item -FUNCTIONS.    ) The search order is "Search Order"  in item
-SEARCH-ORDER but briefly is as follow

Internal routines:
       These are sequences of instructions inside the same program,
       starting at the label that matches name in the CALL
       instruction.  If you specify the routine name in quotation
       marks, then an internal routine is not considered for that
       search order.  You can use SIGNAL and CALL together to call an
       internal routine whose name is determined at the time of
       execution; this is known as a multi-way call (see item SIGNAL
       The RETURN instruction completes the execution of an internal
       routine.

Built-in routines:
       These are routines built into the language processor for
       providing various functions.  They always return a string that
       is the result of the routine.

External routines:
       Users can write or use routines that are external to the
       language processor and the calling program.  You can code an
       external routine in REXX or in any language that supports the
       system-dependent interfaces.  For information about using the
       system-dependent interfaces, see "External Functions and
       Subroutines, and Function Packages"  in item -EXT-FUNC.  For
       information about the search order the system uses to locate
       external routines, see "Search Order"  in item -SEARCH-ORDER.
       If the CALL instruction calls an external routine written in
       REXX as a subroutine, you can retrieve any argument strings
       with the ARG or PARSE ARG instructions or the ARG built-in
       function.

During execution of an internal routine, all variables previously
known are generally accessible.    However, the PROCEDURE instruction
can set up a local variables environment to protect the subroutine
and caller from each other.    The EXPOSE option on the PROCEDURE
instruction can expose selected variables to a routine.

Calling an external program as a subroutine is similar to calling an
internal routine.    The external routine, however, is an implicit
PROCEDURE in that all the caller's variables are always hidden.    The
status of internal values (NUMERIC settings, and so forth) start
with their defaults (rather than inheriting those of the caller).
In addition, you can use EXIT to return from the routine.

When control reaches an internal routine the line number of the CALL
instruction is available in the variable SIGL (in the caller's
variable environment).    This may be used as a debug aid, as it is,
therefore, possible to find out how control reached a routine.    Note
that if the internal routine uses the PROCEDURE instruction, then it
needs to EXPOSE SIGL to get access to the line number of the CALL.

Eventually the subroutine should process a RETURN instruction, and
at that point control returns to the clause following the original
CALL.    If the RETURN instruction specified an expression, the
variable RESULT is set to the value of that expression.    Otherwise,
the variable RESULT is dropped (becomes uninitialized).

An internal routine can include calls to other internal routines, as
well as recursive calls to itself.

Example:

    /* Recursive subroutine execution... */
    arg z
    call factorial z
    say z'! =' result
    exit
    factorial: procedure     /* Calculate factorial by  */
      arg n                  /*  recursive invocation.  */
      if n=0 then return 1
      call factorial n-1
      return  result * n

During internal subroutine (and function) execution, all important
pieces of information are automatically saved and are then restored
upon return from the routine.    These are:

o     The status of DO loops and other structures:  Executing a SIGNAL
      while within a subroutine is safe because DO loops, and so
      forth, that were active when the subroutine was called are not
      ended.  (But those currently active within the subroutine are
      ended.)

o     Trace action:  After a subroutine is debugged, you can insert a
      TRACE Off at the beginning of it, and this does not affect the
      tracing of the caller.  Conversely, if you simply wish to debug
      a subroutine, you can insert a TRACE Results at the start and
      tracing is automatically restored to the conditions at entry
      (for example, Off) upon return.  Similarly, ?  (interactive
      debug) and !  (command inhibition) are saved across routines.

o     NUMERIC settings:  The DIGITS, FUZZ, and FORM of arithmetic
      operations (in "NUMERIC"  in item NUMERIC) are saved and are
      then restored on return.  A subroutine can, therefore, set the
      precision, and so forth, that it needs to use without affecting
      the caller.

o     ADDRESS settings:  The current and previous destinations for
      commands (see "ADDRESS"  in item ADDRESS ) are saved and are
      then restored on return.

o     Condition traps:  (CALL ON and SIGNAL ON) are saved and then
      restored on return.  This means that CALL ON, CALL OFF, SIGNAL
      ON, and SIGNAL OFF can be used in a subroutine without affecting
      the conditions the caller set up.

o     Condition information:  This information describes the state and
      origin of the current trapped condition.  The CONDITION built-in
      function returns this information.  See "CONDITION"  in item
      CONDITION.

o     Elapsed-time clocks:  A subroutine inherits the elapsed-time
      clock from its caller (see "TIME"  in item TIME ), but because
      the time clock is saved across routine calls, a subroutine or
      internal function can independently restart and use the clock
      without affecting its caller.  For the same reason, a clock
      started within an internal routine is not available to the
      caller.

o     OPTIONS settings:  ETMODE and EXMODE are saved and are then
      restored on return.  For more information, see "OPTIONS"  in
      item OPTIONS.

Implementation maximum:    The total nesting of control structures,
which includes internal routine calls, may not exceed a depth of
250.
=CENTER=CENTRE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>----CENTER(----string,length------------)------------------------->< |
|       +-CENTRE(-+                 +-,pad-+                             |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string of length length with string centered in it, with
pad characters added as necessary to make up length.    The length
must be a positive whole number or zero.    The default pad character
is blank.    If the string is longer than length, it is truncated at
both ends to fit.    If an odd number of characters are truncated or
added, the right-hand end loses or gains one more character than the
left-hand end.

Here are some examples:

    CENTER(abc,7)               ->    '  ABC  '
    CENTER(abc,8,'-')           ->    '--ABC---'
    CENTRE('The blue sky',8)    ->    'e blue s'
    CENTRE('The blue sky',7)    ->    'e blue '

To avoid errors because of the difference between British and
American spellings, this function can be called either CENTRE or
CENTER.
=Comments
)F Function -
A comment is a sequence of characters (on one or more lines)
delimited by /* and */.    Within these delimiters any characters are
allowed.    Comments can contain other comments, as long as each
begins and ends with the necessary delimiters.    They are called
nested comments.    Comments can be anywhere and can be of any
length.    They have no effect on the program, but they do act as
separators.    (Two tokens with only a comment in between are not
treated as a single token.)

/* This is an example of a valid REXX comment */

Take special care when commenting out lines of code containing /* or
*/ as part of a literal string.    Consider the following program
segment:

01      parse pull input
02      if substr(input,1,5) = '/*123'
03        then call process
04      dept = substr(input,32,5)

To comment out lines 2 and 3, the following change would be
incorrect:

01      parse pull input
02 /* if substr(input,1,5) = '/*123'
03        then call process
04 */ dept = substr(input,32,5)

This is incorrect because the language processor would interpret the
/* that is part of the literal string /*123 as the start of a nested
comment.    It would not process the rest of the program because it
would be looking for a matching comment end (*/).

You can avoid this type of problem by using concatenation for
literal strings containing /* or */; line 2 would be:

if substr(input,1,5) = '/' || '*123'

You could comment out lines 2 and 3 correctly as follows:

01      parse pull input
02 /* if substr(input,1,5) = '/' || '*123'
03        then call process
04 */ dept = substr(input,32,5)

=COMPARE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--COMPARE(string1,string2------------)---------------------------->< |
|                                +-,pad-+                                |
|                                                                        |
+------------------------------------------------------------------------+

Returns 0 if the strings, string1 and string2, are identical.
Otherwise, returns the position of the first character that does not
match.    The shorter string is padded on the right with pad if
necessary.    The default pad character is a blank.

Here are some examples:

    COMPARE('abc','abc')         ->    0
    COMPARE('abc','ak')          ->    2
    COMPARE('ab ','ab')          ->    0
    COMPARE('ab ','ab',' ')      ->    0
    COMPARE('ab ','ab','x')      ->    3
    COMPARE('ab-- ','ab','-')    ->    5
=CONDITION
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--CONDITION(----------------)------------------------------------->< |
|                    +-option-+                                          |
|                                                                        |
+------------------------------------------------------------------------+

Returns the condition information associated with the current
trapped condition.    (See "Conditions and Condition Traps"  in item
-CONDS-TRAPS for a description of condition traps.) You can request
the following pieces of information:

o     The name of the current trapped condition
o     Any descriptive string associated with that condition
o     The instruction processed as a result of the condition trap (CALL
      or SIGNAL)
o     The status of the trapped condition.

To select the information to return, use the following options.
(Only the capitalized and highlighted letter is needed; all
characters following it are ignored.)

Condition name        returns the name of the current trapped
                      condition.

Description           returns any descriptive string associated with
                      the current trapped condition.  See item
                      -DESCR-STR for the list of possible strings.  If
                      no description is available, returns a null
                      string.

Instruction           returns either CALL or SIGNAL, the keyword for
                      the instruction processed when the current
                      condition was trapped.  This is the default if
                      you omit option.

Status                returns the status of the current trapped
                      condition.  This can change during processing,
                      and is either:

                          ON - the condition is enabled

                          OFF - the condition is disabled

                          DELAY - any new occurrence of the condition
                          is delayed or ignored.

If no condition has been trapped, then the CONDITION function
returns a null string in all four cases.

Here are some examples:

    CONDITION()            ->    'CALL'        /* perhaps */
    CONDITION('C')         ->    'FAILURE'
    CONDITION('I')         ->    'CALL'
    CONDITION('D')         ->    'FailureTest'
    CONDITION('S')         ->    'OFF'        /* perhaps */

The CONDITION function returns condition information that is saved
and restored across subroutine calls (including those a CALL ON
condition trap causes).    Therefore, after a subroutine called with
CALL ON trapname has returned, the current trapped condition reverts
to the condition that was current before the CALL took place (which
may be none).    CONDITION returns the values it returned before the
condition was trapped.
=Continuations
)F Function -
A clause can be continued onto the next line by using the comma,
which is referred to as the continuation character.    The comma is
functionally replaced by a blank, and, thus, no semicolon is
implied.    One or more comments can follow the continuation character
before the end of the line.    The continuation character cannot be
used in the middle of a string or it will be processed as part of
the string itself.    The same situation holds true for comments.
Note that the comma remains in execution traces.

The following example shows how to use the continuation character to
continue a clause.

say 'You can use a comma',
     'to continue this clause.'

This displays:

You can use a comma to continue this clause.

A clause can also be continued onto the next line by using nulls.
That is, the clause can be a literal string that contains blank
characters and spans multiple lines until the ending quote is
encountered.    A literal string can contain up to 250 characters.
=COPIES
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--COPIES(string,n)------------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

Returns n concatenated copies of string.    The n must be a positive
whole number or zero.

Here are some examples:

    COPIES('abc',3)    ->    'abcabcabc'
    COPIES('abc',0)    ->    ''
=C2D (Character to Decimal)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--C2D(string----------)------------------------------------------->< |
|                   +-,n-+                                               |
|                                                                        |
+------------------------------------------------------------------------+

Returns the decimal value of the binary representation of string.
If the result cannot be expressed as a whole number, an error
results.    That is, the result must not have more digits than the
current setting of NUMERIC DIGITS.    If you specify n, it is the
length of the returned result.    If you do not specify n, string is
processed as an unsigned binary number.

If string is null, returns 0.

Here are some examples:

    C2D('09'X)      ->        9
    C2D('81'X)      ->      129
    C2D('FF81'X)    ->    65409
    C2D('')         ->        0
    C2D('a')        ->      129     /*  EBCDIC  */

If you specify n, the string is taken as a signed number expressed
in n characters.    The number is positive if the leftmost bit is off,
and negative, in two's complement notation, if the leftmost bit is
on.    In both cases, it is converted to a whole number, which may,
therefore, be negative.    The string is padded on the left with '00'x
characters (note, not "sign-extended"), or truncated on the left to
n characters.    This padding or truncation is as though
RIGHT(string,n,'00'x) had been processed.    If n is 0, C2D always
returns 0.

Here are some examples:

    C2D('81'X,1)      ->     -127
    C2D('81'X,2)      ->      129
    C2D('FF81'X,2)    ->     -127
    C2D('FF81'X,1)    ->     -127
    C2D('FF7F'X,1)    ->      127
    C2D('F081'X,2)    ->    -3967
    C2D('F081'X,1)    ->     -127
    C2D('0031'X,0)    ->        0

Implementation maximum:    The input string cannot have more than 250
characters that are significant in forming the final result.
Leading sign characters ('00'x and 'FF'x) do not count toward this
total.
=C2X (Character to Hexadecimal)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--C2X(string)----------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string, in character format, that represents string
converted to hexadecimal.    The returned string contains twice as
many bytes as the input string.    For example, on an EBCDIC system,
C2X(1) returns F1 because the EBCDIC representation of the character
1 is ÛF1ÛX.

The string returned uses uppercase alphabetics for the values A-F
and does not include blanks.    The string can be of any length.  If
string is null, returns a null string.

Here are some examples:

    C2X('72s')      ->    'F7F2A2' /* 'C6F7C6F2C1F2'X in EBCDIC */
    C2X('0123'X)    ->    '0123'   /* 'F0F1F2F3'X     in EBCDIC */
=DATATYPE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DATATYPE(string-------------)----------------------------------->< |
|                        +-,type-+                                       |
|                                                                        |
+------------------------------------------------------------------------+

Returns NUM if you specify only string and if string is a valid REXX
number that can be added to 0 without error; returns CHAR if string
is not a valid number.

If you specify type, returns 1 if string matches the type; otherwise
returns 0.    If string is null, the function returns 0 (except when
type is X, which returns 1 for a null string).    The following are
valid types.    (Only the capitalized and highlighted letter is
needed; all characters following it are ignored.    Note that for the
hexadecimal option, you must start your string specifying the name
of the option with x rather than h.)

Alphanumeric returns 1 if string contains only characters from the
            ranges a-z, A-Z, and 0-9.

Binary      returns 1 if string contains only the characters 0 or 1 or
            both.

C           returns 1 if string is a mixed SBCS/DBCS string.

Dbcs        returns 1 if string is a DBCS-only string enclosed by SO
            and SI bytes.

Lowercase returns 1 if string contains only characters from the
            range a-z.

Mixed casereturns 1 if string contains only characters from the
            ranges a-z and A-Z.

Number      returns 1 if string is a valid REXX number.

Symbol      returns 1 if string contains only characters that are
            valid in REXX symbols.  Note that both
            uppercase and lowercase alphabetics are permitted.

Uppercase returns 1 if string contains only characters from the
            range A-Z.

Whole number returns 1 if string is a REXX whole number under the
            current setting of NUMERIC DIGITS.

heXadecimal returns 1 if string contains only characters from the
            ranges a-f, A-F, 0-9, and blank (as long as blanks appear
            only between pairs of hexadecimal characters).  Also
            returns 1 if string is a null string, which is a valid
            hexadecimal string.

Here are some examples:

    DATATYPE(' 12 ')         ->   'NUM'
    DATATYPE('')             ->   'CHAR'
    DATATYPE('123*')         ->   'CHAR'
    DATATYPE('12.3','N')     ->    1
    DATATYPE('12.3','W')     ->    0
    DATATYPE('Fred','M')     ->    1
    DATATYPE('','M')         ->    0
    DATATYPE('Fred','L')     ->    0
    DATATYPE('?20K','s')     ->    1
    DATATYPE('BCd3','X')     ->    1
    DATATYPE('BC d3','X')    ->    1

The DATATYPE function tests the meaning or type of characters in a
string, independent of the encoding of those characters (for
example, ASCII or EBCDIC).
=DATE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DATE--(----------------------------------------------------------> |
|                +-date_format1-------------------------------------|    |
|                |              +-,input_date--------------------+  |    |
|                |                            +-,date_format2-+     |    |
|                +-,input_date--------------------------------------+    |
|                              +-,date_format2-+                         |
|                                                                        |
| >--)---------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns, by default, the local date in the format:    dd mon yyyy
(day, month, year--for example, 25 Dec 2001), with no leading zero
or blank on the day.    Otherwise, the string input_date is converted
to the format specified by date_format1.    date_format2 can be
specified to define the current format of input_date.    The default
for date_format1 and date_format2 is Normal.    input_date must not
have a leading zero or blank.

You can use the following options to obtain specific date formats.
(Only the bold character is needed; all other characters are
ignored.)

Base        the number of complete days (that is, not including the
            current day) since and including the base date, 1 January
            0001, in the format:  dddddd (no leading zeros or
            blanks).  The expression DATE('B')//7 returns a number in
            the range 0-6 that corresponds to the current day of the
            week, where 0 is Monday and 6 is Sunday.

            Thus, this function can be used to determine the day of
            the week independent of the national language in which you
            are working.

            Note:  The base date of 1 January 0001 is determined by
                   extending the current Gregorian calendar backward
                   (365 days each year, with an extra day every year
                   that is divisible by 4 except century years that
                   are not divisible by 400).  It does not take into
                   account any errors in the calendar system that
                   created the Gregorian calendar originally.

Century     the number of days, including the current day, since and
            including January 1 of the last year that is a multiple of
            100 in the form:  ddddd (no leading zeros).  Example:  A
            call to DATE(C) on March 13, 1992, returns 33675, the
            number of days from 1 January 1900 to 13 March 1992.
            Similarly, a call to DATE(C) on November 20, 2001, returns
            690, the number of days from 1 January 2000 to 20 November
            2001.

            Note:  When used for date_format1, this option is valid
                   when input_date is not specified.

Days        the number of days, including the current day, so far in
            this year in the format:  ddd (no leading zeros or
            blanks).

European    date in the format: dd/mm/yy

Julian      date in the format: yyddd.

            Note:  When used for date_format1, this option is valid
                   only when input_date is not specified.

Month       full English name of the current month, in mixed case--for
            example, August.  Only valid for date_format1.

Normal      date in the format:  dd mon yyyy, in mixed case.  This is
            the default.  If the active language has an abbreviated
            form of the month name, then it is used--for example, Jan,
            Feb, and so on.  If Normal is specified (or allowed to
            default) for date_format2, the input_date must have the
            month (mon) specified in the English abbreviated form of
            the month name in mixed case.

Ordered     date in the format:  yy/mm/dd (suitable for sorting, and
            so forth).

Standard    date in the format:  yyyymmdd (suitable for sorting, and
            so forth).

Usa         date in the format: mm/dd/yy.

Weekday     the English name for the day of the week, in mixed
            case--for example, Tuesday.  Only valid for date_format1.

Here are some examples, assuming today is November 20, 2001:

    DATE()                      ->    '20 Nov 2001'
    DATE(,'20020609','S')       ->    '9 Jun 2002'
    DATE('B')                   ->    '730808'
    DATE('B','25 Sep 2001')     ->    '730752'
    DATE('C')                   ->    '690'
    DATE('E')                   ->    '20/11/01'
    DATE('J')                   ->    '01324'
    DATE('M')                   ->    'November'
    DATE('N')                   ->    '20 Nov 2001'
    DATE('N','1438','C')        ->    '8 Dec 2003'
    DATE('O')                   ->    '01/11/20'
    DATE('S')                   ->    '20011120'
    DATE('U')                   ->    '11/20/01'
    DATE('U','25 May 2001')     ->    '05/25/01'
    DATE('U','25 MAY 2001')     ->    ERROR,month not in mixed case
    DATE('W')                   ->    'Tuesday'

Notes:

1.    The first call to DATE or TIME in one clause causes a time stamp
      to be made that is then used for all calls to these functions in
      that clause.  Therefore, multiple calls to any of the DATE or
      TIME functions or both in a single expression or clause are
      guaranteed to be consistent with each other.

2.    Input dates given in 2-digit year formats (i.e.  European,
      Julian, Ordered, Usa) are interpreted as being within a 100 year
      window as calculated by:

      (current_year - 50) = low end of window
      (current_year + 49) = high end of window

DATE conversion requires that the input_date conforms exactly to one
of the syntax forms that could have been output by the DATE
function.    For example, the following invocations of DATE would
fail.    The incorrect specification of input_date in each case would
result in the same error message, IRX0040I.

    DATE('B','7 MAY 2001')   ->  IRX0040I  (input is not mixed case)
    DATE('B',' 7 May 2001')  ->  IRX0040I  (input has a leading blank)
    DATE('B','07 May 2001')  ->  IRX0040I  (input has a leading zero)
=DELSTACK
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DELSTACK-------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Deletes the most recently created data stack that was created by the
NEWSTACK command, and all elements on it.    If a new data stack was
not created, DELSTACK removes all the elements from the original
data stack.

The DELSTACK command can be used in REXX execs that execute in both
the TSO/E address space and non-TSO/E address spaces.

The exec that creates a new data stack with the NEWSTACK command can
delete the data stack with the DELSTACK command, or an external
function or subroutine that is written in REXX and that is called by
that exec can issue a DELSTACK command to delete the data stack.

Examples

1.    To create a new data stack for a called routine and delete the
      data stack when the routine returns, use the NEWSTACK and
      DELSTACK commands as follows:

        .
        .
        .
        "NEWSTACK"   /* data stack 2 created */
        CALL sub1
        "DELSTACK"   /* data stack 2 deleted */

        .
        .
        .
        EXIT
        sub1:
        PUSH ...
        QUEUE ...
        PULL ...
        RETURN

2.    After creating multiple new data stacks, to find out how many
      data stacks were created and delete all but the original data
      stack, use the NEWSTACK, QSTACK, and DELSTACK commands as
      follows:

        "NEWSTACK"   /* data stack 2 created */

        .
        .
        .
        "NEWSTACK"   /* data stack 3 created */

        .
        .
        .
        "NEWSTACK"   /* data stack 4 created */
        "QSTACK"
        times = RC-1 /* set times to the number of new data stacks
                        created */
        DO times     /* delete all but the original data stack */
          "DELSTACK" /* delete one data stack */
        END
=DELSTR (Delete String)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DELSTR(string,n---------------)--------------------------------->< |
|                        +-,length-+                                     |
|                                                                        |
+------------------------------------------------------------------------+

Returns string after deleting the substring that begins at the nth
character and is of length characters.    If you omit length, or if
length is greater than the number of characters from n to the end of
string, the function deletes the rest of string (including the nth
character).    The length must be a positive whole number or zero.
The n must be a positive whole number.    If n is greater than the
length of string, the function returns string unchanged.

Here are some examples:

    DELSTR('abcd',3)       ->    'ab'
    DELSTR('abcde',3,2)    ->    'abe'
    DELSTR('abcde',6)      ->    'abcde'
=DELWORD (Delete Word)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DELWORD(string,n---------------)-------------------------------->< |
|                         +-,length-+                                    |
|                                                                        |
+------------------------------------------------------------------------+

Returns string after deleting the substring that starts at the nth
word and is of length blank-delimited words.    If you omit length, or
if length is greater than the number of words from n to the end of
string, the function deletes the remaining words in string
(including the nth word).    The length must be a positive whole
number or zero.    The n must be a positive whole number.  If n is
greater than the number of words in string, the function returns
string unchanged.    The string deleted includes any blanks following
the final word involved but none of the blanks preceding the first
word involved.

Here are some examples:

    DELWORD('Now is the  time',2,2)  ->  'Now time'
    DELWORD('Now is the time ',3)    ->  'Now is '
    DELWORD('Now is the  time',5)    ->  'Now is the  time'
    DELWORD('Now is   the time',3,1) ->  'Now is   time'
=DIGITS
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DIGITS()-------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the current setting of NUMERIC DIGITS.    See the NUMERIC
instruction on item NUMERIC for more information.

Here is an example:

    DIGITS()    ->    9      /* by default */
=DO
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DO------------------------------------------;--------------------> |
|           +-| repetitor +-+  +-| conditional +-+                       |
|                                                                        |
| >-----------------------END--------------;-------------------------->< |
|      |  <-----------+  |        +-name-+                               |
|      +---instruction---+                                               |
|                                                                        |
| repetitor:                                                             |
| +----name=expri------------------------------------------------------| |
|      |            +-TO--exprt-+  +-BY--exprb-+  +-FOR--exprf-+  |      |
|      +-FOREVER--------------------------------------------------|      |
|      +-exprr----------------------------------------------------+      |
|                                                                        |
| conditional:                                                           |
| +----WHILE--exprw----------------------------------------------------| |
|      +-UNTIL--expru-+                                                  |
|                                                                        |
+------------------------------------------------------------------------+

DO groups instructions together and optionally processes them
repetitively.    During repetitive execution, a control variable
(name) can be stepped through some range of values.

Syntax Notes:

o     The exprr, expri, exprb, exprt, and exprf options (if present)
      are any expressions that evaluate to a number.  The exprr and
      exprf options are further restricted to result in a positive
      whole number or zero.  If necessary, the numbers are rounded
      according to the setting of NUMERIC DIGITS.

o     The exprw or expru options (if present) can be any expression
      that evaluates to 1 or 0.

o     The TO, BY, and FOR phrases can be in any order, if used, and
      are evaluated in the order in which they are written.

o     The instruction can be any instruction, including assignments,
      commands, and keyword instructions (including any of the more
      complex constructs such as IF, SELECT, and the DO instruction
      itself).

o     The subkeywords WHILE and UNTIL are reserved within a DO
      instruction, in that they cannot be used as symbols in any of
      the expressions.  Similarly, TO, BY, and FOR cannot be used in
      expri, exprt, exprb, or exprf.  FOREVER is also reserved, but
      only if it immediately follows the keyword DO and an equal sign
      does not follow it.

o     The exprb option defaults to 1, if relevant.
=DROPBUF
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--DROPBUF--------------------------------------------------------->< |
|               +-n-+                                                    |
|                                                                        |
+------------------------------------------------------------------------+

Removes the most recently created data stack buffer that was created
with the MAKEBUF command, and all elements on the data stack in the
buffer.    To remove a specific data stack buffer and all buffers
created after it, issue the DROPBUF command with the number (n) of
the buffer.

The DROPBUF command can be issued from REXX execs that execute in
both the TSO/E address space and non-TSO/E address spaces.

Operand: The operand for the DROPBUF command is:

n
      specifies the number of the first data stack buffer you want to
      drop.  DROPBUF removes the specified buffer and all buffers
      created after it.  Any elements that were placed on the data
      stack after the specified buffer was created are also removed.
      If n is not specified, only the most recently created buffer and
      its elements are removed.

      The data stack initially contains one buffer, which is known as
      buffer 0.  This buffer will never be removed, as it is not
      created by MAKEBUF.  If you issue DROPBUF 0, all buffers that
      were created on the data stack with the MAKEBUF command and all
      elements that were put on the data stack are removed.  DROPBUF 0
      effectively clears the data stack including the elements on
      buffer 0.

If processing was not successful, the DROPBUF command sets one of
the following return codes in the REXX special variable RC.

+------------------------------------------------------------------------+
| Return Code | Meaning                                                  |
+-------------+----------------------------------------------------------|
| 0             | DROPBUF was successful.                                |
+-------------+----------------------------------------------------------|
| 1             | An invalid number n was specified. For example, n was  |
|               | A1.                                                    |
+-------------+----------------------------------------------------------|
| 2             | The specified buffer does not exist.  For example,     |
|               | you get a return code of 2 if you try to drop a        |
|               | buffer that does not exist.                            |
+------------------------------------------------------------------------+

Example

A subroutine (sub2) in a REXX exec (execc) issues the MAKEBUF
command to create four buffers.    Before the subroutine returns, it
removes buffers two and above and all elements within the buffers.


    /*  REXX program  */
    execc:

    .
    .
    .
         CALL sub2

    .
    .
    .

    exit
    sub2:
       "MAKEBUF"      /* buffer 1 created */
       QUEUE A
       "MAKEBUF"      /* buffer 2 created */
       QUEUE B
       QUEUE C
       "MAKEBUF"      /* buffer 3 created */
       QUEUE D
       "MAKEBUF"      /* buffer 4 created */
       QUEUE E
       QUEUE F

    .
    .
    .
       "DROPBUF 2"    /* buffers 2 and above deleted */
       RETURN
=DROP
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
|             <----------+                                               |
| >>--DROP-----name-------;------------------------------------------->< |
|              +-(name)-+                                                |
|                                                                        |
+------------------------------------------------------------------------+

DROP "unassigns" variables, that is, restores them to their
original uninitialized state.    If name is not enclosed in
parentheses, it identifies a variable you want to drop and must be a
symbol that is a valid variable name, separated from any other name
by one or more blanks or comments.

If parentheses enclose a single name, then its value is used as a
subsidiary list of variables to drop.    (Blanks are not necessary
either inside or outside the parentheses, but you can add them if
desired.) This subsidiary list must follow the same rules as the
original list (that is, be valid variable names, separated by
blanks) except that no parentheses are allowed.

Variables are dropped in sequence from left to right.    It is not an
error to specify a name more than one time or to DROP a variable
that is not known.    If an exposed variable is named, (see
"PROCEDURE"    in item PROCEDURE ), the variable in the older
generation is dropped.

Example:

    j=4
    Drop  a z.3 z.j
    /* Drops the variables: A, Z.3, and Z.4              */
    /* so that reference to them returns their names.    */

Here, a variable name in parentheses is used as a subsidiary list.

Example:

    mylist='c d e'
    drop (mylist) f
    /* Drops the variables C, D, E, and F          */
    /* Does not drop MYLIST                        */

Specifying a stem (that is, a symbol that contains only one period,
as the last character), drops all variables starting with that
stem.

Example:

    Drop  z.
    /* Drops all variables with names starting with Z. */
=D2C (Decimal to Character)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--D2C(wholenumber----------)-------------------------------------->< |
|                        +-,n-+                                          |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string, in character format, that represents wholenumber,
a decimal number, converted to binary.    If you specify n, it is the
length of the final result in characters; after conversion, the
input string is sign-extended to the required length.    If the number
is too big to fit into n characters, then the result is truncated on
the left.    The n must be a positive whole number or zero.

If you omit n, wholenumber must be a positive whole number or zero,
and the result length is as needed.    Therefore, the returned result
has no leading '00'x characters.

Here are some examples:

    D2C(9)         ->   ' '    /* '09'x is unprintable in EBCDIC       */
    D2C(129)       ->   'a'    /* '81'x is an EBCDIC 'a'               */
    D2C(129,1)     ->   'a'    /* '81'x is an EBCDIC 'a'               */
    D2C(129,2)     ->   ' a'   /* '0081'x is EBCDIC ' a'               */
    D2C(257,1)     ->   ' '    /* '01'x is unprintable in EBCDIC       */
    D2C(-127,1)    ->   'a'    /* '81'x is EBCDIC 'a'                  */
    D2C(-127,2)    ->   ' a'   /* 'FF'x is unprintable EBCDIC;         */
                               /* '81'x is EBCDIC 'a'                  */
    D2C(-1,4)      ->   '    ' /* 'FFFFFFFF'x is unprintable in EBCDIC */
    D2C(12,0)      ->   ''     /* '' is a null string                  */

Implementation maximum:    The output string may not have more than
250 significant characters, though a longer result is possible if it
has additional leading sign characters ('00'x and 'FF'x).
=D2X (Decimal to Hexadecimal)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--D2X(wholenumber----------)-------------------------------------->< |
|                        +-,n-+                                          |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string, in character format, that represents wholenumber,
a decimal number, converted to hexadecimal.    The returned string
uses uppercase alphabetics for the values A-F and does not include
blanks.

If you specify n, it is the length of the final result in
characters; after conversion the input string is sign-extended to
the required length.    If the number is too big to fit into n
characters, it is truncated on the left.    The n must be a positive
whole number or zero.

If you omit n, wholenumber must be a positive whole number or zero,
and the returned result has no leading zeros.

Here are some examples:

    D2X(9)         ->    '9'
    D2X(129)       ->    '81'
    D2X(129,1)     ->    '1'
    D2X(129,2)     ->    '81'
    D2X(129,4)     ->    '0081'
    D2X(257,2)     ->    '01'
    D2X(-127,2)    ->    '81'
    D2X(-127,4)    ->    'FF81'
    D2X(12,0)      ->    ''

Implementation maximum:    The output string may not have more than
500 significant hexadecimal characters, though a longer result is
possible if it has additional leading sign characters (0 and F).
=ERRORTEXT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--ERRORTEXT(n)---------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the REXX error message associated with error number n.    The
n must be in the range 0-99, and any other value is an error.
Returns the null string if n is in the allowed range but is not a
defined REXX error number.

Error numbers produced by syntax errors during processing of REXX
execs correspond to TSO/E REXX messages (described in z/OS TSO/E
Messages.) For example, error 26 corresponds to message number
IRX0026I.    The error number is also the value that is placed in the
REXX special variable RC when SIGNAL ON SYNTAX event is trapped.

Here are some examples:

    ERRORTEXT(16)    ->    'Label not found'
    ERRORTEXT(60)    ->    ''
=EXECIO
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--EXECIO----lines--------------------------------------------------> |
|               +-*-----+                                                |
|                                                                        |
| >----DISKW--ddname-------------------------------------------------->< |
|      |                +-| Write Parms +-+                    |         |
|      +----DISKR----ddname------------------------------------+         |
|         +-DISKRU-+        +-linenum-+  +--| Read Parms +--+            |
|                                                                        |
| Write Parms:                                                           |
| +--------------------------------------------------------------------| |
|      +-(------------------------------------------------+              |
|           +-STEM var-name-+  +-OPEN-+  +-FINIS-+  +-)-+                |
|                                                                        |
| Read Parms:                                                            |
| +--------------------------------------------------------------------| |
|      +-(----------------------------------------------------------+    |
|          +-FIFO----------|  +-OPEN-+  +-FINIS-+  +-SKIP-+  +-)-+       |
|          +-LIFO----------|                                             |
|          +-STEM var-name-+                                             |
|                                                                        |
+------------------------------------------------------------------------+

Controls the input and output (I/O) of information to and from a
data set.    Information can be read from a data set to the data stack
for serialized processing or to a list of variables for random
processing.    Information from the data stack or a list of variables
can be written to a data set.

The EXECIO command can be used in REXX execs that execute in both
the TSO/E address space and non-TSO/E address spaces.

You can use the EXECIO command to do various types of I/O tasks,
such as copy information to and from a data set to add, delete, or
update the information.

Restrictions:    The EXECIO command does not support I/O on files
allocated to data sets with spanned, track overflow, or undefined
record formats.

An I/O data set must be either sequential or a single member of a
PDS.    Before the EXECIO command can perform I/O to or from the data
set, the data set must be allocated to a file that is specified on
the EXECIO command.    The EXECIO command does not perform the
allocation.

When performing I/O with a new file for which no LRECL, no RECFM, or
no BLKSIZE has been specified, EXECIO will provide default values
which may or may not be desirable.    However, when a new file with a
block size of zero (BLKSIZE=0) is written to by EXECIO DISKW, its
block size will not be overridden with a default value by EXECIO.
This allows REXX users to take advantage of System-Determined Block
Size, or SDB.    For more information about using DFSMS:  Using Data
Sets for more information about using System-Determined Block Size,
see DFSMS Macro Instructions for Data Sets, SC26-7408-01.

When performing I/O with a system data set that is available to
multiple users, allocate the data set as OLD, before issuing the
EXECIO command, to have exclusive use of the data set.

When you use EXECIO, you must ensure that you use quotation marks
around any operands, such as DISKW, STEM, FINIS, or LIFO.    Using
quotation marks prevents the possibility of the operands being
substituted as variables.    For example, if you assign the variable
stem to a value in the exec and then issue EXECIO with the STEM
option, if STEM is not enclosed in quotation marks, it will be
substituted with its assigned value.

Operands for Reading from a Data Set:    The operands for the EXECIO
command to read from a data set are as follows:

lines
      the number of lines to be processed.  This operand can be a
      specific decimal number or an arbitrary number indicated by *.
      When the operand is * and EXECIO is reading from a data set,
      input is read until EXECIO reaches the end of the data set.

      If you specify a value of zero (0), no I/O operations are
      performed unless you also specify either OPEN, FINIS, or both
      OPEN and FINIS.

      o   If you specify OPEN and the data set is closed, EXECIO opens
          the data set but does not read any lines.  If you specify
          OPEN and the data set is open, EXECIO does not read any
          lines.

          In either case, if you also specify a non-zero value for the
          linenum operand, EXECIO sets the current record number to
          the record number indicated by the linenum operand.

          Note:  By default, when a file is opened, the current record
                 number is set to the first record (record 1).  The
                 current record number is the number of the next
                 record EXECIO will read.  However, if you use a
                 non-zero linenum value with the OPEN operand, EXECIO
                 sets the current record number to the record number
                 indicated by linenum.

      o   If you specify FINIS and the data set is open, EXECIO does
          not read any lines, but EXECIO closes the data set.  If you
          specify FINIS and the data set is not already opened, EXECIO
          does not open the data set and then close it.

      o   If you specify both OPEN and FINIS, EXECIO processes the
          OPEN first as described above.  EXECIO then processes the
          FINIS as described above.

DISKR
      opens a data set for input (if it is not already open) and reads
      the specified number of lines from the data set and places them
      on the data stack.  If the STEM operand is specified, the lines
      are placed in a list of variables instead of on the data stack.

      While a data set is open for input, you cannot write information
      back to the same data set.

      The data set is not automatically closed unless:

      o   the task, under which the data set was opened, ends

      o   the last language processor environment associated with the
          task, under which the data set was opened, is terminated
          (see "Initialization and Termination of a Language Processor
          Environment"  in item -LPE-INIT-TERM for information about
          language processor environments)

DISKRU
      opens a data set for update (if it is not already open) and
      reads the specified number of lines from the data set and places
      them on the data stack.  If the STEM operand is specified, the
      lines are placed in a list of variables instead of on the data
      stack.

      While a data set is open for update, the last record read can be
      changed and then written back to the data set with a
      corresponding EXECIO DISKW command.  Typically, you open a data
      set for update when you want to modify information in the data
      set.

      The data set is not automatically closed unless:

      o   the task, under which the data set was opened, ends

      o   the last language processor environment associated with the
          task, under which the data set was opened, is terminated

      After a data set is open for update (by issuing a DISKRU as the
      first operation against the data set), you can use either DISKR
      or DISKRU to fetch subsequent records for update.

ddname
      the name of the file to which the sequential data set or member
      of the PDS was allocated.  You must allocate the file before you
      can issue EXECIO.  For example, you can allocate a file using
      the ALLOCATE command in the TSO/E address space only or a JCL DD
      statement.

linenum
      the line number in the data set at which EXECIO is to begin
      reading.  When a data set is closed and reopened as a result of
      specifying a record number earlier than the current record
      number, the file is open for:

      o   input if DISKR is specified
      o   update if DISKRU is specified

      When a data set is open for input or update, the current record
      number is the number of the next record to be read.  When
      linenum specifies a record number earlier than the current
      record number in an open data set, the data set must be closed
      and reopened to reposition the current record number at
      linenum.  When this situation occurs and the data set was not
      opened at the same task level as that of the executing exec,
      attempting to close the data set at a different task level
      results in an EXECIO error.  The linenum operand must not be
      used in this case.

      Specifying a value of zero (0) for linenum is equivalent to not
      specifying the linenum operand.  In either case, EXECIO begins
      reading the file as follows:

      o   If the file was already opened, EXECIO begins reading with
          the line following the last line that was read.

      o   If the file was just opened, EXECIO begins reading with the
          first line of the file.

      FINIS
          close the data set after the EXECIO command completes.  A
          data set can be closed only if it was opened at the same
          task level as the exec issuing the EXECIO command.

          You can use FINIS with a lines value of 0 to have EXECIO
          close an open data set without first reading a record.

          Because the EXEC command (when issued from TSO/E READY mode)
          is attached by the TSO/E terminal monitor program (TMP),
          data sets opened by a REXX exec are typically closed
          automatically when the top level exec ends.  Good
          programming practice, however, would be to explicitly close
          all data sets when finished with them.

      OPEN
          opens the specified data set if it is not already open.  You
          can use OPEN with a lines value of 0 to have EXECIO do one
          of the following:

          o   open a data set without reading any records

          o   set the current record number (that is, the number of
              the next record EXECIO will read) to the record number
              indicated by the linenum operand, if you specify a value
              for linenum

      STEM var-name
          the stem of the set of variables into which information is
          to be placed.  To place information in compound variables,
          which allow for easy indexing, the var-name should end with
          a period.  For example,

            MYVAR.

          When var-name does not end with a period, the variable names
          are appended with numbers and can be accessed in a loop such
          as:

               "EXECIO * DISKR MYINDD (FINIS STEM MYVAR"
               DO i = 1 to MYVAR0
                  this_line = VALUE('MYVAR'||i)
               END

          In the first example above, the list of compound variables
          has the stem MYVAR.  and lines of information (records) from
          the data set are placed in variables MYVAR.1, MYVAR.2,
          MYVAR.3, and so forth.  The number of variables in the list
          is placed in MYVAR.0

          Thus if 10 lines of information were read into the MYVAR
          variables, MYVAR.0 contains the number 10, indicating that
          10 records are read.  Furthermore, MYVAR.1 contains record
          1, MYVAR.2 contains record 2, and so forth up to MYVAR.10
          which contains record 10.  All stem variables beyond
          MYVAR.10 (i.e.  MYVAR.11, MYVAR.12, etc.) are residual and
          contain the values that they held before entering the EXECIO
          command.

          To avoid confusion as to whether a residual stem variable
          value is meaningful, you may want to clear the entire stem
          variable before entering the EXECIO command.  To clear all
          compound variables whose names begin with that stem, you can
          either:

          o   Use the DROP instruction as follows, to set all possible
              compound variables whose names begin with that stem to
              their uninitialized values:

                DROP MYVAR.

          o   Set all possible compound variables whose names begin
              with that stem to nulls as follows:

                MYVAR. = ''

          See the example at 12, which shows the usage of the EXECIO
          command with stem variables.

      LIFO
          places information about the data stack in LIFO (last in
          first out) order.

      FIFO
          places information about the data stack in FIFO (first in
          first out) order.  FIFO is the default when neither LIFO or
          FIFO is specified.

      SKIP
          reads the specified number of lines but does not place them
          on the data stack or in variables.  When the number of lines
          is *, EXECIO skips to the end of the data set.

Operands for Writing to a Data Set:    The operands for the EXECIO
command that write to a data set are as follows:

lines
      the number of lines to be written.  This operand can be a
      specific decimal number or an arbitrary number indicated by *.
      If you specify a value of zero (0), no I/O operations are
      performed unless you also specify either OPEN, FINIS, or both
      OPEN and FINIS.

      o   If you specify OPEN and the data set is closed, EXECIO opens
          the data set but does not write any lines.  If you specify
          OPEN and the data set is open, EXECIO does not write any
          lines.

      o   If you specify FINIS and the data set is open, EXECIO does
          not write any lines, but EXECIO closes the data set.  If you
          specify FINIS and the data set is not already opened, EXECIO
          does not open the data set and then close it.

      o   If you specify both OPEN and FINIS, EXECIO processes the
          OPEN first as described above.  EXECIO then processes the
          FINIS as described above.

      When EXECIO writes an arbitrary number of lines from the data
      stack, it stops only when it reaches a null line.  If there is
      no null line on the data stack in an interactive TSO/E address
      space, EXECIO waits for input from the terminal and stops only
      when it receives a null line.  See note below.

      When EXECIO writes an arbitrary number of lines from a list of
      compound variables, it stops when it reaches a null value or an
      uninitialized variable (one that displays its own name).

      The 0th variable has no effect on controlling the number of
      lines written from variables.

      Note:  EXECIO running in TSO/E background or in a non-TSO/E
             address space has the same use of the data stack as an
             exec that runs in the TSO/E foreground.  If an EXECIO *
             DISKW ...  command is executing in the background or in a
             non-TSO/E address space and the data stack becomes empty
             before a null line is found (which would terminate
             EXECIO), EXECIO goes to the input stream as defined by
             the INDD field in the module name table
             The system default is SYSTSIN.  When end-of-file reached,
             EXECIO ends.

DISKW
      opens a data set for output (if it is not already open) and
      writes the specified number of lines to the data set.  The lines
      can be written from the data stack or, if the STEM operand is
      specified, from a list of variables.

      You can use the DISKW operand to write information to a
      different data set from the one opened for input, or to update,
      one line at a time, the same data set opened for update.

      When a data set is open for update, you can use DISKW to rewrite
      the last record read.  The lines value should be 1 when doing an
      update.  For lines values greater than 1, each write updates the
      same record.

      The data set is not automatically closed unless:

      o   The task, under which the data set was opened, ends.

      o   The last language processor environment associated with the
          task, under which the data set was opened, is terminated.

      Notes:

      1.  The length of an updated line is set to the length of the
          line it replaces.  When an updated line is longer than the
          line it replaces, information that extends beyond the
          replaced line is truncated.  When information is shorter
          than the replaced line, the line is padded with blanks to
          attain the original line length.

      2.  When using EXECIO to write to more than one member of the
          same PDS, only one member of the PDS should be open at a
          time for output.

      3.  Do not use the MOD attribute when allocating a member of a
          PDS to which you want to append information.  You can use
          MOD only when appending information to a sequential data
          set.  To append information to a member of a PDS, rewrite
          the member with the additional records added.

ddname
      the name of the file to which the sequential data set or member
      of the PDS was allocated.  You must allocate the file before you
      issue the EXECIO command.

      FINIS
          close the data set after the EXECIO command completes.  A
          data set can be closed only if it was opened at the same
          task level as the exec issuing the EXECIO command.

          You can use FINIS with a lines value of 0 to have EXECIO
          close an open data set without first writing a record.

          Because the EXEC command (when issued from TSO/E READY mode)
          is attached by the TMP, data sets opened by a REXX exec are
          typically closed automatically when the top level exec
          ends.  Good programming practice, however, would be to
          explicitly close all data sets when finished with them.

      OPEN
          opens the specified data set if it is not already open.  You
          can use OPEN with a lines value of 0 to have EXECIO open a
          data set without writing any records.

      STEM var-name
          the stem of the list of variables from which information is
          to be written.  To write information from compound
          variables, which allow for indexing, the var-name should end
          with a period, MYVAR., for example.  When three lines are
          written to the data set, they are taken from MYVAR.1,
          MYVAR.2, MYVAR.3.  When * is specified as the number of
          lines to write, the EXECIO command stops writing information
          to the data set when it finds a null line or an
          uninitialized compound variable.  In this case, if the list
          contained 10 compound variables, the EXECIO command stops at
          MYVAR.11.

          The 0th variable has no effect on controlling the number of
          lines written from variables.

          When var-name does not end with a period, the variable names
          must be appended with consecutive numbers, such as MYVAR1,
          MYVAR2, MYVAR3.

          See the example 12 which shows the usage of the EXECIO
          command with stem variables.

Closing Data Sets:    If you specify FINIS on the EXECIO command, the
data set is closed after EXECIO completes processing.    If you do not
specify FINIS, the data set is closed when one of the following
occurs:

o     The task, under which the data set was opened, is terminated, or

o     The last language processor environment associated with the
      task, under which the data set was opened, is terminated (even
      if the task itself is not terminated).

In general, if you use the TSO/E EXEC command to invoke a REXX exec,
any data sets that the exec opens are closed when the top level exec
completes.    For example, suppose you are executing an exec (top
level exec) that invokes another exec.    The second exec uses EXECIO
to open a data set and then returns control to the first exec
without closing the data set.    The data set is still open when the
top level exec regains control.    The top level exec can then read
the same data set continuing from the point where the nested exec
finished EXECIO processing.    When the original exec (top level exec)
ends, the data set is automatically closed.

Figure 12 is an example of two execs that show how a data set
remains open.    The first (top level) exec, EXEC1, allocates a file
and then calls EXEC2.    The second exec (EXEC2) opens the file, reads
the first three records, and then returns control to EXEC1.    Note
that EXEC2 does not specify FINIS on the EXECIO command, so the file
remains open.

When the first exec EXEC1 regains control, it issues EXECIO and gets
the fourth record because the file is still open.    If EXEC2 had
specified FINIS on the EXECIO command, EXEC1 would have read the
first record.    In the example, both execs run at the same task
level.

--------------------------------------------------------------------------

                     FIRST EXEC ---- EXEC1
    /*   REXX exec (EXEC1) invokes another exec (EXEC2) to open a    */
    /*   file.  EXEC1 then continues reading the same file.          */
    say 'Executing the first exec EXEC1'
    "ALLOC FI(INPUTDD) DA(MYINPUT) SHR REUSE"   /* Alloc input file  */
    /*                                                               */
    /*   Now invoke the second exec (EXEC2) to open the INPUTDD file.*/
    /*   The exec uses a call to invoke the second exec.  You can    */
    /*   also use the TSO/E EXEC command, which would have the       */
    /*   same result.                                                */
    /*   If EXEC2 opens a file and does not close the file before    */
    /*   returning control to EXEC1, the file remains open when      */
    /*   control is returned to EXEC1.                               */
    /*                                                               */
    say 'Invoking the second exec EXEC2'
    call exec2                            /* Call EXEC2 to open file */
    say 'Now back from the second exec EXEC2.  Issue another EXECIO.'
    "EXECIO 1 DISKR INPUTDD (STEM X."     /* EXECIO reads record 4   */
    say x.1
    say 'Now close the file'
    "EXECIO 0 DISKR INPUTDD (FINIS"  /* Close file so it can be freed*/
    "FREE FI(INPUTDD)"
    EXIT 0
                     SECOND EXEC ---- EXEC2
    /* REXX exec (EXEC2) opens the file INPUTDD, reads 3 records, and*/
    /* then returns to the invoking exec (EXEC1).  The exec (EXEC2)  */
    /* returns control to EXEC1 without closing the INPUTDD file.    */
    /*                                                               */
    say "Now in the second exec EXEC2"
    DO I = 1 to 3                     /* Read & display first 3 recs */
       "EXECIO 1 DISKR INPUTDD (STEM Y."
       say y.1
    END
    Say 'Leaving second exec EXEC2.  Three records were read from file.'
    RETURN 0

--------------------------------------------------------------------------
Figure 12. Example of Closing Data Sets With EXECIO

Return Codes: After the EXECIO command runs, it sets the REXX special
variable RC to one of the following return codes:

 split=yes' SCALE='0.9'.
+--------------------------------------------------------------------------+
| Return Code    | Meaning                                                 |
+--------------+-----------------------------------------------------------|
| 0              | Normal completion of requested operation                |
+--------------+-----------------------------------------------------------|
| 1              | Data was truncated during DISKW operation               |
+--------------+-----------------------------------------------------------|
| 2              | End-of-file reached before the specified number of      |
|                | lines were read during a DISKR or DISKRU                |
|                | operation.  This does not occur if * is used for        |
|                | number of lines because the remainder of the file       |
|                | is always read.                                         |
+--------------+-----------------------------------------------------------|
| 4              | During a DISKR or DISKRU operation, an empty data       |
|                | set was found in a concatenation of data sets.  The     |
|                | file was not successfully opened and no data was        |
|                | returned.                                               |
+--------------+-----------------------------------------------------------|
| 20             | Severe error.  EXECIO completed unsuccessfully and      |
|                | a message is issued.                                    |
+--------------------------------------------------------------------------+

Examples

1.    This example copies an entire existing sequential data set named
      prefix.MY.INPUT into a member of an existing PDS named
      DEPT5.MEMO(MAR22), and uses the ddnames DATAIN and DATAOUT
      respectively.

         "ALLOC DA(MY.INPUT) F(DATAIN) SHR REUSE"
         "ALLOC DA('DEPT5.MEMO(MAR22)') F(DATAOUT) OLD"
         "NEWSTACK" /* Create a new data stack for input only */
         "EXECIO * DISKR DATAIN (FINIS"
         QUEUE ''   /* Add a null line to indicate the end of info */
         "EXECIO * DISKW DATAOUT (FINIS"
         "DELSTACK" /* Delete the new data stack */
         "FREE F(DATAIN DATAOUT)"

2.    This example copies an arbitrary number of lines from existing
      sequential data set prefix.TOTAL.DATA into a list of compound
      variables with the stem DATA., and uses the ddname INPUTDD:

         ARG lines
         "ALLOC DA(TOTAL.DATA) F(INPUTDD) SHR REUSE"
         "EXECIO" lines "DISKR INPUTDD (STEM DATA."
         SAY data.0 'records were read.'

3.    To update the second line in data set DEPT5.EMPLOYEE.LIST in
      file UPDATEDD, allocate the data set as OLD to guarantee
      exclusive update.

         "ALLOC DA('DEPT5.EMPLOYEE.LIST') F(UPDATEDD) OLD"
         "EXECIO 1 DISKRU UPDATEDD 2"
         PULL line
         PUSH 'Crandall, Amy        AMY       5500'
         "EXECIO 1 DISKW UPDATEDD (FINIS"
         "FREE F(UPDATEDD)"

4.    The following example scans each line of a data set whose name
      and size is specified by the user.  The user is given the option
      of changing each line as it appears.  If there is no change to
      the line, the user presses the Enter key to indicate that there
      is no change.  If there is a change to the line, the user types
      the entire line with the change and the new line is returned to
      the data set.

        PARSE ARG name numlines
                     /* Get data set name and size from user */
        "ALLOC DA("name") F(UPDATEDD) OLD"
        eof = 'NO'                /* Initialize end-of-file flag */
        DO i = 1 to numlines WHILE eof = no
          "EXECIO 1 DISKRU UPDATEDD "
                     /* Queue the next line on the stack */
          IF RC = 2 THEN
                     /* Return code indicates end-of-file */
             eof = 'YES'
          ELSE
            DO
              PARSE PULL line
              SAY 'Please make changes to the following line.'
              SAY 'If you have no changes, press ENTER.'
              SAY line
              PARSE PULL newline
              IF newline = '' THEN NOP
              ELSE
               DO
                  PUSH newline
                  "EXECIO 1 DISKW UPDATEDD"
               END
            END
        END
        "EXECIO 0 DISKW UPDATEDD (FINIS"

5.    This example reads from the data set allocated to INDD to find
      the first occurrence of the string "Jones".  Upper and lowercase
      distinctions are ignored.  The example demonstrates how to read
      and search one record at a time.  For better performance, you
      can read all records to the data stack or to a list of
      variables, search them, and then return the updated records.

        done = 'no'
        DO WHILE done = 'no'
          "EXECIO 1 DISKR INDD"
           IF RC = 0 THEN          /*  Record was read */
             DO
               PULL record
               lineno = lineno + 1   /*  Count the record */
               IF INDEX(record,'JONES') ^= 0 THEN
                 DO
                   SAY 'Found in record' lineno
                   done = 'yes'
                   SAY 'Record = ' record
                 END
               ELSE NOP
             END
           ELSE
             done = 'yes'
        END
        "EXECIO 0 DISKR INDD (FINIS"
        EXIT 0

6.    This exec copies records from data set prefix.MY.INPUT to the
      end of data set prefix.MY.OUTPUT.  Neither data set has been
      allocated to a ddname.  It assumes that the input data set has
      no null lines.

        "ALLOC DA(MY.INPUT) F(INDD) SHR REUSE"
        "ALLOC DA(MY.OUTPUT) F(OUTDD) MOD REUSE"
        SAY 'Copying ...'
        "EXECIO * DISKR INDD (FINIS"
        QUEUE ''
        /* Insert a null line at the end to indicate end of file */
        "EXECIO * DISKW OUTDD (FINIS"
        SAY 'Copy complete.'
        "FREE F(INDD OUTDD)"
        EXIT 0

7.    This exec reads five records from the data set allocated to
      MYINDD starting with the third record.  It strips trailing
      blanks from the records, and then writes any record that is
      longer than 20 characters.  The file is not closed when the exec
      is finished.

        "EXECIO 5 DISKR MYINDD 3"
        DO i = 1 to 5
          PARSE PULL line
          stripline = STRIP(line,t)
          len = LENGTH(stripline)
          IF len > 20 THEN
            SAY 'Line' stripline 'is long.'
          ELSE NOP
        END
        /* The file is still open for processing */
        EXIT 0

8.    This exec reads the first 100 records (or until EOF) of the data
      set allocated to INVNTORY.  Records are placed on the data stack
      in LIFO order.  A message is issued that gives the result of the
      EXECIO operation.

        eofflag = 2     /* Return code to indicate end of file */
        "EXECIO 100 DISKR INVNTORY (LIFO"
        return_code = RC
        IF return_code = eofflag THEN
           SAY 'Premature end of file.'
        ELSE
           SAY '100 Records read.'
        EXIT return_code

9.    This exec erases any existing data from the data set
      FRED.WORKSET.FILE by opening the data set and then closing it
      without writing any records.  By doing this, EXECIO just writes
      an end-of-file marker, which erases any existing records in the
      data set.

      In this example, the data set from which you are erasing records
      must not be allocated with a disposition of MOD.  If you
      allocate the data set with a disposition of MOD, the EXECIO OPEN
      followed by the EXECIO FINIS results in EXECIO just rewriting
      the existing end-of-file marker.

        "ALLOCATE DA('FRED.WORKSET.FILE') F(OUTDD) OLD REUSE"
        "EXECIO 0 DISKW OUTDD (OPEN"
                     /* Open the OUTDD file for writing,
                        but do not write a record       */
        "EXECIO 0 DISKW OUTDD (FINIS"
                     /* Close the OUTDD file.  This
                        basically completes the erasing of
                        any existing records from the
                        OUTDD file.                     */

      Note that in this example, the EXECIO ...  (OPEN command
      followed by the EXECIO ...  (FINIS command is equivalent to:

        "EXECIO 0 DISKW OUTDD (OPEN FINIS"

10. This exec opens the data set MY.INVNTORY without reading any
      records.  The exec then uses a main loop to read records from
      the data set and process the records.

        "ALLOCATE DA('MY.INVNTORY') F(INDD) SHR REUSE"
        "ALLOCATE DA('MY.AVAIL.FILE') F(OUTDD) OLD REUSE"
        "EXECIO 0 DISKR INDD (OPEN" /* Open INDD file for input, but
                                       do not read any records       */
        eof = 'NO'                  /* Initialize end-of-file flag   */
        avail_count = 0             /* Initialize counter            */
        DO WHILE eof = 'NO'         /* Loop until the EOF of input
                                       file                          */
          "EXECIO 1 DISKR INDD (STEM LINE." /* Read a line           */
          IF RC = 2 THEN            /* If end of file is reached,    */
            eof = 'YES'             /* set the end-of-file (eof)
                                       flag                          */
          ELSE                      /* Otherwise, a record is read   */
            DO
              IF INDEX(line.1,'AVAILABLE') ^ = 0 THEN /* Look for
                                       records marked "available"    */
                DO                          /* "Available" rec found */
                  "EXECIO 1 DISKW OUTDD (STEM LINE." /* Write record to
                                             "Available" file        */
                  avail_count = avail_count+1 /* Increment "available"
                                                   counter           */
                END
            END
        END
        "EXECIO 0 DISKR INDD (FINIS"   /* Close INDD file that is
                                          currently open             */
        "EXECIO 0 DISKW OUTDD (FINIS"  /* Close OUTDD file if file is
                               currently open.  If the OUTDD file is
                               not open, the EXECIO command has
                               no effect.                            */
        EXIT 0

11. This exec opens the data set MY.WRKFILE and sets the current
      record number to record 8 so that the next EXECIO DISKR command
      begins reading at the eighth record.

        "ALLOC DA('MY.WRKFILE') F(INDD) SHR REUSE"
        "EXECIO 0 DISKR INDD 8 (OPEN"
                       /* Open INDD file for input and set
                          current record number to 8.         */
        CALL READ_NEXT_RECORD
                       /* Call subroutine to read record on
                          to the data stack.  The next
                          record EXECIO reads is record 8
                          because the previous EXEC IO set
                          the current record number to 8.     */
          .
          .
          .
        "EXECIO 0 DISKR INDD (FINIS"  /* Close the INDD file. */

12. This exec uses EXECIO to successively append the records from
      'sample1.data' and then from 'sample2.data' to the end of the
      data set 'all.sample.data'.  It illustrates the effect of
      residual data in STEM variables.  Data set 'sample1.data'
      contains 20 records.  Data set 'sample2.data' contains 10
      records.

        "ALLOC FI(MYINDD1) DA('SAMPLE1.DATA') SHR REUSE" /* infile 1 */
        "ALLOC FI(MYINDD2) DA('SAMPLE2.DATA') SHR REUSE" /* infile 2 */
        "ALLOC FI(MYOUTDD) DA('ALL.SAMPLE.DATA') MOD REUSE" /* output
                                          append file                */
    /*****************************************************************/
    /* Read all records from 'sample1.data' and append them to the   */
    /* end of 'all.sample.data'.                                     */
    /*****************************************************************/
        exec_RC = 0                   /* Initialize exec return code */
        "EXECIO * DISKR MYINDD1 (STEM NEWVAR. FINIS" /* Read all recs*/
        if rc = 0 then                 /* If read was successful     */
          do
    /*****************************************************************/
    /* At this point, newvar.0 should be 20, indicating 20 records   */
    /* have been read. Stem variables newvar.1, newvar.2, ... through*/
    /* newvar.20 will contain the 20 records that were read.         */
    /*****************************************************************/
            say "-----------------------------------------------------"
            say newvar.0 "records have been read from 'sample1.data': "
            say
            do i = 1 to newvar.0       /* Loop through all records   */
              say newvar.i             /* Display the ith record     */
            end
            "EXECIO" newvar.0 "DISKW MYOUTDD (STEM NEWVAR."
                        /* Write exactly the number of records read  */
            if rc = 0 then             /* If write was successful    */
              do
                say
                say newvar.0 "records were written to 'all.sample.data'"
              end
            else
              do
                exec_RC = RC           /* Save exec return code      */
                say
          say "Error during 1st EXECIO ... DISKW, return code is " RC
                say
              end
          end

        else
          do
            exec_RC = RC               /* Save exec return code      */
            say
            say "Error during 1st EXECIO ... DISKR, return code is " RC
            say
          end
          If exec_RC = 0 then    /* If no errors so far... continue  */
            do
      /***************************************************************/
      /* At this time, the stem variables newvar.0 through newvar.20 */
      /* will contain residual data from the previous EXECIO. We     */
      /* issue the "DROP newvar." instruction to clear these residual*/
      /* values from the stem.                                       */
      /***************************************************************/
            DROP newvar.         /* Set all stems variables to their */
                                 /* uninitialized state              */
      /***************************************************************/
      /* Read all records from 'sample2.data' and append them to the */
      /* end of 'all.sample.data'.                                   */
      /***************************************************************/
      "EXECIO * DISKR MYINDD2 (STEM NEWVAR. FINIS" /*Read all records*/
             if rc = 0 then             /* If read was successful    */
              do
        /*************************************************************/
        /* At this point, newvar.0 should be 10, indicating 10       */
        /* records have been read. Stem variables newvar.1, newvar.2,*/
        /* ... through newvar.10 will contain the 10 records. If we  */
        /* had not cleared the stem newvar. with the previous DROP   */
        /* instruction, variables newvar.11 through newvar.20 would  */
        /* still contain records 11 through 20 from the first data   */
        /* set. However, we would know that these values were not    */
        /* read by the last EXECIO DISKR since the current newvar.0  */
        /* variable indicates that only 10 records were read by      */
        /* that last EXECIO.                                         */
        /*************************************************************/

           say
           say
           say "-----------------------------------------------------"
           say newvar.0 "records have been read from 'sample2.data': "
           say
                do i = 1 to newvar.0   /* Loop through all records  */
                  say newvar.i         /* Display the ith record    */
                end
                "EXECIO" newvar.0 "DISKW MYOUTDD (STEM NEWVAR."
                        /* Write exactly the number of records read */
                if rc = 0 then         /* If write was successful   */
                 do
                   say
              say newvar.0 "records were written to 'all.sample.data'"
                 end
                else
                  do
                    exec_RC = RC       /* Save exec return code     */
                    say
            say "Error during 2nd EXECIO ...DISKW, return code is " RC
                    say
                  end
              end
            else
              do
                exec_RC = RC           /* Save exec return code     */
                say
         say "Error during 2nd EXECIO ... DISKR, return code is " RC
                say
              end
          end
        "EXECIO 0 DISKW MYOUTDD (FINIS"   /* Close output file      */
        "FREE FI(MYINDD1)"
        "FREE FI(MYINDD2)"
        "FREE FI(MYOUTDD)"
         exit 0
=EXECUTIL
)F Function -
+----------------------------------------------------------------------------
|
| >>--EXECUTIL---------------------------------------------------------------
|
| >----EXECDD(---CLOSE-----)-------------------------------------------------
|      |         +-NOCLOSE-+                                               |
|      +-TS----------------------------------------------------------------|
|      +-TE----------------------------------------------------------------|
|      +-HT----------------------------------------------------------------|
|      +-RT----------------------------------------------------------------|
|      +-HI----------------------------------------------------------------|
|      +-RENAME NAME(function-name)----------------------------------------|
|      |                            +-SYSNAME(sys-name)-+  +-DD(sys-dd)-+  |
|      +-SEARCHDD(---NO----)-----------------------------------------------+
|                  +-YES-+
|
+----------------------------------------------------------------------------

Lets you change various characteristics that control how an exec
processes in the TSO/E address space.    You can use EXECUTIL:

o     In a REXX exec that runs in a TSO/E address space

o     From TSO/E READY mode

o     From ISPF -- the ISPF command line or the ISPF option that lets
      you enter a TSO/E command or CLIST

o     In a CLIST.  You can use EXECUTIL in a CLIST to affect exec
      processing.  However, it has no effect on CLIST processing

You can also use EXECUTIL with the HI, HT, RT, TS, and TE operands
from a program that is written in a high-level programming language
by using the TSO service facility.    From READY mode or ISPF, the HI,
HT, and RT operands are not applicable because an exec is not
currently running.

Use EXECUTIL to:

o     Specify whether the system exec library (the default is SYSEXEC)
      is to be closed after the exec is located or is to remain open

o     Start and end tracing of an exec

o     Halt the interpretation of an exec

o     Suppress and resume terminal output from an exec

o     Change entries in a function package directory

o     Specify whether the system exec library (the default is SYSEXEC)
      is to be searched in addition to SYSPROC.

Additional Considerations for Using EXECUTIL:

o     All of the EXECUTIL operands are mutually exclusive, that is,
      you can only specify one of the operands on the command.

o     The HI, HT, RT, TS, and TE operands on the EXECUTIL command are
      also, by themselves, immediate commands.  Immediate commands are
      commands you can issue from the terminal if an exec is running
      in TSO/E and you press the attention interrupt key and enter
      attention mode.  When you enter attention mode, you can enter an
      immediate command.  Note that HE (Halt Execution) is an
      immediate command, but HE is not a valid operand on the EXECUTIL
      command.

      You can also use the TSO/E REXX commands TS (Trace Start) and TE
      (Trace End) in a REXX exec that runs in any address space (TSO/E
      and non-TSO/E).  For information about the TS command, see item
      TS.  For information about the TE command, see item TE.

o     In general, EXECUTIL works on a language processor environment
      basis.  That is, EXECUTIL affects only the current environment
      in which EXECUTIL is issued.  For example, if you are in split
      screen in ISPF and issue EXECUTIL TS from the second ISPF screen
      to start tracing, only execs that are invoked from that ISPF
      screen are traced.  If you invoke an exec from the first ISPF
      screen, the exec is not traced.

      Using the EXECDD and SEARCHDD operands may affect subsequent
      language processor environments that are created.  For example,
      if you issue EXECUTIL SEARCHDD from TSO/E READY mode and then
      invoke ISPF, the new search order defined by EXECUTIL SEARCHDD
      may be in effect for the ISPF session also.  This depends on
      whether your installation has provided its own parameters
      modules IRXTSPRM and IRXISPRM and the values specified in the
      load module.

EXECDD(CLOSE) or EXECDD(NOCLOSE)
      Specifies whether the system exec library is to be closed after
      the system locates the exec but before the exec runs.

      CLOSE causes the system exec library, whose default name is
      SYSEXEC, to be closed after the exec is located but before the
      exec runs.  You can change this condition by issuing the
      EXECUTIL EXECDD(NOCLOSE) command.

      NOCLOSE causes the system exec library to remain open.  This is
      the default condition and can be changed by issuing the EXECUTIL
      EXECDD(CLOSE) command.  The selected option remains in effect
      until it is changed by the appropriate EXECUTIL command, or
      until the current environment is terminated.

      Notes:

      1.  The EXECDD operand affects the ddname specified in the
          LOADDD field in the module name table.  The default is
          SYSEXEC.  "Module Name Table"  in item -MODNAMET describes
          the table.

      2.  If you specify EXECDD(CLOSE), the exec library (DD specified
          in the LOADDD field) is closed immediately after an exec is
          loaded.

      3.  Specify EXECDD(CLOSE) or EXECDD(NOCLOSE) before running any
          execs out of the SYSEXEC file.  If you attempt to use
          EXECDD(CLOSE) or EXECDD(NOCLOSE) after SYSEXEC has already
          been opened, you may not get the expected result because the
          SYSEXEC file must be closed at the same MVS task level at
          which it was opened.

      Any libraries defined using the ALTLIB command are not affected
      by the EXECDD operand.  SYSPROC is also not affected.

TS
      Use TS (Trace Start) to start tracing execs.  Tracing lets you
      interactively control the processing of an exec and debug
      problems.  For more information about the interactive debug
      facility, see "Debug Aids"  in item -DEBUG-AIDS.

      If you issue EXECUTIL TS from READY mode or ISPF, tracing is
      started for the next exec you invoke.  Tracing is then in effect
      for that exec and any other execs it calls.  Tracing ends:

      o   When the original exec completes
      o   If one of the invoked execs specifies EXECUTIL TE
      o   If one of the invoked execs calls a CLIST, which specifies
          EXECUTIL TE
      o   If you enter attention mode while an exec is running and
          issue the TE immediate command.

      If you use EXECUTIL TS in an exec, tracing is started for all
      execs that are running.  This includes the current exec that
      contains EXECUTIL TS, any execs it invokes, and any execs that
      were running when the current exec was invoked.  Tracing remains
      active until all execs that are currently running complete or an
      exec or CLIST contains EXECUTIL TE.

      For example, suppose exec A calls exec B, which then calls exec
      C.  If exec B contains the EXECUTIL TS command, tracing is
      started for exec B and remains in effect for both exec C and
      exec A.  Tracing ends when exec A completes.  However, if one of
      the execs contains EXECUTIL TE, tracing ends for all of the
      execs.

      If you use EXECUTIL TS in a CLIST, tracing is started for all
      execs that are running, that is, for any exec the CLIST invokes
      or execs that were running when the CLIST was invoked.  Tracing
      ends when the CLIST and all execs that are currently running
      complete or if an exec or CLIST contains EXECUTIL TE.  For
      example, suppose an exec calls a CLIST and the CLIST contains
      the EXECUTIL TS command.  When control returns to the exec that
      invoked the CLIST, that exec is traced.

      You can use EXECUTIL TS from a program by using the TSO service
      facility.  For example, suppose an exec calls a program and the
      program encounters an error.  The program can invoke EXECUTIL TS
      using the TSO service facility to start tracing all execs that
      are currently running.

      You can also press the attention interrupt key, enter attention
      mode, and then enter TS to start tracing or TE to end tracing.
      You can also use the TS command (see item TS ) and TE command
      (see item TE ) in an exec.

TE
      Use TE (Trace End) to end tracing execs.  The TE operand is not
      really applicable in READY mode because an exec is not currently
      running.  However, if you issued EXECUTIL TS to trace the next
      exec you invoke and then issued EXECUTIL TE, the next exec you
      invoke is not traced.

      If you use EXECUTIL TE in an exec or CLIST, tracing is ended for
      all execs that are currently running.  This includes execs that
      were running when the exec or CLIST was invoked and execs that
      the exec or CLIST calls.  For example, suppose exec A calls
      CLIST B, which then calls exec C.  If tracing was on and CLIST B
      contains EXECUTIL TE, tracing is ended and execs C and A are not
      traced.

      You can use EXECUTIL TE from a program by using the TSO service
      facility.  For example, suppose tracing has been started and an
      exec calls a program.  The program can invoke EXECUTIL TE using
      the TSO service facility to end tracing of all execs that are
      currently running.

      You can also press the attention interrupt key, enter attention
      mode, and then enter TE to end tracing.  You can also use the TE
      immediate command in an exec (see item TE ).

HT
      Use HT (Halt Typing) to suppress terminal output generated by an
      exec.  The exec continues running.  HT suppresses any output
      generated by REXX instructions or functions (for example, the
      SAY instruction) and REXX informational messages.  REXX error
      messages are still displayed.  Normal terminal output resumes
      when the exec completes.  You can also use EXECUTIL RT to resume
      terminal output.

      HT has no effect on CLISTs or commands.  If an exec invokes a
      CLIST and the CLIST generates terminal output, the output is
      displayed.  If an exec invokes a command, the command displays
      messages.

      Use the HT operand in either an exec or CLIST.  You can also use
      EXECUTIL HT from a program by using the TSO service facility.
      If the program invokes EXECUTIL HT, terminal output from all
      execs that are currently running is suppressed.  EXECUTIL HT is
      not applicable from READY mode or ISPF because no execs are
      currently running.

      If you use EXECUTIL HT in an exec, output is suppressed for all
      execs that are running.  This includes the current exec that
      contains EXECUTIL HT, any execs the exec invokes, and any execs
      that were running when the current exec was invoked.  Output is
      suppressed until all execs that are currently running complete
      or an exec or CLIST contains EXECUTIL RT.

      If you use EXECUTIL HT in a CLIST, output is suppressed for all
      execs that are running, that is, for any exec the CLIST invokes
      or execs that were running when the CLIST was invoked.  Terminal
      output resumes when the CLIST and all execs that are currently
      running complete or if an exec or CLIST contains EXECUTIL RT.

      For example, suppose exec A calls CLIST B, which then calls exec
      C.  If the CLIST contains EXECUTIL HT, output is suppressed for
      both exec A and exec C.

      If you use EXECUTIL HT and want to display terminal output using
      the SAY instruction, you must use EXECUTIL RT before the SAY
      instruction to resume terminal output.

RT
      Use RT (Resume Typing) to resume terminal output that was
      previously suppressed.  Use the RT operand in either an exec or
      CLIST.  You can also use EXECUTIL RT from a program by using the
      TSO service facility.  If the program invokes EXECUTIL RT,
      terminal output from all execs that are currently running is
      resumed.  EXECUTIL RT is not applicable from READY mode or ISPF
      because no execs are currently running.

      If you use EXECUTIL RT in an exec or CLIST, typing is resumed
      for all execs that are running.

HI
      Use HI (Halt Interpretation) to halt the interpretation of all
      execs that are currently running in the language processor
      environment.  From either an exec or a CLIST, EXECUTIL HI halts
      the interpretation of all execs that are currently running.  If
      an exec calls a CLIST and the CLIST contains EXECUTIL HI, the
      exec that invoked the CLIST stops processing.

      EXECUTIL HI is not applicable from READY mode or ISPF because no
      execs are currently running.

      You can use EXECUTIL HI from a program by using the TSO service
      facility.  If the program invokes EXECUTIL HI, the
      interpretation of all execs that are currently running is
      halted.

      If an exec enables the halt condition trap and the exec includes
      the EXECUTIL HI command, the interpretation of the current exec
      and all execs the current exec invokes is halted.  However, any
      execs that were running when the current exec was invoked are
      not halted.  These execs continue running.  For example, suppose
      exec A calls exec B and exec B specifies EXECUTIL HI and also
      contains a SIGNAL ON HALT instruction (with a HALT:  label).
      When EXECUTIL HI is processed, control is given to the HALT
      subroutine.  When the subroutine completes, exec A continues
      processing at the statement that follows the call to exec B.
      For more information, see Conditions and Condition Traps in item
      -CONDS-TRAPS

RENAME
      Use EXECUTIL RENAME to change entries in a function package
      directory.  A function package directory contains information
      about the functions and subroutines that make up a function
      package.  See "External Functions and Subroutines, and Function
      Packages"  in item -EXT-FUNC for more information.

      A function package directory contains the following fields for
      each function and subroutine:

      o   Func-name -- the name of the external function or subroutine
          that is used in an exec.

      o   Addr -- the address, in storage, of the entry point of the
          function or subroutine code.

      o   Sys-name -- the name of the entry point in a load module
          that corresponds to the code that is called for the function
          or subroutine.

      o   Sys-dd -- the name of the DD from which the function or
          subroutine code is loaded.

      You can use EXECUTIL RENAME with the SYSNAME and DD operands to
      change an entry in a function package directory as follows:

      o   Use the SYSNAME operand to change the sys-name of the
          function or subroutine in the function package directory.
          When an exec invokes the function or subroutine, the routine
          with the new sys-name is invoked.

      o   Use EXECUTIL RENAME NAME(function-name) without the SYSNAME
          and DD operands to flag the directory entry as null.  This
          causes the search for the function or subroutine to continue
          because a null entry is bypassed.  The system will then
          search for a load module and/or an exec.  See item
          -SEARCH-ORDER for the complete search order.

      EXECUTIL RENAME clears the addr field in the function package
      directory to X'00'.  When you change an entry, the name of the
      external function or subroutine is not changed, but the code
      that the function or subroutine invokes is replaced.

      You can use EXECUTIL RENAME to change an entry so that different
      code is used.

      NAME(function-name)
          Specifies the name of the external function or subroutine
          that is used in an exec.  This is also the name in the
          func-name field in the directory entry.

      SYSNAME(sys-name)
          Specifies the name of the entry point in a load module that
          corresponds to the package code that is called for the
          function or subroutine.  If SYSNAME is omitted, the sys-name
          field in the package directory is set to blanks.

      DD(sys-dd)
          Specifies the name of the DD from which the package code is
          loaded.  If DD is omitted, the sys-dd field in the package
          directory is set to blanks.

SEARCHDD(YES/NO)
      Specifies whether the system exec library (the default is
      SYSEXEC) should be searched when execs are implicitly invoked.
      YES indicates that the system exec library (SYSEXEC) is
      searched, and if the exec is not found, SYSPROC is then
      searched.  NO indicates that SYSPROC only is searched.

      EXECUTIL SEARCHDD lets you dynamically change the search order.
      The new search order remains in effect until you issue EXECUTIL
      SEARCHDD again, the language processor environment terminates,
      or you use ALTLIB.  Subsequently created environments inherit
      the same search order unless explicitly changed by the invoked
      parameters module.

      ALTLIB affects how EXECUTIL operates to determine the search
      order.  If you use the ALTLIB command to indicate that
      user-level, application-level, or system-level libraries are to
      be searched, ALTLIB operates on an application basis.  For more
      information about the ALTLIB command, see z/OS TSO/E Command
      Reference.

      EXECUTIL SEARCHDD generally affects the current language
      processor environment in which it is invoked.  For example, if
      you are in split screen in ISPF and issue EXECUTIL SEARCHDD from
      the second ISPF screen to change the search order, the changed
      search order affects execs invoked from that ISPF screen.  If
      you invoke an exec from the first ISPF screen, the changed
      search order is not in effect.  However, if you issue EXECUTIL
      SEARCHDD from TSO/E READY mode, when you invoke ISPF, the new
      search order may also be in effect for ISPF.  This depends on
      whether your installation has provided its own parameters
      modules IRXTSPRM and IRXISPRM and the values specified in the
      load module.

Return Codes: EXECUTIL returns the following return codes.

+--------------------------------------------------------------------------+
| Return Code    | Meaning                                                 |
+--------------+-----------------------------------------------------------|
| 0              | Processing successful.                                  |
+--------------+-----------------------------------------------------------|
| 12             | Processing unsuccessful. An error message has been      |
|                | issued.                                                 |
+--------------------------------------------------------------------------+

Examples

1.    Your installation uses both SYSEXEC and SYSPROC to store REXX
      execs and CLISTs.  All of the execs you work with are stored in
      SYSEXEC and your CLISTs are stored in SYSPROC.  Currently, your
      system searches SYSEXEC and SYSPROC and you do not use ALTLIB.

      You want to work with CLISTs only and do not need to search
      SYSEXEC.  To change the search order and have the system search
      SYSPROC only, use the following command:

        EXECUTIL SEARCHDD(NO)

2.    You are updating a REXX exec and including a new internal
      subroutine.  You want to trace the subroutine to test for any
      problems.  In your exec, include EXECUTIL TS at the beginning of
      your subroutine and EXECUTIL TE when the subroutine returns
      control to the main program.  For example:

        /*  REXX program  */
        MAINRTN:
        .
        .
        .
        CALL SUBRTN
        "EXECUTIL TE"
        .
        .
        .
        EXIT
        /*  Subroutine follows  */
        SUBRTN:
        "EXECUTIL TS"
        .
        .
        .
        RETURN

3.    You want to invoke an exec and trace it.  The exec does not
      contain EXECUTIL TS or the TRACE instruction.  Instead of
      editing the exec and including EXECUTIL TS or a TRACE
      instruction, you can enter the following from TSO/E READY mode:

        EXECUTIL TS

      When you invoke the exec, the exec is traced.  When the exec
      completes processing, tracing is off.

4.    Suppose an external function called PARTIAL is part of a
      function package.  You have written your own function called
      PARTIAL or a new version of the external function PARTIAL and
      want to execute your new PARTIAL function instead of the one in
      the function package.  Your new PARTIAL function may be an exec
      or may be stored in a load module.  You must flag the entry for
      the PARTIAL function in the function package directory as null
      in order for the search to continue to execute your new PARTIAL
      function.  To flag the PARTIAL entry in the function package
      directory as null, use the following command:

        EXECUTIL RENAME NAME(PARTIAL)

      When you execute the function PARTIAL, the null entry for
      PARTIAL in the function package directory is bypassed.  The
      system will continue to search for a load module and/or exec
      that is called PARTIAL.
=EXIT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--EXIT----------------;------------------------------------------->< |
|            +-expression-+                                              |
|                                                                        |
+------------------------------------------------------------------------+

EXIT leaves a program unconditionally.    Optionally EXIT returns a
character string to the caller.    The program is stopped immediately,
even if an internal routine is currently being run.    If no internal
routine is active, RETURN (see item RETURN ) and EXIT are identical
in their effect on the program that is being run.

If you specify expression, it is evaluated and the string resulting
from the evaluation is passed back to the caller when the program
stops.

Example:

    j=3
    Exit j*4
    /* Would exit with the string '12' */

If you do not specify expression, no data is passed back to the
caller.    If the program was called as an external function, this is
detected as an error--either immediately (if RETURN was used), or on
return to the caller (if EXIT was used).

"Running off the end"    of the program is always equivalent to the
instruction EXIT, in that it stops the whole program and returns no
result string.

Note:    If the program was called through a command interface, an
         attempt is made to convert the returned value to a return
         code acceptable by the host.  If the conversion fails, it is
         deemed to be a failure of the host interface and thus is not
         subject to trapping with SIGNAL ON SYNTAX.  The returned
         string must be a whole number whose value fits in a general
         register (that is, must be in the range -2**31 through
         2**31-1).
=EXTERNALS
)F Function -
(Non-SAA Function)

EXTERNALS is a non-SAA built-in function provided only by TSO/E and
VM.

>>--EXTERNALS()---------------------------------------------------------><

always returns a 0. For example:

    EXTERNALS()    ->    0    /* Always */

The EXTERNALS function returns the number of elements in the
terminal input buffer (system external event queue).    In TSO/E,
there is no equivalent buffer.    Therefore, in the TSO/E
implementation of REXX, the EXTERNALS function always returns a 0.
=FIND
)F Function -
(Non-SAA Function)

FIND is a non-SAA built-in function provided only by TSO/E and VM.

WORDPOS is the preferred built-in function for this type of word
search.    See item WORDPOS for a complete description.

+------------------------------------------------------------------------+
|                                                                        |
| >>--FIND(string,phrase)--------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the word number of the first word of phrase found in string
or returns 0 if phrase is not found or if there are no words in
phrase.    The phrase is a sequence of blank-delimited words.
Multiple blanks between words in phrase or string are treated as a
single blank for the comparison.

Here are some examples:

    FIND('now is the time','is the time')    ->    2
    FIND('now is  the time','is    the')     ->    2
    FIND('now is  the time','is  time ')     ->    0
=FORMAT
)F Function -
+---------------------------------------------------------------------------+
|                                                                           |
| >>--FORMAT(number-------------------------------------------------------> |
|                                                                           |
| >-----------------------------------------------------------------------> |
|      +-,-----------------------------------------------------------+      |
|          +-before-+  +-,----------------------------------------+         |
|                          +-after-+  +-,----------------------+            |
|                                         +-expp-+  +-,expt-+               |
|                                                                           |
| >--)------------------------------------------------------------------->< |
|                                                                           |
+---------------------------------------------------------------------------+

Returns number, rounded and formatted.

The number is first rounded according to standard REXX rules, just as
though the operation number+0 had been carried out. The result is
precisely that of this operation if you specify only number. If you
specify any other options, the number is formatted as follows.

The before and after options describe how many characters are used
for the integer and decimal parts of the result, respectively.    If
you omit either or both of these, the number of characters used for
that part is as needed.

If before is not large enough to contain the integer part of the
number (plus the sign for a negative number), an error results.    If
before is larger than needed for that part, the number is padded on
the left with blanks.    If after is not the same size as the decimal
part of the number, the number is rounded (or extended with zeros)
to fit.    Specifying 0 causes the number to be rounded to an
integer.

Here are some examples:

    FORMAT('3',4)            ->    '   3'
    FORMAT('1.73',4,0)       ->    '   2'
    FORMAT('1.73',4,3)       ->    '   1.730'
    FORMAT('-.76',4,1)       ->    '  -0.8'
    FORMAT('3.03',4)         ->    '   3.03'
    FORMAT(' - 12.73',,4)    ->    '-12.7300'
    FORMAT(' - 12.73')       ->    '-12.73'
    FORMAT('0.000')          ->    '0'

The first three arguments are as described previously.    In addition,
expp and expt control the exponent part of the result, which, by
default, is formatted according to the current NUMERIC settings of
DIGITS and FORM.    The expp sets the number of places for the
exponent part; the default is to use as many as needed (which may be
zero).    The expt sets the trigger point for use of exponential
notation.    The default is the current setting of NUMERIC DIGITS.

If expp is 0, no exponent is supplied, and the number is expressed
in simple form with added zeros as necessary.    If expp is not large
enough to contain the exponent, an error results.

If the number of places needed for the integer or decimal part
exceeds expt or twice expt, respectively, exponential notation is
used.    If expt is 0, exponential notation is always used unless the
exponent would be 0.    (If expp is 0, this overrides a 0 value of
expt.) If the exponent would be 0 when a nonzero expp is specified,
then expp+2 blanks are supplied for the exponent part of the
result.    If the exponent would be 0 and expp is not specified,
simple form is used.

Here are some examples:

    FORMAT('12345.73',,,2,2)    ->    '1.234573E+04'
    FORMAT('12345.73',,3,,0)    ->    '1.235E+4'
    FORMAT('1.234573',,3,,0)    ->    '1.235'
    FORMAT('12345.73',,,3,6)    ->    '12345.73'
    FORMAT('1234567e5',,3,0)    ->    '123456700000.000'
=FORM
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--FORM()---------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the current setting of NUMERIC FORM.    See the NUMERIC
instruction on item NUMERIC for more information.

Here is an example:

    FORM()    ->    'SCIENTIFIC'  /* by default */
=FUZZ
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--FUZZ()---------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the current setting of NUMERIC FUZZ.    See the NUMERIC
instruction on item NUMERIC for more information.

Here is an example:

    FUZZ()    ->    0     /* by default */
=GETMSG
)F Function -
GETMSG is a TSO/E external function. See this item.

+----------------------------------------------------------------------------
|
| >>--GETMSG(msgstem---------------------------------------------------------
|
| >-------------------------------------------------------------------------)
|      +-,-----------------------------------------------------------------+
|          +-msgtype-+  +-,---------------------------------------------+
|                           +-cart-+  +-,----------------------------+
|                                         +-mask-+  +-,-----------+
|                                                       +-time-+
|
+----------------------------------------------------------------------------

GETMSG returns a function code that replaces the function call and
retrieves, in variables, a message that has been issued during a
console session.    Table HH lists the function codes that GETMSG
returns.

Use GETMSG during an extended MCS console session that you
established using the TSO/E CONSOLE command.    Use GETMSG to retrieve
messages that are routed to the user's console but that are not
being displayed at the user's terminal.    The message can be either
solicited (a command response) or unsolicited (other system
messages), or either.    GETMSG retrieves only one message at a time.
The message itself may be more than one line.    Each line of message
text is stored in successive variables.    For more information, see
the description of the msgstem argument on this item.

To use GETMSG, you must:

o     Have CONSOLE command authority

o     Have solicited or unsolicited messages stored rather than
      displayed at the terminal during a console session.  Your
      installation may have set up a console profile for you so that
      the messages are not displayed.  You can also use the TSO/E
      CONSPROF command to specify that solicited or unsolicited
      messages should not be displayed during a console session.

o     Issue the TSO/E CONSOLE command to activate a console session.

You can use the GETMSG function only in REXX execs that run in the
TSO/E address space.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use GETMSG only in environments that are             |
| integrated into TSO/E.                                                 |
|                                                                        |
+------------------------------------------------------------------------+

Responses to commands sent through the network to another system
might be affected as follows:

o     The responses might not be returned as solicited even if a CART
      was specified and preserved; UNSOLDISPLAY(YES) may be required.

o     If the receiving system does not preserve the extended console
      identifier, ROUTCODE(ALL) and UNSOLDISPLAY(YES) might be
      required to receive the responses.

For information about ROUTCODE, see z/OS MVS Initialization and
Tuning Reference.    For information about UNSOLDISPLAY, see z/OS
TSO/E System Programming Command Reference.

Table HH lists the function codes that replace the function call.
The GETMSG function raises the SYNTAX condition if you specify an
incorrect argument on the function call or you specify too many
arguments.    A SYNTAX condition is also raised if a severe error
occurs during GETMSG processing.

+------------------------------------------------------------------------+
| Table HH. Function Codes for GETMSG That Replace the Function Call     |
+------------------------------------------------------------------------|
| Function      |                                                        |
| Code          | Description                                            |
+-------------+----------------------------------------------------------|
| 0             | GETMSG processing was successful.  GETMSG retrieved    |
|               | the message.                                           |
+-------------+----------------------------------------------------------|
| 4             | GETMSG processing was successful.  However, GETMSG     |
|               | did not retrieve the message.                          |
|               |                                                        |
|               | There are several reasons why GETMSG may not be able   |
|               | to retrieve the message based on the arguments you     |
|               | specify on the function call.  GETMSG returns a        |
|               | function code of 4 if one of the following occurs:     |
|               |                                                        |
|               | o   No messages were available to be retrieved         |
|               |                                                        |
|               | o   The messages did not match the search criteria     |
|               |     you specified on the function call                 |
|               |                                                        |
|               | o   You specified the time argument and the time       |
|               |     limit expired before the message was available.    |
+-------------+----------------------------------------------------------|
| 8             | GETMSG processing was successful.  However, you        |
|               | pressed the attention interrupt key during GETMSG      |
|               | processing.  GETMSG did not retrieve the message.      |
+-------------+----------------------------------------------------------|
| 12            | GETMSG processing was not successful.  A console       |
|               | session is not active.  The system issues a message    |
|               | that describes the error.  You must issue the TSO/E    |
|               | CONSOLE command to activate a console session.         |
+-------------+----------------------------------------------------------|
| 16            | GETMSG processing was not successful.  The console     |
|               | session was being deactivated while GETMSG was         |
|               | processing.  The system issues a message that          |
|               | describes the error.                                   |
+------------------------------------------------------------------------+

The arguments you can specify on the GETMSG function are:

msgstem     the stem of the list of variables into which GETMSG places
            the message text.  To place the message text into compound
            variables, which allow for indexing, msgstem should end
            with a period (for example, "messg.").  GETMSG places each
            line of the retrieved message into successive variables.
            For example, if GETMSG retrieves a message that has three
            lines of text, GETMSG places each line of message text
            into the variables messg.1, messg.2, messg.3.  GETMSG
            stores the number of lines of message text in the variable
            ending in 0, messg.0.

            Note:  If messg.0=0, no lines are associated with this
                   message.  This message might be a delete operator
                   message (DOM) request.  For more information about
                   the DOM macro, see z/OS MVS Programming:
                   Authorized Assembler Services Reference ALE-DYN.

            If msgstem does not end with a period, the variable names
            are appended with consecutive numbers.  For example,
            suppose you specify msgstem as "conmsg"  (without a
            period).  If GETMSG retrieves a message that has two lines
            of message text, GETMSG places the text into the variables
            conmsg1 and conmsg2.  The variable conmsg0 contains the
            number of lines of message text, which is 2.

            In addition to the variables into which GETMSG places the
            retrieved message text, GETMSG also sets additional
            variables.  The additional variables relate to the field
            names in the message data block (MDB) for MVS/ESA System
            Product.  For more information about these variables, see
            "Additional Variables That GETMSG Sets"  in item
            -GETMSG-VARSET.

msgtype     the type of message you want to retrieve.  Specify one of
            the following values for msgtype:

            o   SOL

                indicates that you want to retrieve a solicited
                message.  A solicited message is the response from an
                MVS system or subsystem command.

            o   UNSOL

                indicates that you want to retrieve an unsolicited
                message.  An unsolicited message is any message that
                is not issued in response to an MVS system or
                subsystem command.  For example, an unsolicited
                message may be a message that another user sends you
                or a broadcast message.

            o   EITHER

                indicates that you want to retrieve either type of
                message (solicited or unsolicited).  If you do not
                specify the msgtype argument, EITHER is the default.

cart        the command and response token (CART).  The CART is a
            token that lets you associate MVS system commands and
            subcommands with their responses.  When you issue an MVS
            system or subsystem command, you can specify a CART on the
            command invocation.  To use GETMSG to retrieve a
            particular message that is in direct response to the
            command invoked, specify the same CART value.

            GETMSG uses the CART you specify as a search argument to
            obtain the message.  If you specify a CART, GETMSG
            compares the CART you specify with the CARTs for the
            messages that have been routed to the user's console.
            GETMSG retrieves the message, only if the CART you specify
            matches the CART associated with the message.  Otherwise,
            no message is retrieved.

            The cart argument is used only if you are retrieving
            solicited messages, that is, the value for the msgtype
            argument is SOL.  The CART is ignored if you specify UNSOL
            or EITHER for msgtype.

            The cart argument is optional.  If you do not specify a
            CART, GETMSG retrieves the oldest message that is
            available.  The type of message retrieved depends on the
            msgtype argument.

            For cart, you can specify a character string of 1-8
            characters or a hexadecimal string of 1-16 hexadecimal
            digits.  For example:

              'C1D7D7C1F4F9F4F1'X

            If you specify less than 8 characters or less than 16
            hexadecimal digits, the value is padded on the right with
            blanks.  If you specify more than 8 characters or more
            than 16 hexadecimal digits, the value is truncated to the
            first 8 characters or 16 digits and no error message is
            issued.

            For more information, see "Using the Command and Response
            Token (CART) and Mask"  in item -CART-MASK.

mask        search argument that GETMSG uses as a mask with the cart
            argument for obtaining a message.  If you specify a mask,
            GETMSG ANDs the mask value with the CART value that you
            specify on the GETMSG function.  GETMSG also ANDs the mask
            with the CARTs associated with the messages that have been
            routed to the user's console.  GETMSG then compares the
            results of the AND operations.  If a comparison matches,
            GETMSG retrieves the message.  Otherwise, no message is
            retrieved.

            The mask argument is valid only if you are retrieving
            solicited messages and are using a CART.  That is, mask is
            valid only if you specify SOL for msgtype and you specify
            the cart argument.

            The mask argument is optional.  If you do not specify a
            mask, GETMSG does not use a mask value when comparing CART
            values.

            For mask, you can specify a character string of 1-8
            characters or a hexadecimal string of 1-16 hexadecimal
            digits.  For example:

              'FFFFFFFF00000000'X

            If you specify less than 8 characters or less than 16
            hexadecimal digits, the value is padded on the right with
            blanks.  If you specify more than eight characters or more
            than 16 hexadecimal digits, the value is truncated to the
            first eight characters or 16 digits and no error message
            is issued.

            For more information, see "Using the Command and Response
            Token (CART) and Mask"  in item -CART-MASK.

time        the amount of time, in seconds, that GETMSG should wait,
            if the requested message has not yet been routed to the
            user's console.  If you specify a time value and the time
            expires before the message is routed to the user's
            console, GETMSG does not retrieve the message.  Otherwise,
            if the message is available before the time expires,
            GETMSG retrieves the message.

            If you do not specify time, GETMSG uses a time value of 0
            seconds.  If the message has not been routed to the user's
            console, GETMSG does not retrieve the message.
=HE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--HE-------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

HE (Halt Execution) is an immediate command you can use to halt the
execution of a REXX exec.    The HE immediate command is available
only if an exec is running in TSO/E and you press the attention
interrupt key to enter attention mode.    You can enter HE in response
to the REXX attention prompting message, IRX0920I.

HE does not set the halt condition, which is set by the HI (Halt
Interpretation) immediate command.    If you need to halt the
execution of an exec, it is suggested that you use the HI immediate
command whenever possible.    HE is useful if an exec is processing an
external function or subroutine written in a programming language
other than REXX and the function or subroutine goes into a loop.

For more information about how to use the HE immediate command, see
"Debug Aids"    in item -DEBUG-AIDS.

Example

You are running an exec in TSO/E.    The exec invokes an external
subroutine and the subroutine goes into a loop.    To halt execution
of the exec, press the attention interrupt key.    The system issues
the REXX attention prompting message that asks you to enter either a
null line to continue or an immediate command.    Enter HE to halt
execution.
=HI
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--HI-------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

HI (Halt Interpretation) is an immediate command you can use to halt
the interpretation of all currently executing execs.    The HI
immediate command is available only if an exec is running in TSO/E
and you press the attention interrupt key to enter attention mode.
You can enter HI in response to the REXX attention prompting
message, IRX0920I.

After you enter HI, exec processing ends or control passes to a
routine or label if the halt condition trap has been turned on in
the exec.    For example, if the exec contains a SIGNAL ON HALT
instruction and exec processing is interrupted by HI, control passes
to the HALT:    label in the exec.  See Conditions and Condition Traps
in item -CONDS-TRAPS for information about the halt condition.

Example

You are running an exec in TSO/E that is in an infinite loop.    To
halt interpretation of the exec, press the attention interrupt key.
The system issues the REXX attention prompting message that asks you
to enter either a null line to continue or an immediate command.
Enter HI to halt interpretation.
=HT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--HT-------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

HT (Halt Typing) is an immediate command you can use to suppress
terminal output that an exec generates.    The HT immediate command is
available only if an exec is running in TSO/E and you press the
attention interrupt key to enter attention mode.    You can enter HT
in response to the REXX attention prompting message, IRX0920I.

After you enter HT, the exec that is running continues processing,
but the only output that is displayed at the terminal is output from
TSO/E commands that the exec issues.    All other output from the exec
is suppressed.

Example

You are running an exec in TSO/E that calls an internal subroutine
to display a line of output from a loop that repeats many times.
Before the exec calls the subroutine, the exec displays a message
that lets you press the attention interrupt key and then suppress
the output by entering HT.    When the loop is completed, the
subroutine issues EXECUTIL RT to redisplay output.

    /*  REXX program  */
    .
    .
    .
    SAY 'To suppress the output that will be displayed,'
    SAY 'press the attention interrupt key and'
    SAY 'enter HT.'
    CALL printout
    .
    .
    .
    EXIT
    printout:
    DO i = 1 to 10000
    .
    .
    .
    SAY 'The outcome is' ....
    END
    "EXECUTIL RT"
    RETURN
=IF
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--IF--expression-----------THEN-----------instruction--------------> |
|                        +-;-+          +-;-+                            |
|                                                                        |
| >------------------------------------------------------------------->< |
|      +-ELSE-------instruction-+                                        |
|             +-;-+                                                      |
|                                                                        |
+------------------------------------------------------------------------+

IF conditionally processes an instruction or group of instructions
depending on the evaluation of the expression.    The expression is
evaluated and must result in 0 or 1.

The instruction after the THEN is processed only if the result is 1
(true).    If you specify an ELSE, the instruction after the ELSE is
processed only if the result of the evaluation is 0 (false).

Example:

    if answer='YES' then say 'OK!'
                    else say 'Why not?'

Remember that if the ELSE clause is on the same line as the last
clause of the THEN part, you need a semicolon before the ELSE.

Example:

    if answer='YES' then say 'OK!';  else say 'Why not?'

The ELSE binds to the nearest IF at the same level.    You can use the
NOP instruction to eliminate errors and possible confusion when IF
constructs are nested, as in the following example.

Example:

    If answer = 'YES' Then
       If name = 'FRED' Then
          say 'OK, Fred.'
       Else
          nop
    Else
       say 'Why not?'

Notes:

1.    The instruction can be any assignment, command, or keyword
      instruction, including any of the more complex constructs such
      as DO, SELECT, or the IF instruction itself.  A null clause is
      not an instruction, so putting an extra semicolon (or label)
      after the THEN or ELSE is not equivalent to putting a dummy
      instruction (as it would be in PL/I).  The NOP instruction is
      provided for this purpose.

2.    The symbol THEN cannot be used within expression, because the
      keyword THEN is treated differently, in that it need not start a
      clause.  This allows the expression on the IF clause to be ended
      by the THEN, without a ; being required.  If this were not so,
      people who are accustomed to other computer languages would
      experience considerable difficulties.
=Comparison
)F Function -
The comparison operators compare two terms and return the value 1 if
the result of the comparison is true, or 0 otherwise.

The strict comparison operators all have one of the characters
defining the operator doubled.    The ==, \==, /==, and == operators
test for an exact match between two strings.    The two strings must
be identical (character by character) and of the same length to be
considered strictly equal.    Similarly, the strict comparison
operators such as >> or << carry out a simple character-by-character
comparison, with no padding of either of the strings being
compared.    The comparison of the two strings is from left to right.
If one string is shorter than and is a leading substring of another,
then it is smaller than (less than) the other.    The strict
comparison operators also do not attempt to perform a numeric
comparison on the two operands.

For all the other comparison operators, if both terms involved are
numeric, a numeric comparison (in which leading zeros are ignored,
and so forthsee Numeric comparisons in item -NUM-COMPARE) is
effected.    Otherwise, bot terms are treated as character strings
(leading and trailing blanks are ignored, and then the shorter
string is padded with blanks on the right).

Character comparison and strict comparison operations are both
case-sensitive, and for both the exact collating order may depend on
the character set used for the implementation.    For example, in an
EBCDIC environment, lowercase alphabetics precede uppercase, and the
digits 09 are higher than all alphabetics.    In an ASCII environment,
the digits are lower than the alphabetics, and lowercase alphabetics
are higher than uppercase alphabetics.

The comparison operators and operations are:
  =
True if the terms are equal (numerically or when padded, and so forth)
  \=, =, /=
True if the terms are not equal (inverse of =)
  >
Greater than
  <
Less than
  ><
Greater than or less than (same as not equal)
  <>
Greater than or less than (same as not equal)
  >=
Greater than or equal to
  \<, <
Not less than
  <=
Less than or equal to
  \>, >
Not greater than
  ==
True if terms are strictly equal (identical)
  \==, ==, /==
True if the terms are NOT strictly equal (inverse of ==)
  >>
Strictly greater than
  <<
Strictly less than
  >>=
Strictly greater than or equal to
  \<<, <<
Strictly NOT less than
  <<=
Strictly less than or equal to
  \>>, >>
Strictly NOT greater than

Guideline:    Throughout the language, the not character, , is
synonymous with the backslash (\).    You can use the two characters
interchangeably, according to availability and personal preference.
The backslash can appear in the following operators:    \ (prefix
not), \=, \==, \<, \>, \<<, and \>>.
=INDEX
)F Function -
(Non-SAA Function)

INDEX is a non-SAA built-in function provided only by TSO/E and VM.

POS is the preferred built-in function for obtaining the position of
one string in another.    See item POS for a complete description.

+------------------------------------------------------------------------+
|                                                                        |
| >>--INDEX(haystack,needle--------------)---------------------------->< |
|                              +-,start-+                                |
|                                                                        |
+------------------------------------------------------------------------+

Returns the character position of one string, needle, in another,
haystack, or returns 0 if the string needle is not found or is a
null string.    By default the search starts at the first character of
haystack (start has the value 1).    You can override this by
specifying a different start point, which must be a positive whole
number.

Here are some examples:

    INDEX('abcdef','cd')      ->    3
    INDEX('abcdef','xd')      ->    0
    INDEX('abcdef','bc',3)    ->    0
    INDEX('abcabc','bc',3)    ->    5
    INDEX('abcabc','bc',6)    ->    0
=INSERT
)F Function -
+---------------------------------------------------------------------------+
|                                                                           |
| >>--INSERT(new,target---------------------------------------------)---->< |
|                          +-,-------------------------------------+        |
|                              +-n-+  +-,-----------------------+           |
|                                         +-length-+  +-,pad-+              |
|                                                                           |
+---------------------------------------------------------------------------+

Inserts the string new, padded or truncated to length length, into
the string target after the nth character.    The default value for n
is 0, which means insert before the beginning of the string.    If
specified, n and length must be positive whole numbers or zero.    If
n is greater than the length of the target string, padding is added
before the string new also.    The default value for length is the
length of new.    If length is less than the length of the string new,
then INSERT truncates new to length length.    The default pad
character is a blank.

Here are some examples:

    INSERT(' ','abcdef',3)         ->    'abc def'
    INSERT('123','abc',5,6)        ->    'abc  123   '
    INSERT('123','abc',5,6,'+')    ->    'abc++123+++'
    INSERT('123','abc')            ->    '123abc'
    INSERT('123','abc',,5,'-')     ->    '123--abc'
=INTERPRET
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--INTERPRET--expression;------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

INTERPRET processes instructions that have been built dynamically by
evaluating expression.

The expression is evaluated and is then processed (interpreted) just
as though the resulting string were a line inserted into the program
(and bracketed by a DO; and an END;).

Any instructions (including INTERPRET instructions) are allowed, but
note that constructions such as DO...END and SELECT...END must be
complete.    For example, a string of instructions being interpreted
cannot contain a LEAVE or ITERATE instruction (valid only within a
repetitive DO loop) unless it also contains the whole repetitive
DO...END construct.

A semicolon is implied at the end of the expression during
execution, if one was not supplied.

Example:

    data='FRED'
    interpret data '= 4'
    /* Builds the string  "FRED = 4" and        */
    /* Processes:  FRED = 4;                    */
    /* Thus the variable FRED is set to "4"     */

Example:

    data='do 3; say "Hello there!"; end'
    interpret data        /* Displays:          */
                          /*  Hello there!      */
                          /*  Hello there!      */
                          /*  Hello there!      */

Notes:

1.    Label clauses are not permitted in an interpreted character
      string.

2.    If you are new to the concept of the INTERPRET instruction and
      are getting results that you do not understand, you may find
      that executing it with TRACE R or TRACE I in effect is helpful.

      Example:

        /* Here is a small REXX program. */
        Trace Int
        name='Kitty'
        indirect='name'
        interpret 'say "Hello"' indirect'"!"'

      When this is run, it gives the trace:

        kitty
             3 *-* name='Kitty'
               >L>   "Kitty"
             4 *-* indirect='name'
               >L>   "name"
             5 *-* interpret 'say "Hello"' indirect'"!"'
               >L>   "say "Hello""
               >V>   "name"
               >O>   "say "Hello" name"
               >L>   ""!""
               >O>   "say "Hello" name"!""
               *-*  say "Hello" name"!"
               >L>    "Hello"
               >V>    "Kitty"
               >O>    "Hello Kitty"
               >L>    "!"
               >O>    "Hello Kitty!"
        Hello Kitty!

      Here, lines 3 and 4 set the variables used in line 5.  Execution
      of line 5 then proceeds in two stages.  First the string to be
      interpreted is built up, using a literal string, a variable
      (INDIRECT), and another literal string.  The resulting pure
      character string is then interpreted, just as though it were
      actually part of the original program.  Because it is a new
      clause, it is traced as such (the second *-* trace flag under
      line 5) and is then processed.  Again a literal string is
      concatenated to the value of a variable (NAME) and another
      literal, and the final result (Hello Kitty!) is then displayed.

3.    For many purposes, you can use the VALUE function (see item
      VALUE ) instead of the INTERPRET instruction.  The following
      line could, therefore, have replaced line 5 in the last
      example:

        say "Hello" value(indirect)"!"

      INTERPRET is usually required only in special cases, such as
      when two or more statements are to be interpreted together, or
      when an expression is to be evaluated dynamically.
=ITERATE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--ITERATE----------;---------------------------------------------->< |
|               +-name-+                                                 |
|                                                                        |
+------------------------------------------------------------------------+

ITERATE alters the flow within a repetitive DO loop (that is, any DO
construct other than that with a simple DO).

Execution of the group of instructions stops, and control is passed
to the DO instruction.    The control variable (if any) is incremented
and tested, as usual, and the group of instructions is processed
again, unless the DO instruction ends the loop.

The name is a symbol, taken as a constant.    If name is not
specified, ITERATE steps the innermost active repetitive loop.    If
name is specified, it must be the name of the control variable of a
currently active loop (which may be the innermost), and this is the
loop that is stepped.    Any active loops inside the one selected for
iteration are ended (as though by a LEAVE instruction).

Example:

    do i=1 to 4
      if i=2 then iterate
      say i
      end
    /* Displays the numbers:  "1" "3" "4" */

Notes:

1.    If specified, name must match the symbol naming the control
      variable in the DO clause in all respects except case.  No
      substitution for compound variables is carried out when the
      comparison is made.

2.    A loop is active if it is currently being processed.  If a
      subroutine is called (or an INTERPRET instruction is processed)
      during execution of a loop, the loop becomes inactive until the
      subroutine has returned or the INTERPRET instruction has
      completed.  ITERATE cannot be used to step an inactive loop.

3.    If more than one active loop uses the same control variable,
      ITERATE selects the innermost loop.
=JUSTIFY
)F Function -
(Non-SAA Function)

JUSTIFY is a non-SAA built-in function provided only by TSO/E and VM.

+------------------------------------------------------------------------+
|                                                                        |
| >>--JUSTIFY(string,length------------)------------------------------>< |
|                              +-,pad-+                                  |
|                                                                        |
+------------------------------------------------------------------------+

Returns string formatted by adding pad characters between
blank-delimited words to justify to both margins.    This is done to
width length (length must be a positive whole number or zero).    The
default pad character is a blank.

The first step is to remove extra blanks as though SPACE(string) had
been run (that is, multiple blanks are converted to single blanks,
and leading and trailing blanks are removed).    If length is less
than the width of the changed string, the string is then truncated
on the right and any trailing blank is removed.    Extra pad
characters are then added evenly from left to right to provide the
required length, and the pad character replaces the blanks between
words.

Here are some examples:

    JUSTIFY('The blue sky',14)       ->    'The  blue  sky'
    JUSTIFY('The blue sky',8)        ->    'The blue'
    JUSTIFY('The blue sky',9)        ->    'The  blue'
    JUSTIFY('The blue sky',9,'+')    ->    'The++blue'
=LASTPOS (Last Position)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--LASTPOS(needle,haystack--------------)-------------------------->< |
|                                +-,start-+                              |
|                                                                        |
+------------------------------------------------------------------------+

Returns the position of the last occurrence of one string, needle,
in another, haystack.    (See also the POS function.) Returns 0 if
needle is the null string or is not found.    By default the search
starts at the last character of haystack and scans backward.    You
can override this by specifying start, the point at which the
backward scan starts.    start must be a positive whole number and
defaults to LENGTH(haystack) if larger than that value or omitted.

Here are some examples:

    LASTPOS(' ','abc def ghi')      ->    8
    LASTPOS(' ','abcdefghi')        ->    0
    LASTPOS('xy','efgxyz')          ->    4
    LASTPOS(' ','abc def ghi',7)    ->    4
=LEAVE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--LEAVE----------;------------------------------------------------>< |
|             +-name-+                                                   |
|                                                                        |
+------------------------------------------------------------------------+

LEAVE causes an immediate exit from one or more repetitive DO loops
(that is, any DO construct other than a simple DO).

Processing of the group of instructions is ended, and control is
passed to the instruction following the END clause.    The control
variable (if any) will contain the value it had when the LEAVE
instruction was processed.

The name is a symbol, taken as a constant.    If name is not
specified, LEAVE ends the innermost active repetitive loop.    If name
is specified, it must be the name of the control variable of a
currently active loop (which may be the innermost), and that loop
(and any active loops inside it) is then ended.    Control then passes
to the clause following the END that matches the DO clause of the
selected loop.

Example:

    do i=1 to 5
      say i
      if i=3 then leave
      end
    /* Displays the numbers:  "1" "2" "3" */

Notes:

1.    If specified, name must match the symbol naming the control
      variable in the DO clause in all respects except case.  No
      substitution for compound variables is carried out when the
      comparison is made.

2.    A loop is active if it is currently being processed.  If a
      subroutine is called (or an INTERPRET instruction is processed)
      during execution of a loop, the loop becomes inactive until the
      subroutine has returned or the INTERPRET instruction has
      completed.  LEAVE cannot be used to end an inactive loop.

3.    If more than one active loop uses the same control variable,
      LEAVE selects the innermost loop.
=LEFT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--LEFT(string,length------------)--------------------------------->< |
|                           +-,pad-+                                     |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string of length length, containing the leftmost length
characters of string.    The string returned is padded with pad
characters (or truncated) on the right as needed.    The default pad
character is a blank.    length must be a positive whole number or
zero.    The LEFT function is exactly equivalent to:

>>--SUBSTR(string,1,length------------)--><
                              +-,pad-+
Here are some examples:

    LEFT('abc d',8)        ->    'abc d   '
    LEFT('abc d',8,'.')    ->    'abc d...'
    LEFT('abc  def',7)     ->    'abc  de'
=LENGTH
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--LENGTH(string)-------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the length of string.

Here are some examples:

    LENGTH('abcdefgh')    ->    8
    LENGTH('abc defg')    ->    8
    LENGTH('')            ->    0
=LINESIZE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--LINESIZE()------------------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the current terminal line width minus 1 (the point at which
the language processor breaks lines displayed using the SAY
instruction).

If the REXX exec is running in TSO/E background (that is, on the JCL
EXEC statement PGM=IKJEFT01), LINESIZE always returns the value
131.    If the REXX exec is running in TSO/E foreground, the LINESIZE
function always returns the current terminal width (as defined by
the TSO/E TERMINAL command) minus one character.

If the exec is running in a non-TSO/E address space, LINESIZE
returns the logical record length of the OUTDD file (the default
file is SYSTSPRT).    The OUTDD file is specified in the module name
table.
=LISTDSI
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--LISTDSI(---data-set-name-----------------------------------------> |
|                |                +-location-+ |   +-directory-+         |
|                +-filename--file--------------+                         |
|                                                                        |
| >---------------------------)--------------------------------------->< |
|      +-recall-+  +-smsinfo-+                                           |
|                                                                        |
+------------------------------------------------------------------------+

LISTDSI returns one of the following function codes that replace the
function call, and retrieves information about a data set's
allocation, protection, and directory and stores it in specific
variables.    Table SS shows the function codes that replace the
function call.

+------------------------------------------------------------------------+
| Table SS. Function Codes for LISTDSI That Replace the Function Call    |
+------------------------------------------------------------------------|
| Function      |                                                        |
| Code          | Description                                            |
+-------------+----------------------------------------------------------|
| 0             | LISTDSI processing was successful.  Data set           |
|               | information was retrieved.                             |
+-------------+----------------------------------------------------------|
| 4             | LISTDSI processing was successful.  Some data set      |
|               | information is unavailable.  Review the reason code    |
|               | in the returned variable SYSREASON and check the       |
|               | messages returned in SYSMSGLVL1 and SYSMSGLVL2 to      |
|               | determine which information is unavailable.            |
+-------------+----------------------------------------------------------|
| 16            | LISTDSI processing was not successful.  An error       |
|               | occurred.  None of the variables containing            |
|               | information about the data set can be considered       |
|               | valid, except for SYSREASON.  The SYSREASON variable   |
|               | contains the LISTDSI reason code (see this item ).     |
+------------------------------------------------------------------------+

Note:    To be compatible with CLIST processing, a function code of 16
         pis rovided.  LISTDSI does not raise the syntax condition in
         cthis ase, even though the processing was not successful.

You can use LISTDSI to obtain information about a data set that is
available on DASD.    LISTDSI does not directly support data that is
on tape.    LISTDSI supports generation data group (GDG) data sets
when using absolute generation names, but does not support relative
GDG names.    LISTDSI does not support hierarchical file system (HFS)
data sets.    Unpredictable results may occur.

LISTDSI is passed a single argument string.    That string may consist
of several values which are the parameters to LISTDSI, separated by
one or more blanks.    For example:

    argument_string = "REXXEXEC VOLUME(PACK1) NODIRECTORY NORECALL"
    x = LISTDSI(argument_string)

If LISTDSI causes a syntax error (for example, if you specify more
than one argument string), a function code is not returned.    In
addition, none of the LISTDSI variables are set.

The variables in which LISTDSI stores data set information are
described in Table DDD.

To suppress TSO/E messages issued by the LISTDSI function, use the
MSG("OFF") function.    For information about the MSG function, see
4.4.3.

The argument strings you can specify on the LISTDSI function are:

data-set-name the name of the data set about which you want to
            retrieve information. See this item for more information.

location    specifies how you want the data set (as specified in
            data-set-name) located.  You can specify location, only if
            you specify a data set name, not a filename.  For
            location, specify one of the following values.  If you do
            not specify either VOLUME or PREALLOC, the system locates
            the data set through catalog search.

            o   'VOLUME(serial ID)' specifies the serial number of the
                volume where the data set is located.

            o   'PREALLOC' specifies that the location of the
                specified data set is determined by allocating the
                data set, rather than through a catalog search.
                PREALLOC allows data sets that have been previously
                allocated to be located without searching a catalog
                and allows unmounted volumes to be mounted.

filename    the name of an allocated file (ddname) about which you
            want to retrieve information.

file        you must specify the word "FILE"  if you specify filename
            instead of data-set-name.  If you do not specify FILE,
            LISTDSI assumes that you specified a data-set-name.

directory indicates whether you want directory information for a
            partitioned data set (PDS).  For directory, specify one of
            the following:

            o   'DIRECTORY' indicates that you want directory
                information.

            o   'NODIRECTORY' indicates that you do not want directory
                information.  If you do not require directory
                information, NODIRECTORY can significantly improve
                processing.  NODIRECTORY is the default.

recall      indicates whether you want to recall a data set migrated
            by Data Facility Hierarchical Storage Manager (DFHSM).
            For recall, specify one of the following:

            o   'RECALL' indicates that you want to recall a data set
                migrated by DFHSM.  The system recalls the data set
                regardless of its level of migration or the type of
                device to which it has been migrated.

            o   'NORECALL' indicates that you do not want to recall a
                data set.  If the data set has been migrated, the
                system stores an error message.

                If you do not specify either RECALL or NORECALL, the
                system recalls the data set only if it has been
                migrated to a direct access storage device (DASD).

smsinfo     indicates whether you want System Managed Storage (SMS)
            information about an SMS-managed data set.  This
            information includes

            o   type of data set
            o   used space
            o   data class name
            o   storage class name
            o   management class name.

            For smsinfo, specify one of the following:

            o   'SMSINFO' indicates that you want SMS information
                about data-set-name or filename.  SMSINFO Neither
                data-set-name nor filename may refer to a VSAM index
                or data component.

                If the specified data set is not managed by SMS,
                LISTDSI continues, but no SMS information is provided
                in the corresponding REXX variables.

                Specify SMSINFO only if you want SMS information about
                a data set.  NOSMSINFO (the default) significantly
                reduces the execution time of the LISTDSI statement.

            o   'NOSMSINFO' indicates that you do not want SMS
                information about the specified data set.  NOSMSINFO
                is the default.

You can use the LISTDSI function only in REXX execs that run in the
TSO/E address space.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use LISTDSI only in environments that are            |
| integrated into TSO/E.                                                 |
|                                                                        |
+------------------------------------------------------------------------+

You can use the LISTDSI information to determine whether the data
set is the right size or has the right organization or format for a
given task.    You can also use the LISTDSI information as input to
the ALLOCATE command, for example, to create a new data set using
some attributes from the old data set while modifying others.

If you use LISTDSI to retrieve information about a VSAM data set,
LISTDSI stores only the volume serial ID (in variable SYSVOLUME),
the device unit (in variable SYSUNIT), and the data set organization
(in variable SYSDSORG).

If you use LISTDSI to retrieve information about a multiple volume
data set, LISTDSI stores information for the first volume only.
Similarly, if you specify a file name or you specify PREALLOC for
location and you have other data sets allocated to the same file
name, the system may not retrieve information for the data set you
wanted.

LISTDSI

When you use LISTDSI to obtain information about a file, LISTDSI
will return information only about the first data set in the file,
if the file consists of a concatenation of more than one data set.
Likewise, if the ddname specified by filename points to a
multi-volume data set, LISTDSI can return information only about the
first volume, and will not be able to detect that the data is
multi-volume.

If the data set is SMS managed and is capable of expanding to
multiple volumes, but has not yet done so, it is considered a single
volume data set by LISTDSI until it has expanded to the second
volume.    In any case, LISTDSI will only retrieve information for the
first volume referenced by the request.

Specifying Data Set Names

On the LISTDSI function, if you use data-set-name instead of
filename, you can specify the name of a sequential data set or a
partitioned data set (PDS).    You can specify the data-set-name in
any of the following ways:

o     Non fully-qualified data set name that follows the naming
      conventions -- When there is only one set of quotation marks or
      no quotation marks, TSO/E adds your prefix to the data set
      name.

           x = LISTDSI('myrexx.exec')
           x = LISTDSI(myrexx.exec)

o     Fully-qualified data set name -- The extra quotation marks
      prevent TSO/E from adding your prefix to the data set name.

           x = LISTDSI("'sys1.proj.new'")
           x = LISTDSI('''sys1.proj.new''')

o     Variable name that represents a fully-qualified or non
      fully-qualified data set name -- The variable name must not be
      enclosed in quotation marks because quotation marks prevent
      variable substitution.  An example of using a variable for a
      fully-qualified data set name is:

        /* REXX program for ....   */
          .
          .
          .
        var1 = "'sys1.proj.monthly'"
          .
          .
          .
        dsinfo = LISTDSI(var1)
          .
          .
          .
        EXIT

Variables That LISTDSI Sets

Table DDD describes the variables that LISTDSI sets.    For VSAM data
sets, only the variables SYSVOLUME, SYSUNIT, and SYSDSORG are
accurate; all other variables are set to question marks.

+------------------------------------------------------------------------+
| Table DDD. Variables That LISTDSI Sets                                 |
+------------------------------------------------------------------------|
| Variable          | Contents                                           |
+-----------------+------------------------------------------------------|
| SYSDSNAME         | Data set name                                      |
+-----------------+------------------------------------------------------|
| SYSVOLUME         | Volume serial ID                                   |
+-----------------+------------------------------------------------------|
| SYSUNIT           | Generic device type on which volume resides, for   |
|                   | example 3390.                                      |
+-----------------+------------------------------------------------------|
| SYSDSORG          | Data set organization:                             |
|                   |                                                    |
|                   | PS   - Physical sequential                         |
|                   | PSU  - Physical sequential unmovable               |
|                   | DA   - Direct organization                         |
|                   | DAU  - Direct organization unmovable               |
|                   | IS   - Indexed sequential                          |
|                   | ISU  - Indexed sequential unmovable                |
|                   | PO   - Partitioned organization                    |
|                   | POU  - Partitioned organization unmovable          |
|                   | VS   - VSAM                                        |
|                   | ???  - Unknown                                     |
+-----------------+------------------------------------------------------|
| SYSRECFM          | Record format; one to six character combination    |
|                   | of the following:                                  |
|                   |                                                    |
|                   | U    - Records of undefined length                 |
|                   | F    - Records of fixed length                     |
|                   | V    - Records of variable length                  |
|                   | T    - Records written with the track overflow     |
|                   |      feature of the device (3375, 3380, and 3390   |
|                   |      do not support track overflow)                |
|                   | B    - Records blocked                             |
|                   | S    - Records written as standard or spanned      |
|                   |      variable-length blocks                        |
|                   | A    - Records contain ASCII control characters    |
|                   | M    - Records contain machine code control        |
|                   |      characters                                    |
|                   | ?????? - Unknown                                   |
+-----------------+------------------------------------------------------|
| SYSLRECL          | Logical record length                              |
+-----------------+------------------------------------------------------|
| SYSBLKSIZE        | Block size                                         |
+-----------------+------------------------------------------------------|
| SYSKEYLEN         | Key length                                         |
+-----------------+------------------------------------------------------|
| SYSALLOC          | Allocation, in space units                         |
+-----------------+------------------------------------------------------|
| SYSUSED           | Allocation used, in space units.  For a            |
|                   | partitioned data set extended (PDSE), 'N/A' will   |
|                   | be returned; see the description of the variable   |
|                   | SYSUSEDPAGES for used space of a PDSE.             |
+-----------------+------------------------------------------------------|
| SYSUSEDPAGES      | The used space of a partitioned data set           |
|                   | extended (PDSE) in 4K pages.                       |
+-----------------+------------------------------------------------------|
| SYSPRIMARY        | Primary allocation in space units                  |
+-----------------+------------------------------------------------------|
| SYSSECONDS        | Secondary allocation in space units                |
+-----------------+------------------------------------------------------|
| SYSUNITS          | Space units:                                       |
|                   |                                                    |
|                   | CYLINDER  - Space units in cylinders               |
|                   | TRACK     - Space units in tracks                  |
|                   | BLOCK     - Space units in blocks                  |
|                   | ????????  - Space units are unknown                |
+-----------------+------------------------------------------------------|
| SYSEXTENTS        | Number of extents allocated                        |
+-----------------+------------------------------------------------------|
| SYSCREATE         | Creation date                                      |
|                   |                                                    |
|                   | Year/day format, for example: 1990/102             |
+-----------------+------------------------------------------------------|
| SYSREFDATE        | Last referenced date                               |
|                   |                                                    |
|                   | Year/day format, for example: 1990/107             |
|                   |                                                    |
|                   | (Specifying DIRECTORY causes the date to be        |
|                   | updated)                                           |
+-----------------+------------------------------------------------------|
| SYSEXDATE         | Expiration date                                    |
|                   |                                                    |
|                   | Year/day format, for example: 1990/365             |
+-----------------+------------------------------------------------------|
| SYSPASSWORD       | Password indication:                               |
|                   |                                                    |
|                   | NONE      - No password protection                 |
|                   | READ      - Password required to read              |
|                   | WRITE     - Password required to write             |
+-----------------+------------------------------------------------------|
| SYSRACFA          | RACF indication:                                   |
|                   |                                                    |
|                   | NONE      - No RACF protection                     |
|                   | GENERIC   - Generic profile covers this data set   |
|                   | DISCRETE  - Discrete profile covers this data set  |
+-----------------+------------------------------------------------------|
| SYSUPDATED        | Change indicator:                                  |
|                   |                                                    |
|                   | YES       - Data set has been updated              |
|                   | NO        - Data set has not been updated          |
+-----------------+------------------------------------------------------|
| SYSTRKSCYL        | Tracks per cylinder for the unit identified in     |
|                   | the SYSUNIT variable                               |
+-----------------+------------------------------------------------------|
| SYSBLKSTRK        | Blocks (whose size is given in variable            |
|                   | SYSBLKSIZE) per track for the unit identified in   |
|                   | the SYSUNIT variable.  For a PDSE, the value       |
|                   | "N/A"  is returned because a block of size         |
|                   | SYSBLKSIZE can 'span' a track in a PDSE.  The      |
|                   | value contained in SYSUSEDPAGES is a more          |
|                   | meaningful measurement of space usage for a        |
|                   | PDSE.                                              |
+-----------------+------------------------------------------------------|
| SYSADIRBLK        | For a partitioned data set (PDS) the number of     |
|                   | directory blocks allocated will be returned.       |
|                   | For a partitioned data set extended (PDSE),        |
|                   | "NO_LIM"  will be returned because there is no     |
|                   | static allocation for its directory.  A value is   |
|                   | returned only if DIRECTORY is specified on the     |
|                   | LISTDSI statement.                                 |
+-----------------+------------------------------------------------------|
| SYSUDIRBLK        | For a partitioned data set (PDS) the number of     |
|                   | directory blocks used will be returned.  For a     |
|                   | partitioned data set extended (PDSE), "N/A"        |
|                   | will be returned because it is not a static        |
|                   | value.  A value is returned only if DIRECTORY is   |
|                   | specified on the LISTDSI statement.                |
+-----------------+------------------------------------------------------|
| SYSMEMBERS        | Number of members - returned only for              |
|                   | partitioned data sets when DIRECTORY is            |
|                   | specified                                          |
+-----------------+------------------------------------------------------|
| SYSREASON         | LISTDSI reason code                                |
+-----------------+------------------------------------------------------|
| SYSMSGLVL1        | First-level message if an error occurred           |
+-----------------+------------------------------------------------------|
| SYSMSGLVL2        | Second-level message if an error occurred          |
+-----------------+------------------------------------------------------|
| SYSDSSMS          | Contains information about the type of a data      |
|                   | set, provided by DFSMS/MVS.                        |
|                   |                                                    |
|                   | If the SMS DSNTYPE information could not be        |
|                   | retrieved, the SYSDSSMS variable contains:         |
|                   |                                                    |
|                   | SEQ       for a sequential data set                |
|                   | PDS       for a partitioned data set               |
|                   | PDSE      for a partitioned data set extended.     |
|                   |                                                    |
|                   | If the data set is a PDSE and the SMS DSNTYPE      |
|                   | information could be retrieved, the SYSDSSMS       |
|                   | variable contains:                                 |
|                   |                                                    |
|                   | LIBRARY             for an empty PDSE              |
|                   | PROGRAM_LIBRARY     for a partitioned data set     |
|                   |                     extended program library       |
|                   | DATA_LIBRARY        for a partitioned data set     |
|                   |                     extended data library.         |
+-----------------+------------------------------------------------------|
| SYSDATACLASS((1)| The SMS data class name - returned only if           |
|                   | SMSINFO is specified on the LISTDSI statement      |
|                   | and the data set is managed by SMS.                |
+-----------------+------------------------------------------------------|
| SYSSTORCLASS((1)| The SMS storage class name - returned only if        |
|                   | SMSINFO is specified on the LISTDSI statement      |
|                   | and the data set is managed by SMS.                |
+-----------------+------------------------------------------------------|
| SYSMGMTCLASS((1)| The SMS management class name - returned only if     |
|                   | SMSINFO is specified on the LISTDSI statement      |
|                   | and the data set is managed by SMS.                |
+-----------------+------------------------------------------------------|
| SYSSEQDSNTYPE     | Indicates the type of sequential data set:         |
|                   |                                                    |
|                   | BASIC - regular sequential data set                |
|                   |                                                    |
|                   | LARGE - large sequential data set                  |
|                   |                                                    |
|                   | EXTENDED - an extended sequential data set         |
|                   |                                                    |
|                   | See DFSMS for more information about extended,     |
|                   | basic, and large sequential data sets.             |
+------------------------------------------------------------------------|
| Note:                                                                  |
|                                                                        |
|          1.  These variables require either MVS/DFP 3.2 (or later)     |
|              or DFSMS/MVS 1.1 (or later) to be active on your          |
|              system.  For data sets not managed by SMS these           |
|              variables return a null string.                           |
+------------------------------------------------------------------------+

Reason Codes

Reason codes from the LISTDSI function appear in variable
SYSREASON.    Table OOO shows the LISTDSI reason codes.  With each
reason code the REXX variable SYSMSGLVL2 is set to message
IKJ584nnI, where nn is the reason code.    These messages are
described in z/OS TSO/E Messages.

+------------------------------------------------------------------------+
| Table OOO. LISTDSI Reason Codes                                        |
+------------------------------------------------------------------------|
| Reason Code       | Description                                        |
+-----------------+------------------------------------------------------|
| 0                 | Normal completion.                                 |
+-----------------+------------------------------------------------------|
| 1                 | Error parsing the function.                        |
+-----------------+------------------------------------------------------|
| 2                 | Dynamic allocation processing error.               |
+-----------------+------------------------------------------------------|
| 3                 | The data set is a type that cannot be processed.   |
+-----------------+------------------------------------------------------|
| 4                 | Error determining UNIT name.                       |
+-----------------+------------------------------------------------------|
| 5                 | Data set not cataloged.                            |
+-----------------+------------------------------------------------------|
| 6                 | Error obtaining the data set name.                 |
+-----------------+------------------------------------------------------|
| 7                 | Error finding device type.                         |
+-----------------+------------------------------------------------------|
| 8                 | The data set does not reside on a direct access    |
|                   | storage device.                                    |
+-----------------+------------------------------------------------------|
| 9                 | DFHSM migrated the data set. NORECALL prevents     |
|                   | retrieval.                                         |
+-----------------+------------------------------------------------------|
| 11                | Directory information was requested, but you lack  |
|                   | authority to access the data set.                  |
+-----------------+------------------------------------------------------|
| 12                | VSAM data sets are not supported.                  |
+-----------------+------------------------------------------------------|
| 13                | The data set could not be opened.                  |
+-----------------+------------------------------------------------------|
| 14                | Device type not found in unit control block (UCB)  |
|                   | tables.                                            |
+-----------------+------------------------------------------------------|
| 17                | System or user abend occurred.                     |
+-----------------+------------------------------------------------------|
| 18                | Partial data set information was obtained.         |
+-----------------+------------------------------------------------------|
| 19                | Data set resides on multiple volumes.              |
+-----------------+------------------------------------------------------|
| 20                | Device type not found in eligible device table     |
|                   | (EDT).                                             |
+-----------------+------------------------------------------------------|
| 21                | Catalog error trying to locate the data set.       |
+-----------------+------------------------------------------------------|
| 22                | Volume not mounted.                                |
+-----------------+------------------------------------------------------|
| 23                | Permanent I/O error on volume.                     |
+-----------------+------------------------------------------------------|
| 24                | Data set not found.                                |
+-----------------+------------------------------------------------------|
| 25                | Data set migrated to non-DASD device.              |
+-----------------+------------------------------------------------------|
| 26                | Data set on MSS (Mass Storage) device.             |
+-----------------+------------------------------------------------------|
| 27                | No volume serial is allocated to the data set.     |
+-----------------+------------------------------------------------------|
| 28                | The ddname must be one to eight characters.        |
+-----------------+------------------------------------------------------|
| 29                | Data set name or ddname must be specified.         |
+-----------------+------------------------------------------------------|
| 30                | Data set is not SMS-managed.                       |
+-----------------+------------------------------------------------------|
| 31                | ISITMGD macro returned with bad return code and    |
|                   | reason code. Return code and reason code can be    |
|                   | found in message IKJ58431I, which is returned in   |
|                   | variable &SYSMSGLVL2.                              |
+-----------------+------------------------------------------------------|
| 32                | Unable to retrieve SMS information. DFSMS/MVS has  |
|                   | incorrect level.                                   |
+-----------------+------------------------------------------------------|
| 33                | Unable to retrieve SMS information.  DFSMS/MVS     |
|                   | is not active.                                     |
+-----------------+------------------------------------------------------|
| 34                | Unable to retrieve SMS information. OPEN error.    |
+-----------------+------------------------------------------------------|
| 35                | Unexpected error from DFSMS/MVS internal service   |
|                   | IGWFAMS.                                           |
+-----------------+------------------------------------------------------|
| 36                | Unexpected error from the SMS service module.      |
+-----------------+------------------------------------------------------|
| 37                | Unexpected error from DFSMS service IGGCSI00.      |
+------------------------------------------------------------------------+

Examples:

The following are some examples of using LISTDSI.

1.    To set variables with information about data set
      USERID.WORK.EXEC, use the LISTDSI function as follows:

       x = LISTDSI(work.exec)
       SAY 'Function code from LISTDSI is:                 ' x
       SAY 'The data set name is:                          ' sysdsname
       SAY 'The device unit on which the volume resides is:' sysunit
       SAY 'The record format is:                          ' sysrecfm
       SAY 'The logical record length is:                  ' syslrecl
       SAY 'The block size is:                             ' sysblksize
       SAY 'The allocation in space units is:              ' sysalloc
       SAY 'Type of RACF protection is:                    ' sysracfa

      Output from the example might be:

       Function code from LISTDSI is:                   0
       The data set name is:                            USERID.WORK.EXEC
       The device unit on which the volume resides is:  3380
       The record format is:                            VB
       The logical record length is:                    255
       The block size is:                               6124
       The allocation in space units is:                33
       Type of RACF protection is:                      GENERIC

2.    To retrieve information about the DD called APPLPAY, you can use
      LISTDSI as follows:

        ddinfo = LISTDSI("applpay" "FILE")

3.    Suppose you want to retrieve information about a PDS called
      SYS1.APPL.PAYROLL, including directory information.  You do not
      want the PDS to be located through a catalog search, but have
      the location determined by the allocation of the data set.  You
      can specify LISTDSI as follows:

        /*  REXX program for ....   */
          .
          .
          .
        var1 = "'sys1.appl.payroll'"
        infod = "directory"
          .
          .
          .
        pdsinfo = LISTDSI(var1 infod "prealloc")
          .
          .
          .
        EXIT

      In the example, the variable var1 was assigned the name of the
      PDS (SYS1.APPL.PAYROLL).  Therefore, in the LISTDSI function
      call, var1 is not enclosed in quotation marks to allow for
      variable substitution.  Similarly, the variable infod was
      assigned the value "directory", so in the LISTDSI function,
      infod becomes the word "directory".  The PREALLOC argument is
      enclosed in quotation marks to prevent any type of
      substitution.  After the language processor evaluates the
      LISTDSI function, it results in the following function call
      being processed:

        LISTDSI('sys1.appl.payroll' directory prealloc)

4.    The LISTDSI function issues message IKJ56709I if a syntactically
      invalid data set name is passed to the function.  To prevent
      this message from being displayed, use the MSG('OFF') function.

        dsname = "'ABCDEFGHIJ.XYZ'"  /*syntactically invalid name,
                                       because a qualifier is longer
                                       than 8 characters            */
        msgval = MSG('OFF')          /* save current MSG value and
                                        suppress messages           */
        x = LISTDSI(dsname)          /* Retrieve data set info      */
        say 'Function Code returned by LISTDSI ==> ' x
        msgval = MSG(msgval)         /* Restore MSG setting         */
        exit 0

Special Considerations

LISTDSI considers file names starting with 'SYS' followed by five
digits to be system-generated file names.    If you use LISTDSI to
obtain information about a data set that was preallocated multiple
times using file names starting with 'SYS' followed by five digits,
an existing file may be freed.
=MAKEBUF
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--MAKEBUF--------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Use the MAKEBUF command to create a new buffer on the data stack.
The MAKEBUF command can be issued from REXX execs that execute in
both the TSO/E address space and non-TSO/E address spaces.

Initially, the data stack contains one buffer, which is known as
buffer 0.    You create additional buffers using the MAKEBUF command.
MAKEBUF returns the number of the buffer it creates in the REXX
special variable RC.    For example, the first time an exec issues
MAKEBUF, it creates the first buffer and returns a 1 in the special
variable RC.    The second time MAKEBUF is used, it creates another
buffer and returns a 2 in the special variable RC.

To remove buffers from the data stack that were created with the
MAKEBUF command, use the DROPBUF command (see item DROPBUF ).

After the MAKEBUF command executes, it sets the REXX special
variable RC to the number of the buffer it created.

+--------------------------------------------------------------------------+
| Return Code    | Meaning                                                 |
+--------------+-----------------------------------------------------------|
| 1              | A single additional buffer after the original buffer 0  |
|                | now exists on the data stack.                           |
+--------------+-----------------------------------------------------------|
| 2              | A second additional buffer after the original buffer 0  |
|                | now exists on the data stack.                           |
+--------------+-----------------------------------------------------------|
| 3              | A third additional buffer after the original buffer     |
|                | 0 now exists on the data stack.                         |
+--------------+-----------------------------------------------------------|
| n              | An nth additional buffer after the original buffer      |
|                | 0 now exists on the data stack.                         |
+--------------------------------------------------------------------------+

Example

An exec (execa) places two elements, elem1 and elem2, on the data
stack.    The exec calls a subroutine (sub3) that also places an
element, elem3, on the data stack.    The exec (execa) and the
subroutine (sub3) each create a buffer on the data stack so they do
not share their data stack information.    Before the subroutine
returns, it uses the DROPBUF command to remove the buffer it
created.

    /*  REXX program to ...  */
    execa:
    .
    .
    .
      "MAKEBUF"                 /* buffer created */
      SAY 'The number of buffers created is' RC   /* RC = 1 */
      PUSH elem1
      PUSH elem2
      CALL sub3
    .
    .
    .
    exit
    sub3:
       "MAKEBUF"                /* second buffer created */
       PUSH elem3
    .
    .
    .
       "DROPBUF"                /* second buffer created is deleted */
    .
    .
    .
       RETURN
=Arithmetic
)F Function -
You can combine character strings that are valid numbers (see Tokens    n
i item -TOKENS) using the arithmetic operators:

+             Add
-             Subtract
*             Multiply
/             Divide
%             Integer divide (divide and return the integer part of
              results)
//            Remainder (divide and return the remainder not modulo,
              because result may be negative)
**            Power (raise a number to a whole-number power)
Prefix -      Same as the subtraction: 0 - number
Prefix +      Same as the addition: 0 + number

Note if an arithmetic result is shown in exponential
notation, it is likely rounding has occurred.
=MAX (Maximum)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
|             <-,----+                                                   |
| >>--MAX(---number---)----------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the largest number from the list specified, formatted
according to the current NUMERIC settings.

Here are some examples:

    MAX(12,6,7,9) -> 12
    MAX(17.3,19,17.03) -> 19
    MAX(-7,-3,-4.3) -> -3
    MAX(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,MAX(20,21)) ->
    21

Implementation maximum:    You can specify up to 20 numbers, and can
nest calls to MAX if more arguments are needed.
=MIN (Minimum)
)F Function -
            <-,----+
>>--MIN(---number---)---------------------------------------------------><

returns the smallest number from the list specified, formatted
according to the current NUMERIC settings.

Here are some examples:
    MIN(12,6,7,9) -> 6
    MIN(17.3,19,17.03) -> 17.03
    MIN(-7,-3,-4.3) -> -7
    MIN(21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,MIN(2,1)) ->
    1

Implementation maximum:    You can specify up to 20 numbers, and can
nest calls to MIN if more arguments are needed.
=MSG
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--MSG(------------)----------------------------------------------->< |
|            +-option-+                                                  |
|                                                                        |
+------------------------------------------------------------------------+

MSG returns the value ON or OFF, which indicates the status of the
displaying of TSO/E messages.    That is, MSG indicates whether TSO/E
messages are being displayed while the exec is running.

Using MSG, you can control the display of TSO/E messages from TSO/E
commands and TSO/E external functions.    Use the following options to
control the display of TSO/E informational messages.    Informational
messages are automatically displayed unless an exec uses MSG(OFF) to
inhibit their display.

ON          returns the previous status of message issuing (ON or OFF)
            and allows TSO/E informational messages to be displayed
            while an exec is running.

OFF         returns the previous status of message issuing (ON or OFF)
            and inhibits the display of TSO/E informational messages
            while an exec is running.

Here are some examples:

    msgstat = MSG()     ->   'OFF'  /* returns current setting (OFF) */
    stat = MSG('off')   ->   'ON'   /* returns previous setting (ON)
                                       and inhibits message display  */

You can use the MSG function only in REXX execs that run in the
TSO/E address space.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use MSG only in environments that are integrated     |
| into TSO/E.                                                            |
|                                                                        |
+------------------------------------------------------------------------+

When an exec uses the MSG(OFF) function to inhibit the display of
TSO/E messages, messages are not issued while the exec runs and
while functions and subroutines called by that exec run.    The
displaying of TSO/E messages resumes if you use the MSG(ON) function
or when the original exec ends.    However, if an exec invokes another
exec or CLIST using the EXEC command, message issuing status from
the invoking exec is not carried over into the newly-invoked
program.    The newly-invoked program automatically displays TSO/E
messages, which is the default.

The MSG function is functionally equivalent to the CONTROL MSG and
CONTROL NOMSG statements for TSO/E CLISTs.

In non-TSO/E address spaces, you cannot control message output using
the MSG function.    However, if you use the TRACE OFF keyword
instruction, messages do not go to the output file (SYSTSPRT, by
default).

Examples:

The following are some examples of using MSG.

1.    To inhibit the display of TSO/E informational messages while an
      exec is running, use MSG as follows:

        msg_status = MSG("OFF")

2.    To ensure that messages associated with the TSO/E TRANSMIT
      command are not displayed before including the TRANSMIT command
      in an exec, use the MSG function as follows:

        IF MSG() = 'OFF' THEN,
          "TRANSMIT node.userid DA(myrexx.exec)"
        ELSE
          DO
            x = MSG("OFF")
            "TRANSMIT node.userid DA(myrexx.exec)"
            a = MSG(x)        /* resets message value */
          END
=MVSVAR
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--MVSVAR(arg_name)------------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

MVSVAR returns information about MVS, TSO/E, and the current
session, such as the symbolic name of the MVS system, or the
security label of the TSO/E session.

The MVSVAR function is available in any MVS address space.

The information returned depends on the arg_name value specified on
the function call.    The following items of information are available
for retrieval:

SYSAPPCLU the APPC/MVS logical unit (LU) name

SYSDFP      the level of MVS/Data Facility Product (MVS/DFP)

SYSMVS      the level of the base control program (BCP) component of
            z/OS

SYSNAME     the name of the system your REXX exec is running on, as
            specified in the SYSNAME statement in SYS1.PARMLIB member
            IEASYSxx

SYSOPSYS    the z/OS name, version, release, modification level, and
            FMID.

SYSSECLAB the security label (SECLABEL) name of the TSO/E session

SYSSMFID    identification of the system on which System Management
            Facilities (SMF) is active

SYSSMS      indicator whether DFSMS/MVS is available to your REXX exec

SYSCLONE    MVS system symbol representing its system name

SYSPLEX     the MVS sysplex name as found in the COUPLExx or LOADxx
            member of SYS1.PARMLIB

SYMDEF      symbolic variables of your MVS system

Note:    For information about other system variables see "SYSVAR" in
         item SYSVAR.

These items of information will now be described one by one.

SYSAPPCLU the APPC/MVS logical unit (LU) name.    The LU name
            identifies the TSO/E address space, where your REXX exec
            is running, as the SNA addressable unit for Advanced
            Program-to-Program Communications (APPC).  The LU name is
            obtained by using the APPC/MVS Advanced TP Callable
            Services (ATBEXAI - Information Extract Service).

            The LU name is returned as a character string.  Trailing
            blanks are truncated.  A null string is returned if:

            o   There is no APPC activity in the address space where
                the REXX exec is running

            o   No LU name is provided by the APPC/MVS Advanced TP
                Callable Services

SYSDFP      the level of MVS/Data Facility Product (MVS/DFP) installed
            on your system.  The value returned is in the format
            cc.vv.rr.mm, where cc is the component, vv the version, rr
            the release number, and mm the modification level.  All
            values are two-digit decimal numbers.

            A value of 00 for cc indicates a pre-DFSMS/MVS component,
            whereas any value other than 00 indicates a DFSMS/MVS
            component or a follow-on component.

SYSMVS      the level of the base control program (BCP) component of
            z/OS.

            The value returned is that of the CVTPRODN field in the
            communications vector table (CVT), for example SP7.0.1.
            Trailing blanks are removed.

            The format of the value returned by SYSMVS may change in
            future, but will remain the content of the CVTPRODN
            field.

            OS/390 Users:  To provide customers with the least
            disruptive change when changing from MVS/ESA SP 5.x to
            OS/390, the format of the CVTPRODN field is maintained and
            contains SP5.3.0 for OS/390 Release 1.  This is because
            some products test byte 3 to see if it is "5", which
            indicates that certain functions are available.

SYSNAME     the name of the system your REXX exec is running on, as
            specified in the SYSNAME statement in SYS1.PARMLIB member
            IEASYSxx.

            The system name can be used in various ways:

            o   In a multi-system global resource serialization
                complex, the name identifies each system in the
                complex.

            o   The system also uses this value to uniquely identify
                the originating system in messages in the multiple
                console support (MCS) hardcopy log and in the display
                created by the DISPLAY R command.

            o   The value of SYSNAME is used as the name of the system
                log (SYSLOG).

SYSOPSYS    the z/OS name, version, release, modification level, and
            FMID.  For example,

              /* REXX */
              mvsstring = MVSVAR('SYSOPSYS')
              say mvsstring
              exit 0

            may return a string of z/OS 01.01.00 JBB7713, where z/OS
            represents the product name, followed by a blank
            character, followed by an eight-character string
            representing version, release, modification number,
            followed by a blank character, followed by the FMID.

            SYSOPSYS was introduced after TSO/E Version 2 Release 5
            with APAR OW17844.  If you use this variable in a
            environment earlier than TSO/E 2.5, or without the PTF
            associated with APAR OW17844, the system returns a null
            string.

SYSSECLAB the security label (SECLABEL) name of the TSO/E session
            where the REXX exec was started.  Trailing blanks are
            removed.

            Note:  The use of this argument requires that RACF is
                   installed, and that security label checking has
                   been activated.  If no security information is
                   found, the function returns a null string.

SYSSMFID    identification of the system on which System Management
            Facilities (SMF) is active.  The value returned is as
            specified in SYS1.PARMLIB member SMFPRMxx on the SID
            statement.  Trailing blanks are removed.

            Note that the value returned by arguments SYSSMFID and
            SYSNAME can be the same in your installation.  See z/OS
            MVS Initialization and Tuning Reference for more details
            on the SYSNAME and SID statement in member SMFPRMxx.

SYSSMS      indicator whether DFSMS/MVS is available to your REXX
            exec.  The function returns one of the following character
            strings:

            UNAVAILABLE DFSMS/MVS is not available on your system.
            INACTIVE DFSMS/MVS is available on your system but not
            active.
            ACTIVE DFSMS/MVS is available and active, so your REXX
            exec can depend on it.

            Prerequisite:  This argument requires MVS/Data Facility
            Product (MVS/DFP) Version 3.3 or later.  If used with
            lower releases, an error message is issued.

The following three arguments are in support of a SYSPLEX
configuration.    They return information about the SYSPLEX as stored
in various members of SYS1.PARMLIB.    The returned values can be
used, for example, to uniquely identify or build datasets or other
resources belonging to a specific system within the SYSPLEX.

SYSCLONE
       MVS system symbol representing its system name.  It is a 1- to
       2-byte shorthand notation for the system name.  The value is
       obtained from SYS1.PARMLIB member IEASYMxx (4).  For example,
       if SYSCLONE(A1) is specified in IEASYMxx, then

         MVSVAR('SYSCLONE')

       returns a value of A1.  A null string is returned if no MVS
       SYSCLONE ID is specified in IEASYMxx.

SYSPLEX
       the MVS sysplex name as found in the COUPLExx or LOADxx member
       of SYS1.PARMLIB.  The returned value has a maximum of eight
       characters.  Trailing blanks are removed.  If no sysplex name
       is specified in SYS1.PARMLIB, the function returns a null
       string.

SYMDEFstring SYMDEF
       the value represented by the variable string as SYMDEF
       specified in SYS1.PARMLIB member IEASYMxx (4) on the SYSDEF
       ...  SYMDEF statement.  Or, string can also be one of the
       system static or dynamic symbols as defined in z/OS MVS
       Initialization and Tuning Reference.  For example, if
       SYMDEF(³SYSTEMA = ÛSAÛ) is specified in IEASYMxx, then

         X = MVSVAR('SYMDEF','SYSTEMA')

       returns a value of SA.  A null string is returned if the
       symbolic name is not specified in IEASYMxx and is not one of
       the standard static or dynamic symbols defined by MVS.

       You can also retrieve the value for one of the MVS defined
       static or dynamic systems symbols.  For example:

         X = MVSVAR('SYMDEF',JOBNAME )  /*Returns JOBNAME
                                                  BOB perhaps      */

       Refer to z/OS MVS Initialization and Tuning Reference for a
       discussion and list of the currently defined MVS static and
       dynamic symbols.

       For example, you can retrieve the IPL Volume Serial Name of
       your system using

         SAY MVSVAR('SYMDEF','SYMR1')   /*may return 640S06
                                          as IPL Vol. Ser. Name */

       The MVSVAR('SYMDEF',string) function goes through REXX
       substitution first, the result of which must be a 1-8 character
       name specifying the symbol that has been defined in the SYMDEF
       statement.  Any other values including REXX delimiters may
       cause unpredictable results.

Examples:

1.    This example shows how to retrieve the current JES node name
      (which is useful to know before processing is allowed to
      continue).

        nodenam = MVSVAR('SYSNODE')

2.    This example shows how to retrieve information about a SYSPLEX
      configuration.

      Assume your installation has defined, in member
      SYS1.PARMLIB(IEASYM11), certain variables that are applicable on
      a system wide basis.  Assume further that one of them starts
      with the string BOOK and is concatenated by the sysclone ID, for
      example

        SYMDEF(&BOOKA1='DIXI')

      You can obtain the value of this variable as follows.

        tempvar = 'BOOK'||MVSVAR('SYSCLONE') /* the result could be */
                              /* BOOKA1 where A1 is obtained as the */
                              /* result of MVSVAR('SYSCLONE')       */
        instvar = MVSVAR('SYMDEF',tempvar)   /* the result could be */
                            /* DIXI if in IEASYM11 the statement    */
                            /* SYMDEF(&DATASA1='DIXI') had been     */
                            /* included by the system administrator */

Checking for Prerequisite Program Level

Several of the MVSVAR arguments require a minimum prerequisite
program level.

Running on a downlevel release causes a syntax error accompanied by
an error message.    If you do not have SYNTAX trap enabled, the REXX
exec ends.    You may avoid termination of the REXX exec by testing
for the proper program level as shown in the following examples.

Example 1: Testing for Proper MVS Level:

    /*REXX*/
    IF MVSVAR('SYSMVS') >= 'SP5.2.0' THEN
    SAY MVSVAR('SYSCLONE') /* yes, we can use the SYSCLONE argument */
    EXIT 0

Example 2: Testing for Proper DFP Level:

    /*REXX*/
    IF MVSVAR('SYSDFP') >= '00.03.03.00' THEN
    SAY MVSVAR('SYSSMS')   /* yes, we can use the SYSSMS argument   */
    EXIT 0

 (4) Introduced with MVS/ESA SP 5.2; provides a mechanism to
      assign system substitution symbols names and values.
=NEWSTACK
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--NEWSTACK-------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Creates a new data stack and basically hides or isolates the current
data stack.    Elements on the previous data stack cannot be accessed
until a DELSTACK command is issued to delete the new data stack and
any elements remaining in it.

The NEWSTACK command can be used in REXX execs that execute in both
the TSO/E address space and non-TSO/E address spaces.

After an exec issues the NEWSTACK command, any element that is
placed on the data stack with a PUSH or QUEUE instruction is placed
on the new data stack.    If an exec calls a routine (function or
subroutine) after the NEWSTACK command is issued, that routine also
uses the new data stack and cannot access elements on the previous
data stack, unless it issues a DELSTACK command.    If you issue a
NEWSTACK command, you must issue a corresponding DELSTACK command to
delete the data stack that NEWSTACK created.

When there are no more elements on the new data stack, PULL obtains
information from the terminal (TSO/E address space) or the input
stream (non-TSO/E address space), even though elements remain in the
previous data stack (in non-TSO/E address spaces, the default input
stream is SYSTSIN).    To access elements on the previous data stack,
issue a DELSTACK command.    If a new data stack was not created,
DELSTACK removes all elements from the original data stack.

For information about the PULL instruction, see item PULL.

Multiple new data stacks can be created, but only elements on the
most recently created data stack are accessible.    To find out how
many data stacks have been created, use the QSTACK command.    To find
the number of elements on the most recently created stack, use the
QUEUED () built-in function.

If multiple language processor environments are chained together in
a non-TSO/E address space and a new data stack is created with the
NEWSTACK command, the new data stack is available only to execs that
execute in the language processor environment in which the new data
stack was created.    The other environments in the chain cannot
access the new data stack.

Examples

1.    To protect elements placed on the data stack from a subroutine
      that might also use the data stack, you can use the NEWSTACK and
      DELSTACK commands as follows:

        PUSH element1
        PUSH element2
        .
        .
        .
        "NEWSTACK"     /* data stack 2 created */
        CALL sub
        "DELSTACK"     /* data stack 2 deleted */
        .
        .
        .
        PULL stackelem
        .
        .
        .
        PULL stackelem
        EXIT

2.    To put elements on the data stack and prevent the elements from
      being used as prompts for a TSO/E command, use the NEWSTACK
      command as follows:

        "PROFILE PROMPT"
        x = PROMPT("ON")
        PUSH elem1
        PUSH elem2
        "NEWSTACK"   /* data stack 2 created */
        "ALLOCATE"   /* prompts the user at the terminal for input. */
        .
        .
        .
        "DELSTACK"   /* data stack 2 deleted */

3.    To use MVS batch to execute an exec named ABC, which is a member
      in USERID.MYREXX.EXEC, use program IRXJCL and include the exec
      name after the PARM parameter on the EXEC statement.

//MVSBATCH EXEC  PGM=IRXJCL,
//               PARM='ABC'
//SYSTSPRT DD    DSN=USERID.IRXJCL.OUTPUT,DISP=OLD
//SYSEXEC  DD    DSN=USERID.MYREXX.EXEC,DISP=SHR

      Exec ABC creates a new data stack and then put two elements on
      the new data stack for module MODULE3.

        "NEWSTACK"   /* data stack 2 created */
        PUSH elem1
        PUSH elem2
        ADDRESS LINK "module3"
        .
        .
        .
        "DELSTACK"   /* data stack 2 deleted */
        .
        .
        .
=NOP
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--NOP;------------------------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

NOP is a dummy instruction that has no effect.    It can be useful as
the target of a THEN or ELSE clause:

Example:

    Select
       when a=c then nop           /* Do nothing */
       when a>c then say 'A > C'
       otherwise     say 'A < C'
    end

Tip:    Putting an extra semicolon instead of the NOP would merely
insert a null clause, which would be ignored.    The second WHEN
clause would be seen as the first instruction expected after the
THEN, and would, therefore, be treated as a syntax error.    NOP is a
true instruction, however, and is, therefore, a valid target for the
THEN clause.
=NUMERIC
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--NUMERIC----DIGITS------------------------------;---------------->< |
|                |        +-expression1-+           |                    |
|                |      +-SCIENTIFIC-------------+  |                    |
|                +-FORM-+------------------------+--|                    |
|                |      +-ENGINEERING------------|  |                    |
|                |      +------------expression2-+  |                    |
|                |         +-VALUE-+                |                    |
|                +-FUZZ-----------------------------+                    |
|                       +-expression3-+                                  |
|                                                                        |
+------------------------------------------------------------------------+

NUMERIC changes the way in which a program carries out arithmetic
operations.

NUMERIC DIGITS
      controls the precision to which arithmetic operations and
      arithmetic built-in functions are evaluated.  If you omit
      expression1, the precision defaults to 9 digits.  Otherwise,
      expression1 must evaluate to a positive whole number and must be
      larger than the current NUMERIC FUZZ setting.

      There is no limit to the value for DIGITS (except the amount of
      storage available), but note that high precisions are likely to
      require a good deal of processing time.  It is suggested that
      you use the default value wherever possible.

      You can retrieve the current NUMERIC DIGITS setting with the
      DIGITS built-in function.  See "DIGITS"  in item DIGITS.

NUMERIC FORM
      controls which form of exponential notation REXX uses for the
      result of arithmetic operations and arithmetic built-in
      functions.  This may be either SCIENTIFIC (in which case only
      one, nonzero digit appears before the decimal point) or
      ENGINEERING (in which case the power of 10 is always a multiple
      of 3).  The default is SCIENTIFIC.  The subkeywords SCIENTIFIC
      or ENGINEERING set the FORM directly, or it is taken from the
      result of evaluating the expression (expression2) that follows
      VALUE.  The result in this case must be either SCIENTIFIC or
      ENGINEERING.  You can omit the subkeyword VALUE if expression2
      does not begin with a symbol or a literal string (that is, if it
      starts with a special character, such as an operator character
      or parenthesis).

      You can retrieve the current NUMERIC FORM setting with the FORM
      built-in function.  See "FORM"  in item FORM.

NUMERIC FUZZ
      controls how many digits, at full precision, are ignored during
      a numeric comparison operation.  If you
      omit expres the default is 0 digits.  Otherwise, expression3
      must evaluate to 0 or a positive whole number, rounded if
      necessary according to the current NUMERIC DIGITS setting, and
      must be smaller than the current NUMERIC DIGITS setting.

      NUMERIC FUZZ temporarily reduces the value of NUMERIC DIGITS by
      the NUMERIC FUZZ value during every numeric comparison.  The
      numbers are subtracted under a precision of DIGITS minus FUZZ
      digits during the comparison and are then compared with 0.

      You can retrieve the current NUMERIC FUZZ setting with the FUZZ
      built-in function.  See "FUZZ"  in item FUZZ.

The three numeric settings are automatically saved across internal
and external subroutine and function calls.    See item CALL for more
details about the CALL instruction.
=OPTIONS
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--OPTIONS--expression;-------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

OPTIONS passes special requests or parameters to the language
processor.    For example, these may be language processor options or
perhaps define a special character set.

The expression is evaluated, and the result is examined one word at
a time.    The language processor converts the words to uppercase.  If
the language processor recognizes the words, then they are obeyed.
Words that are not recognized are ignored and assumed to be
instructions to a different processor.

The language processor recognizes the following words:

ETMODE      specifies that literal strings and symbols and comments
            containing DBCS characters are checked for being valid
            DBCS strings.  If you use this option, it must be the
            first instruction of the program.

            If the expression is an external function call, for
            example OPTIONS 'GETETMOD'(), and the program contains
            DBCS literal strings, enclose the name of the function in
            quotation marks to ensure that the entire program is not
            scanned before the option takes effect.  It is not
            suggested to use internal function calls to set ETMODE
            because of the possibility of errors in interpreting DBCS
            literal strings in the program.

NOETMODE    specifies that literal strings and symbols and comments
            containing DBCS characters are not checked for being valid
            DBCS strings.  NOETMODE is the default.  The language
            processor ignores this option unless it is the first
            instruction in a program.

EXMODE      specifies that instructions, operators, and functions
            handle DBCS data in mixed strings on a logical character
            basis.  DBCS data integrity is maintained.

NOEXMODE    specifies that any data in strings is handled on a byte
            basis.  The integrity of DBCS characters, if any, may be
            lost.  NOEXMODE is the default.

Notes:

1.    Because of the language processor's scanning procedures, you
      must place an OPTIONS 'ETMODE' instruction as the first
      instruction in a program containing DBCS characters in literal
      strings, symbols, or comments.  If you do not place OPTIONS
      'ETMODE' as the first instruction and you use it later in the
      program, you receive error message IRX0033I.  If you do place it
      as the first instruction of your program, all subsequent uses
      are ignored.  If the expression contains anything that would
      start a label search, all clauses tokenized during the label
      search process are tokenized within the current setting of
      ETMODE.  Therefore, if this is the first statement in the
      program, the default is NOETMODE.

2.    To ensure proper scanning of a program containing DBCS literals
      and DBCS comments, enter the words ETMODE, NOETMODE, EXMODE, and
      NOEXMODE as literal strings (that is, enclosed in quotation
      marks) in the OPTIONS instruction.

3.    The EXMODE setting is saved and restored across subroutine and
      function calls.

4.    To distinguish DBCS characters from 1-byte EBCDIC characters,
      sequences of DBCS characters are enclosed with a shift-out (SO)
      character and a shift-in (SI) character.  The hexadecimal values
      of the SO and SI characters are X'0E' and X'0F', respectively.

5.    When you specify OPTIONS 'ETMODE', DBCS characters within a
      literal string are excluded from the search for a closing
      quotation mark in literal strings.

6.    The words ETMODE, NOETMODE, EXMODE, and NOEXMODE can appear
      several times within the result.  The one that takes effect is
      determined by the last valid one specified between the pairs
      ETMODE-NOETMODE and EXMODE-NOEXMODE.
=OUTTRAP
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--OUTTRAP(--------------------------------------------------------><-|
|                +-off---------------------------------------------------|
|                +-varname-----------------------------------------------|
|                          +-,-------------------------------------------|
|                              +-max-+  +-,------------------------------|
|                                           +-concat-+  +-,--------------|
|                                                           +-skipamt-+  |
|                                                                        |
+------------------------------------------------------------------------+

OUTTRAP returns the name of the variable in which trapped output is
stored, or if trapping is not in effect, OUTTRAP returns the word
off.

You can use the following arguments to trap lines of command output
into compound variables or a series of numbered variables, or to
turn trapping off that was previously started.

off         specify the word OFF to turn trapping off.

varname     the stem of the compound variables or the variable prefix
            assigned to receive the command output.  Compound
            variables contain a period and allow for indexing, but
            lists of variables with the same prefix cannot be accessed
            by an index in a loop.

            Note:  Do not use "OFF" as a variable name.

max         the maximum number of lines to trap.  You can specify a
            number, an asterisk in quotation marks ('*'), or a blank.
            If you specify '*' or a blank, all the output is trapped.
            The default is 999,999,999.  If the maximum number of
            lines are trapped, subsequent lines are not stored in
            variables.

concat      indicates how output should be trapped.  For concat,
            specify one of the following:

            o   CONCAT

                indicates that output from commands be trapped in
                consecutive order until the maximum number of lines is
                reached.  For example, if the first command has three
                lines of output, they are stored in variables ending
                in 1, 2, and 3.  If the second command has two lines
                of output, they are stored in variables ending in 4
                and 5.  The default order for trapping is CONCAT.

            o   NOCONCAT

                indicates that output from each command be trapped
                starting at the variable ending in 1.  For example, if
                the first command has three lines of output, they are
                stored in variables ending in 1, 2, and 3.  If another
                command has two lines of output, they replace the
                first command's output in variables 1 and 2.

skipamt     specifies the number of lines to be skipped before
            trapping begins.  If skipamt is not specified, the default
            is 0.  The highest skip amount allowed is 999,999,999.

Lines of output are stored in successive variable names (as
specified by varname) concatenated with integers starting with 1.
All unused variables display their own names.    The number of lines
that were trapped is stored in the variable name followed by 0.    For
example, if you specify cmdout.    as the varname, the number of lines
stored is in:

    cmdout.0

If you specify cmdout as the varname, the number of lines stored is
in:

    cmdout0

An exec can use these variables to display or process TSO/E command
output.    Error messages from TSO/E commands are trapped, but other
types of error messages are sent to the terminal.    Trapping, once
begun, continues from one exec to other invoked execs or CLISTs.
Trapping ends when the original exec ends or when trapping is turned
off.

You can use the OUTTRAP function only in REXX execs that run in the
TSO/E address space.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use OUTTRAP only in environments that are            |
| integrated into TSO/E.                                                 |
|                                                                        |
+------------------------------------------------------------------------+

OUTTRAP traps output from commands, including those written in
REXX.    A command written in REXX cannot turn output trapping off on
behalf of its invoker.    Output trapping should be turned on and off
at the same exec level.    Therefore, a command written in REXX should
only turn output trapping off if that command turned it on.    In the
following examples, the first illustrates correct usage of OUTTRAP;
the second incorrect usage.    Note that the placement of the y =
OUTTRAP('OFF') statement must be within the REXX1 exec, not the
REXX2 command.

o     Correct usage of OUTTRAP

        x = OUTTRAP('VAR.')
        "%REXX2"
        y = OUTTRAP('OFF')
        EXIT
        /* REXX2 command */
        SAY "This is output from the REXX2 command "
        /* This will be trapped */
        RETURN

o     Incorrect usage of OUTTRAP

        /* REXX1 */
        x = OUTTRAP('VAR.')
        "%REXX2"
        EXIT
        /* REXX2 command */
        SAY "This is output from the REXX2 command "
        /* This will be trapped */
        y = OUTTRAP('OFF')
        RETURN

To trap the output of TSO/E commands under ISPF, you must invoke an
exec with command output after ISPF or one of its services has been
invoked.

The output of authorized commands listed under the AUTHCMD parameter
in the active IKJTSOxx parmlib member cannot be trapped by a REXX
exec invoked under any application that builds its own ECT.    For
example, a REXX exec must be prefixed by the TSO subcommand of IPCS
to trap the output of authorized commands when invoked from IPCS
under ISPF.

Regardless of the user's region size, the variables used to trap
output from authorized commands and programs are limited to storage
below the 16MB line, unless the PROFILE setting of VARSTORAGE(HIGH)
is in use.    If VARSTORAGE(HIGH) is specified in the user's PROFILE
setting, storage above the 16MB line can be used, and more lines of
output from an authorized command or program can be trapped by
REXX.

OUTTRAP may not trap all of the output from a TSO/E command.    The
output that the OUTTRAP function traps depends on the type of output
that the command produces.    For example, the TSO/E command OUTPUT
PRINT(*) directs the output from a job to your terminal.    The
OUTTRAP external function traps messages from the OUTPUT PRINT(*)
command, but does not trap the job output itself that is directed to
the terminal.

In general, the OUTTRAP function traps all output from a TSO/E
command.    For example, OUTTRAP traps broadcast messages from LISTBC,
the list of allocated data sets from LISTALC, catalog entries from
LISTCAT, and so on.

If you plan to write your own command processors for use in REXX
execs, and you plan to use the OUTTRAP external function to trap
command output, note the OUTTRAP function does not trap command
output that is sent to the terminal by:

o     TPUT
o     WTO macro
o     messages issued by TSO/E REXX (that is, messages beginning with
      IRX)
o     messages issued by TRACE output

However, OUTTRAP does trap output from the PUTLINE macro with DATA
or INFOR keywords.    Therefore, if you write any command processors,
you may want to use the PUTLINE macro rather than the TPUT or WTO
macros.    z/OS TSO/E Programming Guide describes how to write a TSO/E
command processor.    For information about the PUTLINE macro, see
z/OS TSO/E Programming Services.

Additional Variables That OUTTRAP Sets

In addition to the variables that store the lines of output, OUTTRAP
stores information in the following variables:

varname0
       contains the largest index into which output was trapped.  The
       number in this variable cannot be larger than varnameMAX or
       varnameTRAPPED.

varnameMAX
       contains the maximum number of output lines that can be
       trapped.  That is, the total number of lines generated by
       commands while OUTPUT trapping is in effect.  See example 1.

varnameTRAPPED
       contains the total number of lines of command output.  The
       number in this variable can be larger than varname0 or
       varnameMAX.

varnameCON
       contains the status of the concat argument, which is either
       CONCAT or NOCONCAT.

varnameSKIPPED
       contains the number of output lines that have been skipped so
       far.  This variable cannot be larger than varnameSKIPAMT.

varnameSKIPAMT
       contains the total number of output lines that must be skipped
       before the first output line is trapped in varname1.

       If a non-zero skip amount is specified, the number of lines
       that are skipped are still counted as part of the
       varnameTRAPPED value.  Any lines of output ignored after the
       vanameMAX limit has been reached will still be counted as part
       of the varnameTRAPPED value.

Examples:

The following are some examples of using OUTTRAP.

1.    This example shows the resulting values in variables after the
      following OUTTRAP function is processed.

        x = OUTTRAP("ABC",4,"CONCAT")

         "Command1" /* sample command producing 3 lines of output */

      Command 1 has three lines of output. After command1 runs, the
      following variables are set.

        ABC0            -->  3
        ABC1            -->  command 1 output line 1
        ABC2            -->  command 1 output line 2
        ABC3            -->  command 1 output line 3
        ABC4            -->  ABC4
        ABCMAX          -->  4
        ABCTRAPPED      -->  3
        ABCCONCAT      --> CONCAT
        ABCSKIPPED      --> 0
        ABCSKIPAMT      --> 0

        "Command2" /* sample command producing 2 lines of output */

      Command 2 has two lines of output.  After command 2 runs, the
      following variables are set.  Note that the second line of
      output from command 2 is not trapped because the MAX (4) is
      reached when the first line of output from command 2 is
      produced.

        ABC0            -->  4
        ABC1            -->  command 1 output line 1
        ABC2            -->  command 1 output line 2
        ABC3            -->  command 1 output line 3
        ABC4            -->  command 2 output line 1
        ABCMAX          -->  4
        ABCTRAPPED      -->  5
        ABCCONCAT      --> CONCAT
        ABCSKIPPED      --> 0
        ABCSKIPAMT      --> 0

2.    This example shows the resulting values in variables after the
      following OUTTRAP function is processed.

        x = OUTTRAP("XYZ.",4,"NOCONCAT")

        "Command1" /* sample command producing 3 lines of output */

      Command 1 has three lines of output. After command1 runs, the
      following variables are set.

        XYZ.0           -->  3
        XYZ.1           -->  command 1 output line 1
        XYZ.2           -->  command 1 output line 2
        XYZ.3           -->  command 1 output line 3
        XYZ.4           -->  XYZ.4
        XYZ.MAX         -->  4
        XYZ.TRAPPED     -->  3
        XYZ.CONCAT     --> NOCONCAT
        XYZ.SKIPPED     --> 0
        XYZ.SKIPAMT     --> 0

        "Command2" /* sample command producing 2 lines of output */

      Command 2 has two lines of output.  Because NOCONCAT was
      specified, output from Command 2 may replace output values
      trapped from Command 1.  However, because only 2 lines were
      trapped by command 2, only 2 of the three lines trapped by
      Command 1 are replaced.  XYZ.3 continues to contain the residual
      output from Command 1.

        XYZ.0           -->  2
        XYZ.1           -->  command 2 output line 1
        XYZ.2           -->  command 2 output line 2
        XYZ.3           -->  command 1 output line 3
        XYZ.4           -->  XYZ.4
        XYZ.MAX         -->  4
        XYZ.TRAPPED     -->  2
        XYZ.CONCAT     --> NOCONCAT
        XYZ.SKIPPED     --> 0
        XYZ.SKIPAMT     --> 0

3.    To determine if trapping is in effect:

        x = OUTTRAP()
        SAY x     /* If the exec is trapping output, displays the  */
                  /* variable name; if it is not trapping output,  */
                  /* displays OFF */

4.    To trap output from commands in consecutive order into the stem
      output.

      use one of the following:

        x = OUTTRAP("output.",'*',"CONCAT")
        x = OUTTRAP("output.")
        x = OUTTRAP("output.",,"CONCAT")

5.    To trap 6 lines of output into the variable prefix line and not
      concatenate the output:

        x = OUTTRAP(line,6,"NOCONCAT")

6.    To suppress all command output:

        x = OUTTRAP("output",0)

      Guideline: This form of OUTTRAP provides the best performance for
      suppressing command output.

7.    Allocate a new data set like an existing one and if the
      allocation is successful, delete the existing data set.  If the
      allocation is not successful, display the trapped output from
      the ALLOCATE command.

        x = OUTTRAP("var.")
        "ALLOC DA(new.data) LIKE(old.data) NEW"
        IF RC = 0 THEN
          "DELETE old.data"
        ELSE
          DO i = 1 TO var.0
             SAY var.i
          END

      If the ALLOCATE command is not successful, error messages are
      trapped in the following compound variables.

      o   VAR.1 = error message
      o   VAR.2 = error message
      o   VAR.3 = error message

8.    This example shows the resulting values in variables after the
      following OUTTRAP function is performed, using the SKIP argument
      of OUTTRAP to skip over lines of output before trapping begins.

        x = OUTTRAP("XYZ.",10,"CONCAT",50)

        "CMD1"             /* CMD1 produces 40 lines of output */

      CMD1 has 40 lines of output.  Because 40 is less than 50, no
      lines of CMD1 are trapped.  After CMD1, OUTTRAP variables have
      the following values:

        XYZ.0           --> 0           No lines trapped yet
        XYZ.1           --> XYZ.1
        XYZ.2           --> XYZ.2
        XYZ.3           --> XYZ.3
        XYZ.4           --> XYZ.4
        XYZ.5           --> XYZ.5
        XYZ.6           --> XYZ.6
        XYZ.7           --> XYZ.7
        XYZ.8           --> XYZ.8
        XYZ.9           --> XYZ.9
        XYZ.10          --> XYZ.10
        XYZ.MAX         --> 10
        XYZ.TRAPPED     --> 40     40 lines of output handled so far
        XYZ.CON         --> CONCAT
        XYZ.SKIPPED     --> 40    Number of lines skipped so far
        XYZ.SKIPAMT     --> 50    Total number to skip before trapping

        "CMD2"             /* CMD2 produces 15 more lines of output */

      CMD2 has 15 lines of output.  10 additional lines will be
      skipped, and trapping will begin with the 11th line (51st line
      overall).

        XYZ.0          --> 5           5 lines trapped
        XYZ.1          --> cmd2 output line 11 (output line 51 overall
        XYZ.2          --> cmd2 output line 12 (output line 52 overall
        XYZ.3          --> cmd2 output line 13 (output line 53 overall
        XYZ.4          --> cmd2 output line 14 (output line 54 overall
        XYZ.5          --> cmd2 output line 15 (output line 55 overall
        XYZ.6          --> XYZ.6
        XYZ.7          --> XYZ.7
        XYZ.8          --> XYZ.8
        XYZ.9          --> XYZ.9
        XYZ.MAX        --> 10
        XYZ.10         --> XYZ.10
        XYZ.TRAPPED    --> 55    55 lines of output handled so far
        XYZ.CON        --> CONCAT
        XYZ.SKIPPED    --> 50    Number of lines skipped so far
        XYZ.SKIPAMT    --> 50    Total number to skip before trapping

      When skipping is in effect, the 1st line trapped into variable
      XYZ.1 is the (XYZ.SKIPAMT +1) line of output.

        "CMD3"             /* CMD3 produces 10 more lines of output */

      CMD3 has 10 lines of output.  5 additional lines will be trapped
      until MAX has been reached, and the remaining lines are
      discarded.

        XYZ.0          --> 10          10 lines trapped
        XYZ.1          --> cmd2 output line 11 (output line 51 overall
        XYZ.2          --> cmd2 output line 12 (output line 52 overall
        XYZ.3          --> cmd2 output line 13 (output line 53 overall
        XYZ.4          --> cmd2 output line 14 (output line 54 overall
        XYZ.5          --> cmd2 output line 15 (output line 55 overall
        XYZ.6          --> cmd3 output line 1 (output line 56 overall)
        XYZ.7          --> cmd3 output line 2 (output line 57 overall)
        XYZ.8          --> cmd3 output line 3 (output line 58 overall)
        XYZ.9          --> cmd3 output line 4 (output line 59 overall)
        XYZ.10         --> cmd3 output line 5 (output line 60 overall)
        XYZ.MAX        --> 10
        XYZ.TRAPPED    --> 65    65 lines of output handled so far
        XYZ.CON        --> CONCAT
        XYZ.SKIPPED    --> 50   Number of lines skipped so far
        XYZ.SKIPAMT    --> 50   Total number to skip before trapping

      o   The first line of output trapped is the XYZ.SKIPAMT+1 -th
          output line.  The last line trapped is the
          XYZ.SKIPAMT+XYZ.MAX -th output line.  Any output lines after
          this are not trapped.

      o   The first line trapped is always placed in the XYZ.1 variable.

      o   The highest indexed variable into which output can be
          trapped is XYZ.n (where n=XYZ.MAX).

      o   PUTLINE output lines that are skipped behave as if they were
          trapped and discarded.  The output is not written to the
          screen, and the skipped lines are not actually trapped.
          However, each skipped line does count in the total number of
          output lines processed (varnameTRAPPED).

9.    A user is about to use a REXX exec to invoke an authorized
      command "MYACMD".  The exec wishes to use OUTTRAP to trap and
      process the output.  Although the command may produce 500,000 or
      more lines of output, the user is only interested in the last
      70,000 lines.  He wants to capture these lines and write them to
      a data set to be processed later.

      a.  The user issues the PROFILE command without operands to see
          the current settings, and to ensures that the VARSTORAGE
          setting is HIGH.

            PROFILE
            IKJ56688I CHAR(0) LINE(0) PROMPT INTERCOM NOPAUSE MSGID NO
            PlANGUAGE(ENU) SLANGUAGE(ENU) VARSTORAGE(HIGH) IKJ56689I
            DEFAULT LINE/CHARACTER DELETE CHARACTERS IN EFFECT FOR TH

          If the VARSTORAGE setting is LOW he can change it to HIGH

            PROFILE VARSTORAGE(HIGH)

      b.  The user then invokes the following exec:

            /* REXX */
            "ALLOC FI(OUTDD) DA(...my output data set...) SHR REUSE"
            /* ... other processing ... */
     /***********************************************************/
     /* First determine how much output the command produces.   */
     /* Specify a MAXAMT of 0 (2nd operand on OUTTRAP) to       */
     /* indicate that we don't want to actually trap any output */
     /* yet. We just want to determine the number of lines of   */
     /* output produced.                                        */
     /***********************************************************/
            X = OUTTRAP(line.)

            "MYACMD"
            No_of_lines = line.trapped   /* Total number of lines of o
     /*********************************************************/
     /* Throw away everything except the last 70,000 lines by */
     /* setting SKIPAMT                                       */
     /*********************************************************/

            Skipamt = MAX(No_of_lines - 70000,0)
            X = OUTTRAP (line.,'*','CONCAT',skipamt)
            " MYACMD"
     /****************************************************************/
     /* Last 70,000 lines are trapped in line.1 to line.n where      */
     /* n is the line.0 value.  If fewer than 70,000 lines of        */
     /* ouput produced, then all of them are trapped.                */
     /****************************************************************/

            n = line.0        /*number actually trapped */

            " execio" n" diskw outdd (stem line. finis"

            If rc=0 then
            Say n ' lines of data have been written to file OUTDD'
            /* ... more processing ... */

            " FREE FI(OUTDD)"
            exit 0
=OVERLAY
)F Function -
+---------------------------------------------------------------------------+
|                                                                           |
| >>--OVERLAY(new,target---------------------------------------------)--->< |
|                           +-,-------------------------------------+       |
|                               +-n-+  +-,-----------------------+          |
|                                          +-length-+  +-,pad-+             |
|                                                                           |
+---------------------------------------------------------------------------+

Returns the string target, which, starting at the nth character, is
overlaid with the string new, padded or truncated to length length.
(The overlay may extend beyond the end of the original target
string.) If you specify length, it must be a positive whole number
or zero.    The default value for length is the length of new.  If n
is greater than the length of the target string, padding is added
before the new string.    The default pad character is a blank, and
the default value for n is 1.    If you specify n, it must be a
positive whole number.

Here are some examples:

    OVERLAY(' ','abcdef',3)         ->    'ab def'
    OVERLAY('.','abcdef',3,2)       ->    'ab. ef'
    OVERLAY('qq','abcd')            ->    'qqcd'
    OVERLAY('qq','abcd',4)          ->    'abcqq'
    OVERLAY('123','abc',5,6,'+')    ->    'abc+123+++'
=PARSE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--PARSE---------------ARG------------------------------------------> |
|              +-UPPER-+  +-EXTERNAL------------------|                  |
|                         +-NUMERIC-------------------|                  |
|                         +-PULL----------------------|                  |
|                         +-SOURCE--------------------|                  |
|                         +-VALUE----------------WITH-|                  |
|                         |       +-expression-+      |                  |
|                         +-VAR--name-----------------|                  |
|                         +-VERSION-------------------+                  |
|                                                                        |
| >-----------------------;------------------------------------------->< |
|       +-template_list-+                                                |
|                                                                        |
+------------------------------------------------------------------------+

PARSE assigns data (from various sources) to one or more variables
according to the rules of parsing (see "Parsing"    in item -PARSING
).

The template_list is often a single template but may be several
templates separated by commas.    If specified, each template is a
list of symbols separated by blanks or patterns or both.

Each template is applied to a single source string.    Specifying
multiple templates is never a syntax error, but only the PARSE ARG
variant can supply more than one non-null source string.    See item
-MULT-STR-PARSE for inf about parsing multiple source strings.

If you do not specify a template, no variables are set but action is
taken to prepare the data for parsing, if necessary.    Thus for PARSE
PULL, a data string is removed from the queue, and for PARSE VALUE,
expression is evaluated.    For PARSE VAR, the specified variable is
accessed.    If it does not have a value, the NOVALUE condition is
raised, if it is enabled.

If you specify the UPPER option, the data to be parsed is first
translated to uppercase (that is, lowercase a-z to uppercase A-Z).
Otherwise, no uppercase translation takes place during the parsing.

The following list describes the data for each variant of the PARSE
instruction.

PARSE ARG
      parses the string or strings passed to a program or internal
      routine as input arguments.  See item ARG for details and
      examples of the ARG instruction.

      Tip:  You can also retrieve or check the argument strings to a
      REXX program or internal routine with the ARG built-in function
      (see item ARG).

PARSE EXTERNAL
      In TSO/E, PARSE EXTERNAL reads from the:

      o   Terminal (TSO/E foreground)
      o   Input stream, which is SYSTSIN (TSO/E background).

      In non-TSO/E address spaces, PARSE EXTERNAL reads from the input
      stream as defined by the file name in the INDD field in the
      module name table.  The system default is
      SYSTSIN.  PARSE EXTERNAL returns a field based on the record that
      is read from the INDD file.  If SYSTSIN has no data, the PARSE
      EXTERNAL instruction returns a null string.

PARSE NUMERIC
      The current numeric controls (as set by the NUMERIC instruction)
      are available (see item NUMERIC ).  These controls are in the
      order DIGITS FUZ FORM.

      Example:

        Parse Numeric Var1

      After this instruction, Var1 would be equal to:  9 0
      SCIENTIFIC.  See "NUMERIC"  in item NUMERIC and the built-in
      functions "DIGITS"  in item DIGITS, "FORM"  in item FORM, and
      "FUZZ"  in item FUZZ.

PARSE PULL
      parses the next string from the external data queue.  If the
      external data queue is empty, PARSE PULL reads a line from the
      default input stream (the user's terminal), and the program
      pauses, if necessary, until a line is complete.  You can add
      data to the head or tail of the queue by using the PUSH and
      QUEUE instructions, respectively.  You can find the number of
      lines currently in the queue with the QUEUED built-in function.
      (See item QUEUED.) Other programs in the system can alter the
      queue and use it as a means of communication with programs
      written in REXX.  See item PULL for the PULL instruction.

      PULL and PARSE PULL read from the data stack.  In TSO/E, if the
      data stack is empty, PULL and PARSE PULL read from the:

      o   Terminal (TSO/E foreground)
      o   Input stream, which is SYSTSIN (TSO/E background).

      In non-TSO/E address spaces, if the data stack is empty, PULL
      and PARSE PULL read from the input stream as defined by the file
      name in the INDD field in the module name table
      The system default i SYSTSIN.  If SYSTSIN has no
      data, the PULL and PARSE PULL instructions return a null
      string.

PARSE SOURCE
      parses data describing the source of the program running.  The
      language processor returns a string that is fixed (does not
      change) while the program is running.

      The source string contains the following tokens:

      1.  The characters TSO

      2.  The string COMMAND, FUNCTION, or SUBROUTINE depending on
          whether the program was called as some kind of host command
          (for example, as an exec from TSO/E READY mode), or from a
          function call in an expression, or using the CALL
          instruction.

      3.  Usually, name of the exec in uppercase.  If the name is not
          known, this token is a question mark (?).  If the name is an
          extended execname, this field is the full name, possibly
          greater than 8-characters and not converted to uppercase.
          If the execname contains any blank characters (which is
          possible in an execname of file system), the blank
          characters are replaced by null characters (X'00') within
          this token.  See "Format of the Exec Block"  in item
          -EXECBLK-FMT and "Format of the In-Storage Control Block"
          in item -INSTOR-CBLK-FMT for more information about how the
          exec load ro can load an extended execname.

      4.  Name of the DD from which the exec was loaded.  If the name
          is not known, this token is a question mark (?).

      5.  Name of the data set from which the exec was loaded.  If the
          name is not known, this token is a question mark (?).  If
          the name contains any blank characters (which is possible in
          a dsname of file system), the blank characters are replaced
          by null characters (X'00') within this token.

      6.  Name of the exec as it was called, that is, the name is not
          folded to uppercase.  If the name is not known, this token
          is a question mark (?).

          If the name returned in token3 is an extended name, this
          token is a question mark (?).

      7.  Initial (default) host command environment in uppercase.
          For example, this token may be TSO or MVS.

      8.  Name of the address space in uppercase.  For example, the
          value may be MVS (non-TSO/E) or TSO/E or ISPF.  If the exec
          was called from ISPF, the address space name is ISPF.

          The value is taken from the parameter block
          that the initialization exit routines may
          change the name specified in the parameters module.  If the
          name of the address space is not known, this token is a
          question mark (?).

      9.  Eight character user token.  This is the token that is
          specified in the PARSETOK field in the parameters module.

      For example, the string parsed might look like one of the
      following:
        TSO COMMAND PROGA SYSXR07 EGGERS.ECE.EXEC ? TSO TSO/E ?
        TSO SUBROUTINE PROGSUB SYSEXEC ? ? TSO ISPF ?
        TSO SUBROUTINE /u/cmddir/pgm.cmd PATH /u/cmddir/pgm.cmd
        ? SH OMVS OpenMVS

PARSE VALUE
      parses the data that is the result of evaluating expression.  If
      you specify no expression, then the null string is used.  Note
      that WITH is a subkeyword in this context and cannot be used as
      a symbol within expression.

      Thus, for example:

        PARSE VALUE time() WITH  hours ':' mins ':' secs

      gets the current time and splits it into its constituent parts.

PARSE VAR name
      parses the value of the variable name.  The name must be a
      symbol that is valid as a variable name (that is, it cannot
      start with a period or a digit).  Note that the variable name is
      not changed unless it appears in the template, so that for
      example:

        PARSE VAR string word1 string

      removes the first word from string, puts it in the variable
      word1, and assigns the remainder back to string.  Similarly

        PARSE UPPER VAR string word1 string

      in addition translates the data from string to uppercase before
      it is parsed.

PARSE VERSION
      parses information describing the language level and the date of
      the language processor.  This information consists of five
      blank-delimited words:

      1.  A word describing the language, which is the string "REXX370"

      2.  The language level description, for example, "3.46"

      3.  Three tokens describing the language processor release date,
          for example, "31 May 2001".
=POS (Position)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--POS(needle,haystack--------------)------------------------------>< |
|                            +-,start-+                                  |
|                                                                        |
+------------------------------------------------------------------------+

Returns the position of one string, needle, in another haystack.
(See also the INDEX and LASTPOS functions.) Returns 0 if needle is
the null string or is not found or if start is greater than the
length of haystack.    By default the search starts at the first
character of haystack (that is, the value of start is 1).    You can
override this by specifying start (which must be a positive whole
number), the point at which the search starts.

Here are some examples:

    POS('day','Saturday')       ->    6
    POS('x','abc def ghi')      ->    0
    POS(' ','abc def ghi')      ->    4
    POS(' ','abc def ghi',5)    ->    8
=PROCEDURE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--PROCEDURE----------------------------;-------------------------->< |
|                  |        <----------+  |                              |
|                  +-EXPOSE----name-------+                              |
|                            +-(name)-+                                  |
|                                                                        |
+------------------------------------------------------------------------+

PROCEDURE, within an internal routine (subroutine or function),
protects variables by making them unknown to the instructions that
follow it.    After a RETURN instruction is processed, the original
variables environment is restored and any variables used in the
routine (that were not exposed) are dropped.    (An exposed variable
is one belonging to a caller of a routine that the PROCEDURE
instruction has exposed.    When the routine refers to or alters the
variable, the original (caller's) copy of the variable is used.) An
internal routine need not include a PROCEDURE instruction; in this
case the variables it is manipulating are those the caller "owns."
If used, the PROCEDURE instruction must be the first instruction
processed after the CALL or function invocation; that is, it must be
the first instruction following the label.

If you use the EXPOSE option, any variable specified by name is
exposed.    Any reference to it (including setting and dropping)
refers to the variables environment the caller owns.    Hence, the
values of existing variables are accessible, and any changes are
persistent even on RETURN from the routine.    If name is not enclosed
in parentheses, it identifies a variable you want to expose and must
be a symbol that is a valid variable name, separated from any other
name with one or more blanks.

If parentheses enclose a single name, then, after the variable name
is exposed, the value of name is immediately used as a subsidiary
list of variables.    (Blanks are not necessary either inside or
outside the parentheses, but you can add them if desired.) This
subsidiary list must follow the same rules as the original list
(that is, valid variable names, separated by blanks) except that no
parentheses are allowed.

Variables are exposed in sequence from left to right.    It is not an
error to specify a name more than one time, or to specify a name
that the caller has not used as a variable.

Any variables in the main program that are not exposed are still
protected.    Therefore, some limited set of the caller's variables
can be made accessible, and these variables can be changed (or new
variables in this set can be created).    All these changes are
visible to the caller upon RETURN from the routine.

Example:

    /* This is the main REXX program */
    j=1; z.1='a'
    call toft
    say j k m       /* Displays "1 7 M"          */
    exit
    /* This is a subroutine     */
    toft: procedure expose j k z.j
       say j k z.j  /* Displays "1 K a"          */
       k=7; m=3     /* Note: M is not exposed    */
       return

Note that if Z.J in the EXPOSE list had been placed before J, the
caller's value of J would not have been visible at that time, so Z.1
would not have been exposed.

The variables in a subsidiary list are also exposed from left to
right.

Example:

    /* This is the main REXX program */
    j=1;k=6;m=9
    a ='j k m'
    call test
    exit

    /* This is a subroutine     */
    test: procedure expose (a)   /* Exposes A, J, K, and M     */
      say a j k m                /* Displays "j k m 1 6 9"     */
      return

You can use subsidiary lists to more easily expose a number of
variables at one time or, with the VALUE built-in function, to
manipulate dynamically named variables.

Example:

    /* This is the main REXX program */
    c=11; d=12; e=13
    Showlist='c d'         /* but not E              */
    call Playvars
    say c d e f            /* Displays "11 New 13 9" */
    exit
    /* This is a subroutine     */
    Playvars: procedure expose (showlist) f
     say word(showlist,2)
                           /* Displays "d"                     */
     say value(word(showlist,2),'New')
                           /* Displays "12" and sets new value */
     say value(word(showlist,2))
                           /* Displays "New"                   */
     e=8
                           /* E is not exposed                 */
     f=9
                           /* F was explicitly exposed         */
     return

Specifying a stem as name exposes this stem and all possible
compound variables whose names begin with that stem.

Example:

    /* This is the main REXX program */
    a.=11; i=13; j=15
    i = i + 1
    C.5 = 'FRED'
    call lucky7
    say a. a.1 i j c. c.5
    say 'You should see 11 7 14 15 C. FRED'
    exit
    lucky7:Procedure Expose i j a. c.
    /* This exposes I, J, and all variables whose     */
    /* names start with A. or C.                      */
    A.1='7'  /* This sets A.1 in the caller's         */
             /* environment, even if it did not       */
             /* previously exist.                     */
    return

Variables may be exposed through several generations of routines, if
desired, by ensuring that they are included on all intermediate
PROCEDURE instructions.

See item CALL for details and examples of how
routines ar called.
=PROMPT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--PROMPT(------------)-------------------------------------------->< |
|               +-option-+                                               |
|                                                                        |
+------------------------------------------------------------------------+

PROMPT returns the value ON or OFF, which indicates the setting of
prompting for the exec.

You can use the following options to set prompting on or off for
interactive TSO/E commands, provided your profile allows for
prompting.    Only when your profile specifies PROMPT, can prompting
be made available to TSO/E commands issued in an exec.

ON          returns the previous setting of prompt (ON or OFF) and sets
            prompting on for TSO/E commands issued within an exec.

OFF         returns the previous setting of prompt (ON or OFF) and sets
            prompting off for TSO/E commands issued within an exec.

Here are some examples:

    promset = PROMPT()    -> 'OFF'  /* returns current setting (OFF)  */
    setprom = PROMPT("ON")-> 'OFF'  /* returns previous setting (OFF)
                                       and sets prompting on          */

You can use the PROMPT function only in REXX execs that run in the
TSO/E address space.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use PROMPT only in environments that are             |
| integrated into TSO/E (see "Interaction of Three Ways to Affect        |
| Prompting").                                                           |
|                                                                        |
+------------------------------------------------------------------------+

You can set prompting for an exec using the PROMPT keyword of the
TSO/E EXEC command or the PROMPT function.    The PROMPT function
overrides the PROMPT keyword of the EXEC command.    For more
information about situations when one option overrides the other,
see this item.

When an exec sets prompting on, prompting continues in other
functions and subroutines called by the exec.    Prompting ends when
the PROMPT(OFF) function is used or when the original exec ends.
When an exec invokes another exec or CLIST with the EXEC command,
prompting in the new exec or CLIST depends on the setting in the
profile and the use of the PROMPT keyword on the EXEC command.

If the data stack is not empty, commands that prompt retrieve
information from the data stack before prompting a user at the
terminal.    To prevent a prompt from retrieving information from the
data stack, issue a NEWSTACK command to create a new data stack for
the exec.

When your TSO/E profile specifies NOPROMPT, no prompting is allowed
in your terminal session even though the PROMPT function returns
ON.

Interaction of Three Ways to Affect Prompting

You can control prompting within an exec in three ways:

1.    TSO/E profile

      The TSO/E PROFILE command controls whether prompting is allowed
      for TSO/E commands in your terminal session.  The PROMPT operand
      of the PROFILE command sets prompting on and the NOPROMPT
      operand sets prompting off.

2.    TSO/E EXEC command

      When you invoke an exec with the EXEC command, you can specify
      the PROMPT operand to set prompting on for the TSO/E commands
      issued within the exec.  The default is NOPROMPT.

3.    PROMPT external function

      You can use the PROMPT function to set prompting on or off
      within an exec.

Table ZZZ shows how the three ways to affect prompting interact and
the final outcome of various interactions.

+------------------------------------------------------------------------+
| Table ZZZ. Different Ways Prompting is Affected                        |
+------------------------------------------------------------------------|
| Interaction                          | Prompting       | No Prompting  |
+------------------------------------+-----------------+-----------------|
| PROFILE PROMPT                       | X               |               |
| EXEC PROMPT                          |                 |               |
| PROMPT(ON)                           |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE PROMPT                       | X               |               |
| EXEC NOPROMPT                        |                 |               |
| PROMPT(ON)                           |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE PROMPT                       |                 | X             |
| EXEC NOPROMPT                        |                 |               |
| PROMPT()                             |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE PROMPT                       |                 | X             |
| EXEC NOPROMPT                        |                 |               |
| PROMPT(OFF)                          |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE PROMPT                       | X               |               |
| EXEC PROMPT                          |                 |               |
| PROMPT()                             |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE PROMPT                       |                 | X             |
| EXEC PROMPT                          |                 |               |
| PROMPT(OFF)                          |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE NOPROMPT                     |                 | X             |
| EXEC PROMPT                          |                 |               |
| PROMPT(ON)                           |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE NOPROMPT                     |                 | X             |
| EXEC NOPROMPT                        |                 |               |
| PROMPT(ON)                           |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE NOPROMPT                     |                 | X             |
| EXEC PROMPT                          |                 |               |
| PROMPT(OFF)                          |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE NOPROMPT                     |                 | X             |
| EXEC NOPROMPT                        |                 |               |
| PROMPT(OFF)                          |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE NOPROMPT                     |                 | X             |
| EXEC PROMPT                          |                 |               |
| PROMPT()                             |                 |               |
+------------------------------------+-----------------+-----------------|
| PROFILE NOPROMPT                     |                 | X             |
| EXEC NOPROMPT                        |                 |               |
| PROMPT()                             |                 |               |
+------------------------------------------------------------------------+

Examples:

The following are some examples of using PROMPT.

1.    To check if prompting is available before issuing the
      interactive TRANSMIT command, use the PROMPT function as
      follows:

        "PROFILE PROMPT"
        IF PROMPT() = 'ON' THEN
          "TRANSMIT"
        ELSE
          DO
            x = PROMPT('ON')
                       /* Save prompt setting and turn prompting ON */
            "TRANSMIT" /* Restore prompting setting */
            y = PROMPT(x)
          END

2.    Suppose you want to use the LISTDS command in an exec and want
      to ensure that prompting is done to the terminal.  First check
      whether the data stack is empty.  If the data stack is not
      empty, use the NEWSTACK command to create a new data stack.  Use
      the PROMPT function before issuing the LISTDS command.

        IF QUEUED() > 0 THEN
          "NEWSTACK"
        ELSE NOP
        x = PROMPT('ON')
        "LISTDS"
        y = PROMPT(x)
=PULL
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--PULL-------------------;---------------------------------------->< |
|            +-template_list-+                                           |
|                                                                        |
+------------------------------------------------------------------------+

PULL reads a string from the head of the external data queue.    It is
just a short form of the instruction:

>>--PARSE UPPER PULL-----------------------;--><
                         +-template_list-+

The current head-of-queue is read as one string.    Without a
template_list specified, no further action is taken (and the string
is thus effectively discarded).    If specified, a template_list is
usually a single template, which is a list of symbols separated by
blanks or patterns or both.    (The template_list can be several
templates separated by commas, but PULL parses only one source
string; if you specify several comma-separated templates, variables
in templates other than the first one are assigned the null string.)
The string is translated to uppercase (that is, lowercase a-z to
uppercase A-Z) and then parsed into variables according to the rules
described in parsing.  Use the PARSE PULL
instruction if you do not desire uppercase translation.

The TSO/E implementation of the external data queue is the data
stack.    REXX execs that run in TSO/E and non-TSO/E address spaces
can use the data stack.    In TSO/E, if the data stack is empty, PULL
reads from the:

o     Terminal (TSO/E foreground)
o     Input stream, which is SYSTSIN (TSO/E background).

In non-TSO/E address spaces, if the data stack is empty, PULL reads
from the input stream as defined by the file name in the INDD field
in the module name table.  The system default
is SYSTSIN.    If SYSTSIN ha no data, the PULL instruction returns a
null string.

The length of each element you can place onto the data stack can be
up to one byte less than 16 megabytes.

Example:

    Say 'Do you want to erase the file?  Answer Yes or No:'
    Pull answer .
    if answer='NO' then say 'The file will not be erased.'

Here the dummy placeholder, a period (.), is used on the template to
isolate the first word the user enters.

The QUEUED built-in function (see item QUEUED ) returns the number
of lines currently in the external data queue.
=PUSH
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--PUSH----------------;------------------------------------------->< |
|            +-expression-+                                              |
|                                                                        |
+------------------------------------------------------------------------+

PUSH stacks the string resulting from the evaluation of expression
LIFO (Last In, First Out) onto the external data queue.

If you do not specify expression, a null string is stacked.

Note:    The TSO/E implementation of the external data queue is the
         data stack.  The length of an element in the data stack can
         be up to one byte less than 16 megabytes.  The data stack
         contains one buffer initially, but you can create additional
         buffers using the TSO/E REXX command MAKEBUF.

Example:

    a='Fred'
    push       /* Puts a null line onto the queue */
    push a 2   /* Puts "Fred 2"    onto the queue */

See item QUEUED for the QUEUED built-in function that returns the
number of lines currently in the external data queue.
=QBUF
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--QBUF------------------------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

Queries the number of buffers that were created on the data stack
with the MAKEBUF command.    The QBUF command returns the number of
buffers in the REXX special variable RC.    If you have not issued
MAKEBUF to create any buffers on the data stack, QBUF sets the
special variable RC to 0.    In this case, 0 is the number of the
buffer that is contained in every data stack.

You can use the QBUF command in REXX execs that run in both the
TSO/E address space and non-TSO/E address spaces.

QBUF returns the current number of data stack buffers created by an
exec and by other routines (functions and subroutines) the exec
calls.    You can issue QBUF from the calling exec or from a called
routine.    For example, if an exec issues two MAKEBUF commands and
then calls a routine that issues another MAKEBUF command, QBUF
returns 3 in the REXX special variable RC.

The following table shows how QBUF sets the REXX special variable RC.

+--------------------------------------------------------------------------+
| Return Code    | Meaning                                                 |
+--------------+-----------------------------------------------------------|
| 0              | Only buffer 0 exists on the data stack                  |
+--------------+-----------------------------------------------------------|
| 1              | One additional buffer exists on the data stack          |
+--------------+-----------------------------------------------------------|
| 2              | Two additional buffers exist on the data stack          |
+--------------+-----------------------------------------------------------|
| n              | n additional buffers exist on the data stack            |
+--------------------------------------------------------------------------+

Examples

1.    If an exec creates two buffers on the data stack using the
      MAKEBUF command, deletes one buffer using the DROPBUF command,
      and then issues the QBUF command, RC is set to 1.

        "MAKEBUF"            /* buffer created */
          .
          .
          .
        "MAKEBUF"            /* second buffer created */
          .
          .
          .
        "DROPBUF"            /* second buffer created is deleted */
        "QBUF"
        SAY 'The number of buffers created is' RC      /* RC = 1 */

2.    Suppose an exec uses MAKEBUF to create a buffer and then calls a
      routine that also issues MAKEBUF.  The called routine then calls
      another routine that issues two MAKEBUF commands to create two
      buffers.  If either of the called routines or the original exec
      issues the QBUF command, QBUF sets the REXX special variable RC
      to 4.

        "DROPBUF 0"     /* delete any buffers MAKEBUF created */
        "MAKEBUF"                     /* create one buffer    */
        SAY 'Buffers created = ' RC               /*  RC = 1  */
        CALL sub1
        "QBUF"
        SAY 'Buffers created = ' RC               /*  RC = 4  */
        EXIT

        sub1:
        "MAKEBUF"                     /* create second buffer */
        SAY 'Buffers created = ' RC               /*  RC = 2  */
        CALL sub2
        "QBUF"
        SAY 'Buffers created = ' RC               /*  RC = 4  */
        RETURN

        sub2:
        "MAKEBUF"                     /* create third buffer  */
        SAY 'Buffers created = ' RC               /*  RC = 3  */
          .
          .
          .
        "MAKEBUF"                     /* create fourth buffer */
        SAY 'Buffers created = ' RC               /*  RC = 4  */
        RETURN
=QELEM
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--QELEM----------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Queries the number of data stack elements that are in the most
recently created data stack buffer (that is, in the buffer that was
created by the MAKEBUF command).    The number of elements is returned
in the REXX special variable RC.    When MAKEBUF has not been issued
to create a buffer, QELEM returns the number 0 in the special
variable RC, regardless of the number of elements on the data
stack.    Thus when QBUF returns 0, QELEM also returns 0.

The QELEM command can be issued from REXX execs that execute in both
the TSO/E address space and in non-TSO/E address spaces.

QELEM only returns the number of elements in a buffer that was
explicitly created using the MAKEBUF command.    You can use QELEM to
coordinate the use of MAKEBUF.    Knowing how many elements are in a
data stack buffer can also be useful before an exec issues the
DROPBUF command, because DROPBUF removes the most recently created
buffer and all elements in it.

The QELEM command returns the number of elements in the most
recently created buffer.    The QUEUED built-in function (see item
QUEUED) returns the total number of elements in the data stack, not
including buffers.

After the QELEM command processes, the REXX special variable RC
contains one of the following return codes:

+--------------------------------------------------------------------------+
| Return Code    | Meaning                                                 |
+--------------+-----------------------------------------------------------|
| 0              | Either the MAKEBUF command has not been issued or       |
|                | the buffer that was most recently created by            |
|                | MAKEBUF contains no elements.                           |
+--------------+-----------------------------------------------------------|
| 1              | MAKEBUF has been issued and there is one element in     |
|                | the current buffer.                                     |
+--------------+-----------------------------------------------------------|
| 2              | MAKEBUF has been issued and there are two elements      |
|                | in the current buffer.                                  |
+--------------+-----------------------------------------------------------|
| 3              | MAKEBUF has been issued and there are three             |
|                | elements in the current buffer.                         |
+--------------+-----------------------------------------------------------|
| n              | MAKEBUF has been issued and there are n elements in     |
|                | the current buffer.                                     |
+--------------------------------------------------------------------------+

Examples

1.    If an exec creates a buffer on the data stack with the MAKEBUF
      command and then puts three elements on the data stack, the
      QELEM command returns the number 3.

        "MAKEBUF"         /* buffer created */
        PUSH one
        PUSH two
        PUSH three
        "QELEM"
        SAY 'The number of elements in the buffer is' RC  /* RC = 3 */

2.    Suppose an exec creates a buffer on the data stack, puts two
      elements on the data stack, creates another buffer, and then
      puts one element on the data stack.  If the exec issues the
      QELEM command, QELEM returns the number 1.  The QUEUED function,
      however, which returns the total number of elements on the data
      stack, returns the number 3.

        "MAKEBUF"         /* buffer created */
        QUEUE one
        PUSH two
        "MAKEBUF"         /* second buffer created */
        PUSH one
        "QELEM"
        SAY 'The number of elements in the most recent buffer is' RC
                                                       /* RC = 1    */
        SAY 'The total number of elements is' QUEUED() /* returns 3 */

3.    To check whether a data stack buffer contains elements before
      you remove the buffer, use the result from QELEM and QBUF in an
      IF...THEN...ELSE instruction.

        "MAKEBUF"
        PUSH a
        "QELEM"
        NUMELEM = RC     /* Assigns value of RC to variable NUMELEM */
        "QBUF"
        NUMBUF = RC      /* Assigns value of RC to variable NUMBUF  */
        IF (NUMELEM = 0) & (numbuf > 0) THEN
           "DROPBUF"
        ELSE             /* Deletes most recently created buffer    */
           DO NUMELEM
              PULL elem
              SAY  elem
           END
=QSTACK
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--QSTACK---------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Queries the number of data stacks in existence for an exec that is
running.    QSTACK returns the number of data stacks in the REXX
special variable RC.    The value QSTACK returns indicates the total
number of data stacks, including the original data stack.    If you
have not issued a NEWSTACK command to create a new data stack,
QSTACK returns 1 in the special variable RC for the original data
stack.

You can use the QSTACK command in REXX execs that run in both the
TSO/E address space and in non-TSO/E address spaces.

QSTACK returns the current number of data stacks created by an exec
and by other routines (functions and subroutines) the exec calls.
You can issue QSTACK from the calling exec or from a called
routine.    For example, if an exec issues one NEWSTACK command and
then calls a routine that issues another NEWSTACK command, and none
of the new data stacks are deleted with the DELSTACK command, QSTACK
returns 3 in the REXX special variable RC.

The following table shows how QSTACK sets the REXX special variable
RC.

+--------------------------------------------------------------------------+
| Return Code    | Meaning                                                 |
+--------------+-----------------------------------------------------------|
| 0              | No data stack exists. See "Data Stack Routine" in       |
|                | item -IRXSTK.                                           |
+--------------+-----------------------------------------------------------|
| 1              | Only the original data stack exists                     |
+--------------+-----------------------------------------------------------|
| 2              | One new data stack and the original data stack exist    |
+--------------+-----------------------------------------------------------|
| 3              | Two new data stacks and the original data stack exist   |
+--------------+-----------------------------------------------------------|
| n              | n - 1 new data stacks and the original data stack       |
|                | exist                                                   |
+--------------------------------------------------------------------------+

Examples

1.    Suppose an exec creates two new data stacks using the NEWSTACK
      command and then deletes one data stack using the DELSTACK
      command.  If the exec issues the QSTACK command, QSTACK returns
      2 in the REXX special variable RC.

        "NEWSTACK"    /* data stack 2 created */
        .
        .
        .
        "NEWSTACK"    /* data stack 3 created */
        .
        .
        .
        "DELSTACK"    /* data stack 3 deleted */
        "QSTACK"
        SAY 'The number of data stacks is' RC   /* RC = 2 */

2.    Suppose an exec creates one new data stack and then calls a
      routine that also creates a new data stack.  The called routine
      then calls another routine that creates two new data stacks.
      When either of the called routines or the original exec issues
      the QSTACK command, QSTACK returns 5 in the REXX special
      variable RC.  The data stack that is active is data stack 5.

        "NEWSTACK"  /* data stack 2 created */
        CALL sub1
        "QSTACK"
        SAY 'Data stacks =' RC  /* RC = 5 */
        EXIT
        sub1:
        "NEWSTACK"  /* data stack 3 created */
        CALL sub2
        "QSTACK"
        SAY 'Data stacks =' RC   /* RC = 5 */
        RETURN
        sub2:
        "NEWSTACK"  /* data stack 4 created */
        .
        .
        .
        "NEWSTACK"  /* data stack 5 created */
        "QSTACK"
        SAY 'Data stacks =' RC  /* RC = 5 */
        RETURN
=QUEUED
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--QUEUED()-------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the number of lines remaining in the external data queue
when the function is called.

The TSO/E implementation of the external data queue is the data
stack.

Here is an example:

    QUEUED()    ->    5    /* Perhaps */
=QUEUE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--QUEUE--------------------;-------------------------------------->< |
|               +-expression-+                                           |
|                                                                        |
+------------------------------------------------------------------------+

QUEUE appends the string resulting from expression to the tail of
the external data queue.    That is, it is added FIFO (First In, First
Out).

If you do not specify expression, a null string is queued.

Note:    The TSO/E implementation of the external data queue is the
         data stack.  The length of an element in the data stack can
         be up to one byte less than 16 megabytes.  The data stack
         contains one buffer initially, but you can create additional
         buffers using the TSO/E REXX command MAKEBUF.

Example:

    a='Toft'
    queue a 2  /* Enqueues "Toft 2" */
    queue      /* Enqueues a null line behind the last */

See item QUEUED for the QUEUED built-in function that returns the
number of lines currently in the external data queue.
=RANDOM
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--RANDOM(--------------------------------------)------------------>< |
|                +-max----------------------------|                      |
|                +----min,------------------------+                      |
|                   +-,----+  +-max-+  +-,seed-+                         |
|                                                                        |
+------------------------------------------------------------------------+

Returns a quasi-random nonnegative whole number in the range min to
max inclusive.    If you specify max or min or both, max minus min
cannot exceed 100000.    The min and max default to 0 and 999,
respectively.    To start a repeatable sequence of results, use a
specific seed as the third argument, as described in Note 1.    This
seed must be a positive whole number ranging from 0 to 999999999.

Here are some examples:

    RANDOM()          ->    305
    RANDOM(5,8)       ->      7
    RANDOM(2)         ->      0  /*  0  to  2    */
    RANDOM(,,1983)    ->    123  /* reproducible */

Notes:

1.    To obtain a predictable sequence of quasi-random numbers, use
      RANDOM a number of times, but specify a seed only the first
      time.  For example, to simulate 40 throws of a 6-sided, unbiased
      die:

        sequence = RANDOM(1,6,12345)  /* any number would */
                                      /* do for a seed    */
        do 39
           sequence = sequence RANDOM(1,6)
           end
        say sequence

      The numbers are generated mathematically, using the initial
      seed, so that as far as possible they appear to be random.
      Running the program again produces the same sequence; using a
      different initial seed almost certainly produces a different
      sequence.  If you do not supply a seed, the first time RANDOM is
      called, an arbitrary seed is used.  Hence, your program usually
      gives different results each time it is run.

2.    The random number generator is global for an entire program; the
      current seed is not saved across internal routine calls.
=RETURN
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--RETURN----------------;----------------------------------------->< |
|              +-expression-+                                            |
|                                                                        |
+------------------------------------------------------------------------+

RETURN returns control (and possibly a result) from a REXX program
or internal routine to the point of its invocation.

If no internal routine (subroutine or function) is active, RETURN
and EXIT are identical in their effect on the program that is being
run.    (See item EXIT )

If a subroutine is being run (see the CALL instruction), expression
(if any) is evaluated, control passes back to the caller, and the
REXX special variable RESULT is set to the value of expression.    If
expression is omitted, the special variable RESULT is dropped
(becomes uninitialized).    The various settings saved at the time of
the CALL (tracing, addresses, and so forth) are also restored.    (See
item CALL )

If a function is being processed, the action taken is identical,
except that expression must be specified on the RETURN instruction.
The result of expression is then used in the original expression at
the point where the function was called.

If a PROCEDURE instruction was processed within the routine
(subroutine or internal function), all variables of the current
generation are dropped (and those of the previous generation are
exposed) after expression is evaluated and before the result is used
or assigned to RESULT.
=REVERSE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--REVERSE(string)------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns string, swapped end for end.

Here are some examples:

    REVERSE('ABc.')    ->    '.cBA'
    REVERSE('XYZ ')    ->    ' ZYX'
=RIGHT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--RIGHT(string,length------------)-------------------------------->< |
|                            +-,pad-+                                    |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string of length length containing the rightmost length
characters of string.    The string returned is padded with pad
characters (or truncated) on the left as needed.    The default pad
character is a blank.    The length must be a positive whole number or
zero.

Here are some examples:

    RIGHT('abc  d',8)     ->    '  abc  d'
    RIGHT('abc def',5)    ->    'c def'
    RIGHT('12',5,'0')     ->    '00012'
=RT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--RT-------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

RT (Resume Typing) is an immediate command you can use to resume
terminal output that was previously suppressed.    The RT immediate
command is available only if an exec is running in TSO/E and you
press the attention interrupt key to enter attention mode.    You can
enter RT in response to the REXX attention prompting message,
IRX0920I.    Terminal output that the exec generated after you issued
the HT command and before you issued the RT command is lost.

Example

You are running an exec in TSO/E and have suppressed typing with the
HT command.    You now want terminal output from the exec to display
at your terminal.

To resume typing, press the attention interrupt key.    The system
issues the REXX attention prompting message that asks you to enter
either a null line to continue or an immediate command.    Enter RT to
resume typing.
=RXDATE
)F Function -
RXDATE -- provides enhancements to all options of the DATE()
function provided by REXX, and also provides 9 additional options.

The format of the RXDATE function is:

+--------------------------------------------------------------+
    RXDATE((option,parm1,parm2))
+--------------------------------------------------------------+

Options:

NULL option i.e. RXDATE() or RXDATE(,parm1) converts the date
     supplied in parm1 to the format 'dd Mmm yyyy', and returns it
     as the value of the function.

     parm1 = a Date in the format mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(,'10/06/85')   returns ===> 06 Oct 1985
           RXDATE(,'10/06/2000') returns ===> 06 Oct 2000

C    (Century); returns as the function value, the number of day into
     the century the date represents. The returned value is of the form
     ddddd with no leading zeroes.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(c,'01/10/85')   returns ===> 31056
           RXDATE(c,'01/10/1800') returns ===> 10

D    (Days); returns as the function value, the number of days into the
     year, the date represents.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(d,'01/10/85')   returns ===> 10
           RXDATE(d,'07/10/1800') returns ===> 191

E    (European); returns as the value of the function, dd/mm/yy if
     the date supplied in parm1 is >= the 1900's, or dd/mm/yyyy if
     the date supplied in parm1 is < the 1900's.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(e,'01/23/85')   returns ===> 23/01/85
           RXDATE(e,'01/23/1800') returns ===> 23/01/1800

J    (Julian-OS); returns as the value of the function, yyddd
     representing the date supplied in parm1.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(j,'07/23/85')   returns ===> 85204
           RXDATE(j,'07/23/1885') returns ===> 85204

M    (Month); returns as the value of the function, the full name of
     the month, for the date supplied in parm1.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(m,'01/23/85')   returns ===> January
           RXDATE(m,'07/23/1885') returns ===> July

O    (Ordered); returns as the value of the function,  yy/mm/dd if the
     date supplied in parm1 is >= the 1900's, or yyyy/mm/dd if the date
     supplied in parm1 is < the 1900's.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(o,'07/23/85')   returns ===> 85/07/23
           RXDATE(o,'07/23/1885') returns ===> 1885/07/23

S    (Sorted); returns as the value of the function, yyyymmdd
     representing the date supplied in parm1

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(s,'07/23/85')   returns ===> 19850723
           RXDATE(s,'07/23/1885') returns ===> 18850723

U    (USA); returns as the value of the function,  mm/dd/yy if the
     date supplied in parm1 is >= the 1900's, or mm/dd/yyyy if the date
     supplied in parm1 is < the 1900's. If you just want the
     current date, the built-in DATE() function is more efficient.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(u,'07/23/85')   returns ===> 07/23/85
           RXDATE(u,'07/23/1985') returns ===> 07/23/85
           RXDATE(u,'07/23/1885') returns ===> 07/23/1885

W    (WEEKDAY) returns as the value of the function, the full name of
     the day-of-the-week, for the date specified in parm1.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(w,'01/01/2000') returns ===> Saturday
           RXDATE(w,'07/04/1776') returns ===> Thursday

1    Converts TRUE Julian number to corresponding GREGORIAN date,
     and returns the GREGORIAN date as the value of the function.

     parm1 = null (TRUE julian number for current date) or
             number in range 1721426-5373484 inclusive.
                 1721426 = 01/01/0001
                 5373484 = 12/31/9999
     parm2 = not used

     e.g.  RXDATE(1,2446270)   returns ===> 07/23/85
           RXDATE(1,2455198)   returns ===> 01/01/2010

2    Converts GREGORIAN date to corresponding TRUE Julian number, and
     returns the TRUE julian number as the value of the function.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(2,'07/23/85')   returns ===> 2446270
           RXDATE(2,'01/01/2010') returns ===> 2455198

3    Converts Julian-OS (yyddd) to TRUE Julian number, and returns the
     TRUE julian number as the value of the function.

     parm1 = null (Julian-OS for current date) or yyddd
             yy assumed if >= 1900's
     parm2 = not used

     e.g.  RXDATE(3,85100)   returns ===> 2446166

4    Converts TRUE Julian number to Julian-OS, and returns the
     Julian-OS as the value of the function.

     parm1 = null (TRUE julian number for current date) or
             number in range 1721426-5373120 inclusive.
                 1721426 = 01/01/0001
                 5373120 = 12/31/9999
     parm2 = not used

     e.g.  RXDATE(4,2446270)   returns ===> 85204    07/23/85
           RXDATE(4,2455198)   returns ===> 10001    01/01/2010

     *** note -- Obviously this makes sense only for the 1900's.

5    Converts Julian-OS to GREGORIAN date, and returns the GREGORIAN
     date as the value of the function.

     parm1 = null (Julian-OS for current date) or yyddd
             yy assumed if >= 1900's
     parm2 = not used

     e.g.  RXDATE(5,85205)   returns ===>  07/24/85

6    Returns the date xx days hence or before.  Base date supplied in
     parm1, number of days hence (+ or -) supplied in parm2.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = null (0) or positive/negative integer

     e.g.  RXDATE(6,,1)            returns ===>  next day's date
           RXDATE(6,'07/23/85',10) returns ===>  08/02/85
           RXDATE(6,'07/23/85',-5) returns ===>  07/18/85

7    Returns as the value of the function, the number of days from one
     date to another. The number of days from one day to the next is
     considered one (1).

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = null (current date) or mm/dd/yy or mm/dd/yyyy

     e.g.  RXDATE(7,,'01/01/2000')             returns ===>  5288
                  (assuming current date is 7/10/85)
           RXDATE(7,'01/01/1900','01/01/2000') returns ===> 36524
           RXDATE(7,'01/01/2000','01/01/1900') returns ===> 36524

8    Returns as the value of the function, the number of the
     day-of-the-week, 1-7 for Sunday-Saturday respectively, for
     date specified in parm1.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(8,'01/01/2000') returns ===> 7
           RXDATE(8,'07/04/1776') returns ===> 5

9    Edits the supplied date.  Returns '1' if date supplied in parm1 is
     valid; returns 'ERROR' if date is invalid.

     parm1 = null (current date) or mm/dd/yy or mm/dd/yyyy
     parm2 = not used

     e.g.  RXDATE(9,'a1/01/2000') returns ===> ERROR
           RXDATE(9,'01/33/1985') returns ===> ERROR    (33 not valid)
           RXDATE(9,'07/04/1776') returns ===> 1
           RXDATE(9,'02/29/85')   returns ===> ERROR    (not leap year)
           RXDATE(9,'02/29/84')   returns ===> 1


Defaults:

Discussed under each option.

---------------------- NOTES NOTES NOTES -----------------------

When specifying dates in the parms, the date can be supplied as
mm/dd/yy, or mm/dd/yyyy.    This allows for dates not in the 1900's.
Any date of the form mm/dd/yy is assumed in the 1900's if yy is >=
the value of the date window variable (win19xx)..

For options requesting a date be returned in the form mm/dd/yy,
dd/mm/yy, or yy/mm/dd, the yy portion will be 2 digits if the year
is >= the 1900's or 4 digits if < the 1900's.

The RXDATE function emulates all of the options of the REXX built-
in function DATE(), and also has nine (9) other options.    The REXX
built-in DATE() function however, returns data concerning the
current date only; for example DATE(M) will return the full name of
the current month, whereas RXDATE(M) will do the same thing, but you
can specify a parm i.e.    RXDATE(M,'02/13/86') which will return
'February'.

This is true for all of the RXDATE options which correspond to the
same option for the REXX DATE built-in function.

Options C, D, E, J, M, O, S, U, and W are the same as for the DATE
built-in function, except you can specify any date as a parm.    As
another example of this, if today is Wednesday, and you execute code
DATE(W), or RXDATE(W), 'Wednesday' will be returned from the
function; if you want to know what day January 1, 2000 is, you can
code:

          day = RXDATE(W,'01/01/2000')

and the variable 'day' will contain 'Saturday'.

=RXVSAM
)F Function -
RXVSAM

RXVSAM is a REXX function to access VSAM files in an MVS, TSO or
ISPF environment.    You can access VSAM ESDS, KSDS or RRDS files
using RXVSAM, and its syntax is like any other REXX function.
RXVSAM consists of two assembler CSECTS, supplied in source code
format.

Syntax

All calls to the RXVSAM function take the form:
          RXVSAM(request,ddname,key/filetype,recordarea)

The first two arguments are always required, arguments 3 and 4 are
sometimes optional.    Argument definitions:

          request - what you want to do, for example:  read a record,
                  begin browsing a file in a forward direction, and so
                  on.
          ddname - the MVS ddname for the VSAM file that contains your
                  data.  The ddname may come from an allocate
                  statement when in TSO or ISPF, or a ddname in your
                  JCL if you are running your REXX program in batch.
          key / filetype - the key or relative record number for your
                  data or the type of VSAM file (ESDS, KSDS or RRDS).
                  The filetype indication is only required for open
                  requests.  For other requests, you will usually
                  indicate a key.  For some requests, this argument
                  may be omitted, and its absence should be indicated
                  by a comma when the next argument is present (see
                  below for more information).
          recordarea - the REXX variable name that contains your data.
                  You can omit this argument too, and RXVSAM will use
                  the default variable name RXVSAM_RECORD.

Request Values

There are 5 types of requests:    opens, closes, reads, writes and
starts.    The values for request may be coded as a literal (within
quotes) or as a REXX variable set to the    desired request value.
The request, whether it is a REXX variable or a literal, must be in
uppercase, coded exactly as shown below:

                  OPENINPUT OPENOUTPUT OPENIO
                  CLOSE
                  READ READGENERIC READNEXT READPREV READLAST
                  WRITE REWRITE DELETE
                  STARTFWD STARTBWD

The above values are self-explanatory, mirroring the actions you
would perform from a COBOL program, or in a CICS EXEC
statement.    There are the usual restrictions:  you must read a record
before attempting to rewrite or delete it, you must have established
positioning within a file using STARTFWD (for reading forward in a
file) or STARTBWD (for reading backward in a file) before a READNEXT
or READPREV request, you must have a file open for input (or I/O) if
you are going to read records, and you must have a file open for
output (or I/O) if you are going to write records.

DDNAME Values

There are no restrictions on the ddname other than those imposed by
MVS.    It must be 1 to 8 uppercase or national characters.  If you
are executing in a TSO or ISPF session, the file must be allocated
prior to any RXVSAM calls.    If you are executing in batch, the
ddname must be present in your JCL.

Key / Filetype Values

Filetype must be in uppercase.    Indicate either 'ESDS', 'KSDS', or
'RRDS' depending on the type of your VSAM file.    Filetype is only
valid with one of the open requests.    For other requests you will
most often code a key.    This key may be either a REXX variable or a
literal.    For RRN datasets, code the key as a normal REXX numeric
(for example '24' to read record number 24).    For keys that contain
packed decimal data, you must construct the components of the key
carefully.    REXX does not recognize packed decimal (other than as a
string of characters), and you may need to "build" your key using a
combination of hexadecimal and character literals.

The key should be null for the following cases:
          READNEXT, READPREV and READLAST requests
          Writing sequentially to an RRDS for the first time
              (initialization)
          Writing to an ESDS
Note that direct reads on an ESDS are possible, using the RBA as the
"key".    This is given in decimal just as a "key" for an RRDS.
However, if your RBA is not an address that is on a record boundry,
you will get an error.

Recordarea Values

This is the name of the variable that contains record data.    It is
important to note that this is the NAME of the variable. Most often,
this will be a literal.    If you code a variable, its value will be
the name used as the record area.    Of course, since an uninitialized
REXX variable's value is the uppercase version of the variable name,
if you accidently omit the surrounding quotes when you mean to use a
literal, you may get the desired result.    This is not clear REXX
coding, however.

If you omit this argument, RXVSAM will use a default name of
RXVSAM_RECORD.    For simple programs that read / write only one file,
it might be easier to use this default.

Examples:
The following example will open a KSDS file, perform a direct read
on a record with a key of "AAA001", then close the file.

          rxvsam_result = RXVSAM('OPENINPUT','VSAMFILE','KSDS')
          IF rxvsam_result \= 0 THEN SAY 'Open Failed'
          keyaaaa = 'AAA001'          /* set value of key data */
          rxvsam_result = RXVSAM('READ','VSAMFILE','KEYAAAA','MY_REC')
          IF rxvsam_result \= 0 THEN SAY 'Read Failed'
          ELSE SAY 'The record is:' my_rec
          rxvsam_result = RXVSAM('CLOSE','VSAMFILE')


The following example will open an RRDS file, and write two records
to it.

          rxvsam_result = RXVSAM('OPENOUTPUT','VSAMFILE','RRDS')
          IF rxvsam_result \= 0 THEN SAY 'Open Failed'
          my_rec = 'AAAAAAAAAAAAAAAAAAAA'
          rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')
          IF rxvsam_result \= 0 THEN SAY 'First write Failed'
          my_rec = 'BBBBBBBBBBBBBBBBBBBB'
          rxvsam_result = RXVSAM('WRITE','VSAMFILE',,'MY_REC')
          IF rxvsam_result \= 0 THEN SAY 'Second write Failed'
          rxvsam_result = RXVSAM('CLOSE','VSAMFILE')

Error Messages

RXVSAM always returns a result, which is a decimal number.    In
addition, it sets the REXX variable RXVSAM_RETURNMSG with an
explanatory text.    All messages are in the form:  nnnns "text" where
nnnn is the message number, s is the severity level (I -
information, W - warning, E - error), and    text is a short
explanation of the problem.    In some cases, VSAM raised a condition
that RXVSAM is not prepared to handle (this may indicate a problem
with RXVSAM).    In that case, an additional variable,
RXVSAM_VSAMERRORMSG is set with the return and reason codes from
VSAM, and the location (label) in RXVSAM where the error occurred.

Following is a list of all messages:

0000I Request successfully processed
          no further action necessary

0001E Invalid argument passed
          a keyword or request is probably misspelled

0002E Open failed
          RXVSAM could not generate an ACB - check RXVSAM_VSAMERRORMSG
          for a return code from VSAM and check to see the DDNAME is
          correct

0003E Close failed
          check RXVSAM_VSAMERRORMSG for the VSAM return code and check
          to see the DDNAME is correct

0004W End of File
          perform end of file logic in your REXX program

0005E File is already open
          A previous OPEN was done for this DDNAME - ensure the DDNAME
          is correct

0007E REXX record variable could not be accessed or was undefined
          This error can occur on a WRITE or REWRITE request and
          usually indicates the variable that contains record data is
          an undefined variable.

0008E Duplicate record
          VSAM indicates this is a duplicate record

0010E Unable to save VSAM error data
          This is an internal RXVSAM error

0011E Unable to set return message text
          This is an internal RXVSAM error

0012E ACB was not available to perform CLOSE request - file may not
          be open. No ACB could be found for the DDNAME you specified -
          ensure the DDNAME is for the correct file, and that the file
          has been opened

0014E ACB was not available to perform request - file may not be
          open. No ACB could be found for the DDNAME you specified -
          ensure the DDNAME is for  the correct file, and that the
          file has been opened

0015E Unable to obtain max record length for this file
          This is probably an internal RXVSAM error (a SHOWCB macro
          failed), check RXVSAM_VSAMERRORMSG for the VSAM return code

0016W Record not found
          Perform not found logic in your REXX program

0016E Record not found - a FULL KEY must be specified when issuing a
          STARTBWD request.  For STARTBWD only: if you specified a full
          key, perform not found logic in your REXX program.  You
          cannot specify a partial (generic) key for a STARTBWD
          request.

0017E Cannot determine length of record
          This is probably an internal RXVSAM error (a SHOWCB macro
          failed), check RXVSAM_VSAMERRORMSG for the VSAM return code

0018E Unable to modify RPL for "UPDate"
          This is probably an internal RXVSAM error (a MODCB macro
          failed), check RXVSAM_VSAMERRORMSG for the VSAM return code

0019E Function failed
          This is probably an internal RXVSAM error,
          RXVSAM_VSAMERRORMSG may give additional information

0020E Unable to update RECORD variable
          This may indicate a storage constraint if you are running in
          a TSO or ISPF session, or an internal error in RXVSAM

0021E File is not open for INPUT
          You are trying to perform a READ function, but the file is
          only open for output

0022E File is not open for OUTPUT
          You are trying to perform a WRITE, REWRITE or DELETE
          function, but the file is only open for input

0023E Unable to switch to DIR processing
          This is probably an internal RXVSAM error,
          RXVSAM_VSAMERRORMSG may give additional information

0024E READGENERIC only allowed for KSDS
          You are attempting a READGENERIC function on an ESDS or RRDS

0025E Non-numeric key specified for an RRDS
          The key you passed for an RRDS is not numeric.  If you are
          passing a REXX variable, ensure the variable contains a
          valid numeric string, and not a binary or packed number

0026E This function is not allowed for an ESDS
          START, REWRITE and DELETE are not allowed for an ESDS

0088E READPREV attempted without a previous STARTBWD
          You must first issue a STARTBWD for positioning before
          READPREV request

0092E REWRITE or DELETE attempted without a previous READ
          You must first read a record before attempting to rewrite or
          delete it

0108E Record length = 0, > max, < key length (KSDS) or not equal to
          slot size (fixed length RRDS). This is a catchall record
          length error.  For a KSDS, a record must be at least the
          size of the key, and may not be greater than the maximum
          record size defined for the file when it was created.  For a
          fixed-length RRDS, all records must be equal to the record
          slot size.  In all cases, ensure the record variable you
          pass RXVSAM is not set to a null string as this will be a
          "zero length" record.


Installation

RXVSAM consists of two CSECTs: RXVSAM and RXVSAMSG.    RXVSAM contains
executable code, and RXVSAMSG contains texts for error messages.    A
VCON in RXVSAM points to RXVSAMSG, so the two CSECTs should be
link-edited together as one load module.    Total module size is a
little over 10K (2A08).    RXVSAM is reentrant, and runs in 31-bit
mode (AMODE=31, RMODE=ANY).

In addition to the VSAM and REXX macros, name / token services and a
few "standard" MVS control block macros are used in RXVSAM.    These
macros are found in SYS1.MACLIB in most installations.    Primary
testing was done using HLASM 5696-234, release 2.0.

To install, assemble the CSECTs and link.    TSO/ISPF users: make sure
the load library into which RXVSAM is linked is either a common one
in the link list, or specifically allocated via the ISPLLIB dd in
your TSO session.    Similarly, for batch users, RXVSAM must be in one
of the link list libraries, or allocated via a JOBLIB or STEPLIB
card.

=SAY
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SAY----------------;-------------------------------------------->< |
|           +-expression-+                                               |
|                                                                        |
+------------------------------------------------------------------------+

SAY writes a line to the output stream.    This typically displays it
to the user, but the output destination can depend on the
implementation.    The result of expression may be of any length.  If
you omit expression, the null string is written.

If a REXX exec runs in TSO/E foreground, SAY displays the expression
on the terminal.    The result from the SAY instruction is formatted
to the current terminal line width (as defined by the TSO/E TERMINAL
command) minus 1 character.    In TSO/E background, SAY writes the
expression to the output stream, which is SYSTSPRT.    In either case,
when the length is undefined (LINESIZE() returns 0), SAY uses a
default line size of 80.

If an exec runs in a non-TSO/E address space, SAY writes the
expression to the output stream as defined by the OUTDD field in the
module name table.  The system default is
SYSTSPRT.    The ddname may be change on an application basis or on a
system basis.

Example:

    data=100
    Say data 'divided by 4 =>' data/4
    /* Displays: "100 divided by 4 => 25"  */
=SELECT
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SELECT;----------------------------------------------------------> |
|                                                                        |
|      <-------------------------------------------------------+         |
| >----WHEN--expression-----------THEN-----------instruction-----------> |
|                           +-;-+          +-;-+                         |
|                                                                        |
| >---------------------------------------------END--;---------------->< |
|      +-OTHERWISE-----------------------------+                         |
|                  +-;-+  |  <-----------+  |                            |
|                         +---instruction---+                            |
|                                                                        |
+------------------------------------------------------------------------+

SELECT conditionally calls one of several alternative instructions.

Each expression after a WHEN is evaluated in turn and must result in
0 or 1.    If the result is 1, the instruction following the
associated THEN (which may be a complex instruction such as IF, DO,
or SELECT) is processed and control then passes to the END.    If the
result is 0, control passes to the next WHEN clause.

If none of the WHEN expressions evaluates to 1, control passes to
the instructions, if any, after OTHERWISE.    In this situation, the
absence of an OTHERWISE causes an error (but note that you can omit
the instruction list that follows OTHERWISE).

Example:

    balance=100
    check=50
    balance = balance - check
    Select
      when balance > 0 then
           say 'Congratulations! You still have' balance 'dollars left.'
      when balance = 0 then do
           say 'Attention, Balance is now zero!  STOP all spending.'
           say "You cut it close this month! Hope you do not have any"
           say "checks left outstanding."
           end
      Otherwise
           say "You have just overdrawn your account."
           say "Your balance now shows" balance "dollars."
           say "Oops!  Hope the bank does not close your account."
    end  /* Select */

Notes:

1.    The instruction can be any assignment, command, or keyword
      instruction, including any of the more complex constructs such
      as DO, IF, or the SELECT instruction itself.

2.    A null clause is not an instruction, so putting an extra
      semicolon (or label) after a THEN clause is not equivalent to
      putting a dummy instruction.  The NOP instruction is provided
      for this purpose.

3.    The symbol THEN cannot be used within expression, because the
      keyword THEN is treated differently, in that it need not start a
      clause.  This allows the expression on the WHEN clause to be
      ended by the THEN without a ; (delimiter) being required.
=SETLANG
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SETLANG(--------------)----------------------------------------->< |
|                +-langcode-+                                            |
|                                                                        |
+------------------------------------------------------------------------+

SETLANG returns a three character code that indicates the language
in which REXX messages are currently being displayed.    Table KKKK
shows the language codes that replace the function call and the
corresponding languages for each code.

You can optionally specify one of the language codes as an argument
on the function to set the language in which REXX messages are
displayed.    In this case, SETLANG returns the code of the language
in which messages are currently displayed and changes the language
in which subsequent REXX messages will be displayed.

+------------------------------------------------------------------------+
| Table KKKK. Language Codes for SETLANG Function That Replace           |
|            the Function Call                                           |
+------------------------------------------------------------------------|
| Language      |                                                        |
| Code          | Language                                               |
+-------------+----------------------------------------------------------|
| CHS           | Simplified Chinese                                     |
+-------------+----------------------------------------------------------|
| CHT           | Traditional Chinese                                    |
+-------------+----------------------------------------------------------|
| DAN           | Danish                                                 |
+-------------+----------------------------------------------------------|
| DEU           | German                                                 |
+-------------+----------------------------------------------------------|
| ENP           | US English - all uppercase                             |
+-------------+----------------------------------------------------------|
| ENU           | US English - mixed case (upper and lowercase)          |
+-------------+----------------------------------------------------------|
| ESP           | Spanish                                                |
+-------------+----------------------------------------------------------|
| FRA           | French                                                 |
+-------------+----------------------------------------------------------|
| JPN           | Japanese                                               |
+-------------+----------------------------------------------------------|
| KOR           | Korean                                                 |
+-------------+----------------------------------------------------------|
| PTB           | Brazilian Portuguese                                   |
+------------------------------------------------------------------------+

Here are some examples::

    curlang = SETLANG()     -> 'ENU'
                              /* returns current language (ENU)  */
    oldlang = SETLANG("ENP")-> 'ENU'
                           '  /* returns current language (ENU)
                                 and sets language to US English
                                 uppercase (ENP)                 */

You can use the SETLANG function in an exec that runs in any MVS
address space (TSO/E and non-TSO/E).

After an exec uses SETLANG to set a specific language, any REXX
message the system issues is displayed in that language.    If the
exec calls another exec (either as a function or subroutine or using
the TSO/E EXEC command), any REXX messages are displayed in the
language you specified on the SETLANG function.    The language
specified on SETLANG is used as the language for displaying REXX
messages until another SETLANG function is invoked or the
environment in which the exec is running terminates.

Notes:

1.    The default language for REXX messages depends on the language
      feature that is installed on your system.  The default language
      is in the language field of the parameters module.
      Use the SETLANG function to determine and
      set the language for REXX messages.

2.    The language codes you can specify on the SETLANG function also
      depend on the language features that are installed on your
      system.  If you specify a language code on the SETLANG function
      and the corresponding language feature is not installed on your
      system, SETLANG does not issue an error message.  However, if
      the system needs to display a REXX message and cannot locate the
      message for the particular language you specified, the system
      issues an error message.  The system then tries to display the
      REXX message in US English.

3.    Your installation can customize TSO/E to display certain
      information at the terminal in different languages.  Your
      installation can define a primary and secondary language for the
      display of information.  The language codes for the primary and
      secondary languages are stored in the user profile table (UPT).
      You can use the TSO/E PROFILE command to change the languages
      specified in the UPT.

      The languages stored in the UPT do not affect the language in
      which REXX messages are displayed.  The language for REXX
      messages is controlled only by the default in the language field
      of the parameters module and the SETLANG function.

      For information about customizing TSO/E for different languages
      and the types of information that are displayed in different
      languages, see z/OS TSO/E Customization.

4.    The SYSVAR external function has the SYSPLANG and SYSSLANG
      arguments that return the user's primary and secondary language
      stored in the UPT.  You can use the SYSVAR function to determine
      the setting of the user's primary and secondary language.  You
      can then use the SETLANG function to set the language in which
      REXX messages are displayed to the same language as the primary
      or secondary language specified for the user.  See "SYSVAR"  in
      item SYSVAR for more information.

Examples:

The following are some examples of using SETLANG:

1.    To check the language in which REXX messages are currently being
      displayed, use the SETLANG function as follows:

        currlng = SETLANG()     /* for example, returns ENU */

2.    The SYSPLANG argument of the SYSVAR function returns the user's
      primary language that is stored in the user profile table
      (UPT).

      The following example uses the SYSVAR function to determine the
      user's primary language and then uses the SETLANG function to
      check the language in which REXX messages are displayed.  If the
      two languages are the same, no processing is performed.  If the
      languages are different, the exec uses the SETLANG function to
      set the language for REXX messages to the same language as the
      userÛs primary language.

        /*  REXX ...   */
          .
          .
          .
        proflang = SYSVAR('SYSPLANG')
                   /* check primary language in UPT     */
        rexxlang = SETLANG()
                   /* check language for REXX messages  */
        IF proflang ^= rexxlang THEN
           newlang = SETLANG(proflang)
                   /* set language for REXX messages    */
                   /* to user's primary language        */
        ELSE NOP   /* otherwise, no processing needed   */
          .
          .
          .
        EXIT
=SIGNAL
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SIGNAL----labelname------------------------------;-------------->< |
|               +------------expression---------------|                  |
|               |  +-VALUE-+                          |                  |
|               +-OFF---ERROR-------------------------|                  |
|               |     +-FAILURE-|                     |                  |
|               |     +-HALT----|                     |                  |
|               |     +-NOVALUE-|                     |                  |
|               |     +-SYNTAX--+                     |                  |
|               +-ON---ERROR--------------------------+                  |
|                    +-FAILURE-|  +-NAME--trapname-+                     |
|                    +-HALT----|                                         |
|                    +-NOVALUE-|                                         |
|                    +-SYNTAX--+                                         |
|                                                                        |
+------------------------------------------------------------------------+

SIGNAL causes an unusual change in the flow of control (if you
specify labelname or VALUE expression), or controls the trapping of
certain conditions (if you specify ON or OFF).

To control trapping, you specify OFF or ON and the condition you
want to trap.    OFF turns off the specified condition trap.  ON turns
on the specified condition trap.    All information about condition
traps is contained in "Conditions and Condition Traps"    in item
-CONDS-TRAPS.

To change the flow of control, a label name is derived from
labelname or taken from the result of evaluating the expression
after VALUE.    The labelname you specify must be a literal string or
symbol that is taken as a constant.    If you use a symbol for
labelname, the search is independent of alphabetic case.    If you use
a literal string, the characters should be in uppercase.    This is
because the language processor translates all labels to uppercase,
regardless of how you enter them in the program.    Similarly, for
SIGNAL VALUE, the expression must evaluate to a string in uppercase
or the language processor does not find the label.    You can omit the
subkeyword VALUE if expression does not begin with a symbol or
literal string (that is, if it starts with a special character, such
as an operator character or parenthesis).    All active pending DO,
IF, SELECT, and INTERPRET instructions in the current routine are
then ended (that is, they cannot be resumed).    Control then passes
to the first label in the program that matches the given name, as
though the search had started from the top of the program.

Example:

    Signal fred;  /* Transfer control to label FRED below */
      ....
      ....
    Fred: say 'Hi!'

Because the search effectively starts at the top of the program, if
duplicates are present, control always passes to the first
occurrence of the label in the program.

When control reaches the specified label, the line number of the
SIGNAL instruction is assigned to the special variable SIGL.    This
can aid debugging because you can use SIGL to determine the source
of a transfer of control to a label.

Using SIGNAL VALUE

The VALUE form of the SIGNAL instruction allows a branch to a label
whose name is determined at the time of execution.    This can safely
effect a multi-way CALL (or function call) to internal routines
because any DO loops, and so forth, in the calling routine are
protected against termination by the call mechanism.

Example:

    fred='PETE'
    call multiway fred, 7
       ....
       ....
    exit
    Multiway: procedure
       arg label .     /* One word, uppercase                  */
                       /* Can add checks for valid labels here */
       signal value label   /* Transfer control to wherever    */
       ....
    Pete: say arg(1) '!' arg(2) /* Displays: "PETE ! 7"        */
       return
=SIGN
)F Function -
>>--SIGN(number)--------------------------------------------------------><

returns a number that indicates the sign of number.    The number is
first rounded according to standard REXX rules, just as though the
operation number+0 had been carried out.    Returns -1 if number is
less than 0; returns 0 if it is 0; and returns 1 if it is greater
than 0.

Here are some examples:

    SIGN('12.3')       ->     1
    SIGN(' -0.307')    ->    -1
    SIGN(0.0)          ->     0
*-------------------------------------------------------------------*
*    Below are two ways of sorting stem variables, without using ISPF.
*    If using ISPF is not an issue, suggest checking out STEMSORT.
*-------------------------------------------------------------------*

     A) Example No. 1
          /* From Doug Nadel's list address spaces. */
          sort:
          Procedure Expose names.
          n=names.0
          Do i= 1 to n-1
            Do j=i+1 to n
              If names.i>names.j Then
                Do
                  t=names.i
                  names.i=names.j
                  names.j=t
                End
            End
          End
          Return

     B) Example No. 2
          /* rexx command to sort a stem variable */
             Simple bubble sort of "stem' by stem.1
             Ken Singer, Shell Oil, Houston
           ********************************************************/
             sort_files: procedure expose stem.
             if stem.0 = 1 then return /* simple sort !*/
             ctr =  stem.0
             do y = 1 to  ctr - 1
                do x = y+1 to ctr
                   if stem.x < stem.y then do
                       /* swap these 2 entries */
                       t1 = stem.y ;
                       stem.y = stem.x
                       stem.x = t1
                   end
                end x
             end y

=SOURCELINE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SOURCELINE(-----------)----------------------------------------->< |
|                     +-n-+                                              |
|                                                                        |
+------------------------------------------------------------------------+

Returns the line number of the final line in the program if you omit
n or 0 if the implementation does not allow access to the source
lines.    If you specify n, returns the nth line in the program if
available at the time of execution; otherwise, returns the null
string.    If specified, n must be a positive whole number and must
not exceed the number that a call to SOURCELINE with no arguments
returns.

Here are some examples:

    SOURCELINE()    ->   10
    SOURCELINE(1)   ->   '/* This is a 10-line REXX program */'
=SPACE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SPACE(string--------------------------)------------------------->< |
|                     +-,------------------+                             |
|                         +-n-+  +-,pad-+                                |
|                                                                        |
+------------------------------------------------------------------------+

Returns the blank-delimited words in string with n pad characters
between each word.    If you specify n, it must be a positive whole
number or zero.    If it is 0, all blanks are removed.  Leading and
trailing blanks are always removed.    The default for n is 1, and the
default pad character is a blank.

Here are some examples:

    SPACE('abc  def  ')          ->    'abc def'
    SPACE('  abc def',3)         ->    'abc   def'
    SPACE('abc  def  ',1)        ->    'abc def'
    SPACE('abc  def  ',0)        ->    'abcdef'
    SPACE('abc  def  ',2,'+')    ->    'abc++def'

=STEMEDIT
)F Function -
MODULE NAME = STEMEDIT

DESCRIPTIVE NAME = Display REXX Stem Variables using BRIF or VIIF.

FUNCTION = This assembler sub-routine can be invoked by a REXX
             EXEC to display the contents of stem variables using
             the ISPF BRIF, VIIF or EDIT services.  STEMEDIT is
             a nice complement to the REXX OUTTRAP function,
             when it is used in the ISPF/PDF environment.

             STEMEDIT can also PULL lines from the data stack
             instead of using stem variables.  This only works
             with EDIT or VIEW, i.e. not with BROWSE.

SYNTAX
     CALL STEMEDIT  service,
                    stemname
                    <,firstelem>
                    <,stemcount>
                    <,title>
                    <,panel>
                    <,lrecl>
                    <,recfm>
                    <,profile>

     Arguments:
          service   This argument must be coded as 'BROWSE', 'VIEW'
                    or 'EDIT'.  It indicates which of the BRIF,
                    VIIF or EDIF services will be used for display.

                    If the BROWSE service is requested, the user can
                    enter the V commands on the BROWSE screen to
                    switch to VIEW.  This allows the data to be
                    saved using CREATE/REPLACE, CUT or ROUTE.

          stemname  the stem of the family of variables to display.
                    The combined lengths of the stemname argument
                    and the largest subscript (plus the period, if
                    specified) cannot exceed 80 characters.
                    If stemname is a true REXX stem, code a period
                    as the last character.  If you do not specify
                    the period, the subscripts will be concatenated
                    to the stem name without an intervening period.
                    For example, if you specify a stemname of "ABC.",
                    STEMEDIT will look for variables of the form
                    "ABC.1", "ABC.2", etc. If you specify a stemname
                    of "XYZ" (no period), STEMEDIT will look for
                    variables of the form "XYZ1", "XYZ2", etc.

                    If the service is coded as "VIEW" or "EDIT" and
                    stemname is omitted, STEMEDIT PULLs lines from
                    the stack.

          firstelem the element of the pseudo-array to begin the
                    display on.  The default value is element 1.

          stemcount the number of elements to display.
                    If you do not specify stemcount, STEMEDIT will
                    display variables beginning with firstelem, and
                    continuing until an un-initialized variable is
                    found (i.e., a variable which has its name for
                    a value).

          title     an arbitrary character string which identifies
                    the data which is being displayed.  The maximum
                    length of this string is 54 characters.

          panel     a 1 to 8 character name of the panel member
                    to use for the display.
                    The default panel is ISRBROBA for BROWSE
                    and ISREDDE2 for VIEW and EDIT.

          lrecl     the record length that should be passed to
                    the BRIF, VIIF or EDIF services.
                    The default value is 255.

          recfm     the record format that should be passed to
                    the BRIF, VIIF or EDIF services.
                    Possible values are F, FA, FM, V, VA, VM, or U.
                    The default value is V.

          profile   the 8-char name of the profile that should be
                    used by VIIF and EDIF when the VIEW or EDIT
                    services are requested.
                    The default value is TEXT.

     Examples:
          Call the STEMEDIT routine to display the output of the
          TSO "LISTCAT" command.  The variables to display
          begin with the characters "LINE.":

             CALL OUTTRAP 'LINE.'
             "LISTCAT"
             CALL STEMEDIT 'BROWSE','LINE.',,,'List Catalog'

          QUEUE JCL to the data stack and call the STEMEDIT
          routine to VIEW it:

             "MAKEBUF"
             QUEUE '//MYJOB JOB 12345,CLASS=A'
             QUEUE '//STEP2 EXEC PGM=IEFBR14'
             CALL STEMEDIT 'VIEW',,,,'Sample JCL'
             "DROPBUF"

RETURN-CODES
         The STEMEDIT function returns a return code that indicates
         whether the display worked.  The returned value is
         contained in the RC special variable.

         The following STEMEDIT return code values are possible:

         0    The display was successful.

         4    There were no stems matching the description given in
              stemname (BROWSE).  The data was not modified (EDIT).

         8    Option incompatible with requested service.

         12   Invalid Service requested.

         16   BRIF, VIIF or EDIF failed.

USAGE NOTES
         The EDIT service only works with a stem variable.
         If the data is modified by the user, STEMEDIT DROPs the
         stem variable, sets stem.0 to the number of records
         written, copies records to the stem.1 through stem.n
         where n is equal to the value of the stem.0 variable,
         and sets the RC variable to 0.  If the data is not
         modified by the user, STEMEDIT sets the RC variable to 4.

COMPATIBILITY
         STEMEDIT has been designed to be compatible with
         the STEMDISP function of the REXXTOOLS product from
         Open Software Technologies, with the following
         exceptions:

         1. STEMEDIT supports the BROWSE, VIEW and EDIT services
            (STEMDISP only supports BROWSE).

         2. If stemcount is not specified, STEMEDIT scans
            variables until an unitialised variable is found.
            (STEMDISP stops after 100000 variables).

         3. STEMEDIT has the ability to retrieve data from a
            stem variable or the data stack (STEMDISP can only
            retrieve data from a stem variable).

=STEMPULL
)F Function -
Name              : STEMPULL

Function          : This program provides an external REXX function
                    to retrive REXX stem variables from the stack
                    created by the STEMPUSH function.

                    The 'stack' is in fact a dataspace whose STOKEN
                    is passed (in EBCDIC) from the STEMPUSH function.
                    This 'token' is used by this program to access
                    the dataspace and set up the REXX variables.

                    After the stack has been processed it is deleted
                    unless the user specifies the 'NODELETE' keyword.

Syntax            : rcode = STEMPULL(token,delflag)

                    where :   rcode  -  Return code :
                                        0  - One or more stem variables
                                             have been 'pulled' from
                                             the stack.
                                        1  - Stack is full - truncation
                                             occurred in STEMPUSH
                                        2  - Stack is empty.
                                        4  - No stack found that
                                             matches the 'token'.
                                        8  - Token missing or delflag
                                             invalid.

                              token  -  The 16-byte token returned by
                                        STEMPUSH that identifies the
                                        stem variable 'stack'.

                              delflag-  Indicator that specifies if the
                                        dataspace is deleted after
                                        being processed.
                                        Possible values :
                                        'DELETE'   - Always delete the
                                                     dataspace. This
                                                     is the deafult.
                                        'NODELETE' - Do not delete the
                                                     dataspace.

Example           : /* REXX - EXEC1 */
                    fname.0 = 2
                    fname.1 = 'Fred'
                    fname.2 = 'Barney'
                    sname.0 = 2
                    sname.1 = 'Flinstone'
                    sname.2 = 'Rubble'
                    token = stempush('fname.','sname.')
                    if token <> 0 then call EXEC2 token
                    exit

                    /* REXX - EXEC2 */
                    arg token
                    rcode = STEMPULL(token,'NODELETE')
                    if rcode = 0 then do
                      say fname.1 sname.1
                      say fname.2 sname.2
                    end
                    exit
=STEMPUSH
)F Function -
Name              : STEMPUSH

Function          : This program provides an external REXX function
                    to place REXX stem variables onto a stack that
                    can be passed to another REXX exec running within
                    the same address space.

                    The 'stack' is in fact a dataspace whose STOKEN
                    is passed back in EBCDIC form to the REXX result
                    value. This 'token' can then be used in any
                    other REXX as an argument to the STEMPULL
                    function to retrieve the contents of the
                    dataspace.

Syntax            : token = STEMPUSH(maxblk,'stem1.',,'stemn.')

                    where :   token  -  16 byte token that identifies
                                        the 'stack' that the stems have
                                        been 'pushed' onto. If this
                                        is set to '0', then the
                                        function has failed.

                              maxblk -  Optional keyword that specifies
                                        the size of the 'stack'. The
                                        format is 'MAXBLOCKS=nnnnn'
                                        where 'nnnnn' is the size of
                                        'stack' in 4K blocks.
                                        The minimum value is 10.
                                        The maximum value is 99999.
                                        The default value is 4000.

                              stemn  -  The stem name(s) that are to be
                                        pushed onto the 'stack'. The
                                        variable names MUST be enclosed
                                        in quotes and the last char in
                                        each name MUST be a dot.

Example           : /* REXX - EXEC1 */
                    fname.0 = 2
                    fname.1 = 'Fred'
                    fname.2 = 'Barney'
                    sname.0 = 2
                    sname.1 = 'Fred'
                    sname.2 = 'Barney'
                    token = STEMPUSH('MAXBLOCKS=10','fname.','sname.')
                    if token <> 0 then call EXEC2 token
                    exit

                    /* REXX - EXEC2 */
                    arg token
                    status = stempull(token)
                    if status = 0 then do
                      say fname.1 sname.1
                      say fname.2 sname.2
                    end
                    exit

Possible ABEND Codes :

User Abend 111    - TCBTOKEN Failed
User Abend 112    - ALESERV Failed
User Abend 113    - DSPSERV Failed

=STEMSORT
)F Function -
STEMSORT - Sorting stem variables using REXX

This is the documentation for the REXX function STEMSORT.    The
function should be invoked from within an MVS REXX EXEC.    This
function sorts the content of a stem variable on a single key into
either ascending or descending sequence.

This REXX function accepts four arguments, the fourth being
optional.    The first argument is a stem variable (with the
terminating period) holding the data records to be sorted, with the
total number in stem.0.    The maximum record length is 2 56 bytes;
all records must be the same length.    The stem name may be a maximum
of 32 bytes in length.    The second argument is the key length in
bytes, a maximum of 256 bytes.    The third argument is the start byte
(not the offset/displacement) of the key within the data record.
The fourth argument is the sequence - ascending or descending
(EBCDIC collating); ascending is the default.    The sorted output is
returned in the stem variable.

The syntax of the function is:
    STEMSORT(-stemname,-key_start,-key_length,Ascending)
                                              Descending

In keeping with standard REXX practices, the Ascending/Descending
requires only the first character to be provided, and that character
may be in upper or lower case.

The function returns an integer.    This integer will indicate success
or failure.    An example of the function being invoked:
    RC = STEMSORT(SORTDATA., 1, 10, 'A');

The different values that may be returned are as follows:
    -2     IRXEXCOM - LACK OF STORAGE
    -1     IRXEXCOM - ERROR CONDITION
     0     NORMAL
     8     STEM NAME SPECIFIED > 32 BYTES
    12     NO PERIOD AT END OF STEM NAME
    16     STEM NAME CONTAINS INVALID CHARACTERS
    20     INVALID NUMBER OF ARGUMENTS (MUST BE THREE or FOUR)
    24     VARIABLE LENGTH STEM RECORDS
    28     KEY LENGTH / KEY START > 3 BYTES LONG
    32     KEY LENGTH / KEY START NOT NUMERIC
    36     KEY LENGTH / KEY START EXTEND BEYOND 256 BYTES
    40     SEQUENCE FIELD > 10 BYTES LONG
    44     SEQUENCE VALUE INVALID
    48     NON-EXISTENT STEM
    52     STEM DATA > 256 BYTES

A full example of the function being used:
    "ALLOC F(INPUT) DA(my.input.file) SH REU"
    "EXECIO * DISKR INPUT (STEM SORTDATA. FINIS"
    SAY "Ascending or Descending"
    PARSE PULL SEQ
    SAY "STEMSORT ended with RC:" STEMSORT(SORTDATA., 2, 3, SEQ)
    DO J = 1 TO SORTDATA.0
       SAY STRIP(SORTDATA.J, t, ' ')
    END

This example reads the content of the file assigned to DDname INPUT
into the ste m variable SORTDATA.    The records are then sorted into
either ascending or descen ding sequence.    The key is three bytes
long, starting in the second byte of the record.

=STEMVIEW
)F Function -
MODULE NAME = STEMVIEW

DESCRIPTIVE NAME = Display Stem Variables using BRIF or EDIF.

FUNCTION = This assembler sub-routine can be invoked in a REXX
             EXEC to display the contents of stem variables using
             the ISPF BRIF or EDIF service.  STEMVIEW is a nice
             complement to the REXX OUTTRAP function.

             STEMVIEW can also PULL lines from the data stack.

SYNTAX
     CALL STEMVIEW  service,
                    stemname
                    <,firstelem>
                    <,stemcount>
                    <,title>
                    <,panel>
                    <,lrecl>
                    <,recfm>
                    <,profile>

     Arguments:
          service   This argument must be coded as 'BROWSE' or 'VIEW'.
                    It indicates which of the BRIF or EDIF services
                    will be used for display.

                    If the BROWSE service is requested, the user can
                    enter the E or V commands on the BROWSE screen
                    to switch to VIEW.  This allows the data to
                    be saved using CREATE/REPLACE, CUT or ROUTE.

          stemname  the stem of the family of variables to display.
                    The combined lengths of the stemname argument
                    and the largest subscript (plus the period, if
                    specified) cannot exceed 80 characters.
                    If stemname is a true REXX stem, code a period
                    as the last character.  If you do not specify
                    the period, the subscripts will be concatenated
                    to the stem name without an intervening period.
                    For example, if you specify a stemname of "ABC.",
                    STEMVIEW will look for variables of the form
                    "ABC.1", "ABC.2", etc. If you specify a stemname
                    of "XYZ" (no period), STEMVIEW will look for
                    variables of the form "XYZ1", "XYZ2", etc.

                    If the first argument is coded as "VIEW" and
                    stemname is omitted, STEMVIEW PULLs lines from
                    the stack.

          firstelem the element of the pseudo-array to begin the
                    display on.  The default value is element 1.

          stemcount the number of elements to display.
                    If you do not specify stemcount, STEMVIEW will
                    display variables beginning with firstelem, and
                    continuing until an un-initialized variable is
                    found (i.e., a variable which has its name for
                    a value).

          title     an arbitrary character string which identifies
                    the data which is being displayed.  The maximum
                    length of this string is 54 characters.

          panel     a 1 to 8 character name of the panel member to
                    use for the display. The default panel is
                    ISRBROBF for BROWSE and ISREDDEx for VIEW,
                    where x is 2 for ISPF V3 and 3 for ISPF V4.

          lrecl     the record length that should be passed
                    to EDIF when the VIEW service is requested.
                    The default value is 255.

          recfm     the record format that should be passed to
                    EDIF when the VIEW service is requested.
                    Possible values are F, FA, FM, V, VA, VM, or U.
                    The default value is V.

          profile   the 8-char name of the profile that should be
                    used by EDIF when the VIEW service is requested.
                    The default value is TEXT.

     Examples:
          Call the STEMVIEW routine to display the output of the
          TSO "LISTCAT" command.  The variables to display
          begin with the characters "LINE.":

             CALL OUTTRAP 'LINE.'
             "LISTCAT"
             CALL STEMVIEW 'BROWSE','LINE.',,,'List Catalog'

          QUEUE JCL to the data stack and call the STEMVIEW
          routine to VIEW it:

             "MAKEBUF"
             QUEUE '//MYJOB JOB 12345,CLASS=A'
             QUEUE '//STEP2 EXEC PGM=IEFBR14'
             CALL STEMVIEW 'VIEW',,,,'Sample JCL'
             "DROPBUF"

RETURN-CODES
          The STEMVIEW function returns a return code that indicates
          whether the display worked.  The returned value is
          contained in the RC special variable.

          The following STEMVIEW return code values are possible:

          0    The display was successful.

          4    There were no stems matching the description given
               in stemname.

          12   Invalid Service requested.

          16   BRIF or EDIF failed.

COMPATIBILITY
         STEMVIEW has been designed to be compatible with
         the STEMDISP function of the REXXTOOLS product from
         Open Software Technologies, with the following
         exceptions:

         1. STEMDISP does not support the VIEW service

         2. the length of the fully-qualified variable name
            is limited to 80 characters (STEMDISP allows 255
            characters).

         3. the length of a data line is limited to 255 characters
            (STEMDISP allows 32760 characters).

         4. STEMDISP stops after 100000 variables if stemcount
            is not specified.

         5. STEMDISP does not have the ability to PULL data
            from the stack.
=STORAGE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--STORAGE(address------------------------------)------------------>< |
|                       +-,------------------------+                     |
|                           +-length-+  +-,data-+                        |
|                                                                        |
+------------------------------------------------------------------------+

STORAGE returns length bytes of data from the specified address in
storage.    The address is a character string containing the
hexadecimal representation of the storage address from which data is
retrieved.

Optionally, you can specify length, which is the decimal number of
bytes to be retrieved from address.    The default length is one
byte.    When length is 0, STORAGE returns a null character string.

If you specify data, STORAGE returns the information from address
and then overwrites the storage starting at address with data you
specified on the function call.    The data is the character string to
be stored at address.    The length argument has no effect on how much
storage is overwritten; the entire data is written.

You can use the STORAGE function in REXX execs that run in any MVS
address space (TSO/E and non-TSO/E).

If the STORAGE function tries to retrieve or change data beyond the
storage limit, only the storage up to the limit is retrieved or
changed.

Virtual storage addresses may be fetch protected, update protected,
or may not be defined as valid addresses to the system.    Any
particular invocation of the STORAGE function may fail if it
references a non-existent address, attempts to retrieve the contents
of fetch protected storage, or attempts to update non-existent
storage or is attempting to modify store protected storage.    In all
cases, a null string is returned to the REXX exec.

The STORAGE function returns a null string if any part of the
request fails.    Because the STORAGE function can both retrieve and
update virtual storage at the same time, it is not evident whether
the retrieve or update caused the null string to be returned.    In
addition, a request for retrieving or updating storage of a shorter
length might have been successful.    When part of a request fails,
the failure point is on a decimal 4096 boundary.

Examples:

The following are some examples of using STORAGE:

1.    To retrieve 25 bytes of data from address 000AAE35, use the
      STORAGE function as follows:

        storret = STORAGE(000AAE35,25)

2.    To replace the data at address 0035D41F with 'TSO/E REXX', use
      the following STORAGE function:

        storrep = STORAGE(0035D41F,,'TSO/E REXX')

      This example first returns one byte of information found at
      address 0035D41F and then replaces the data beginning at address
      0035D41F with the characters 'TSO/E REXX'.

      Note:  Information is retrieved before it is replaced.
=STRIP
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--STRIP(string--------------------------------)------------------->< |
|                     +-,------------------------+                       |
|                         +-option-+  +-,char-+                          |
|                                                                        |
+------------------------------------------------------------------------+

Returns string with leading or trailing characters or both removed,
based on the option you specify.    The following are valid options.
(Only the capitalized and highlighted letter is needed; all
characters following it are ignored.)

Both        removes both leading and trailing characters from string.
            This is the default.

Leading     removes leading characters from string.

Trailing    removes trailing characters from string.

The third argument, char, specifies the character to be removed, and
the default is a blank.    If you specify char, it must be exactly one
character long.

Here are some examples:

    STRIP('  ab c  ')        ->    'ab c'
    STRIP('  ab c  ','L')    ->    'ab c  '
    STRIP('  ab c  ','t')    ->    '  ab c'
    STRIP('12.7000',,0)      ->    '12.7'
    STRIP('0012.700',,0)     ->    '12.7'
=SUBCOM
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SUBCOMenvname--------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Queries the existence of a specified host command environment.
SUBCOM searches the host command environment table for the named
environment and sets the REXX special variable RC to 0 or 1.    When
RC contains 0, the environment exists.    When RC contains 1, the
environment does not exist.

You can use the SUBCOM command in REXX execs that run in both the
TSO/E address space and non-TSO/E address spaces.

Before an exec runs, a default host command environment is defined
to process the commands that the exec issues.    You can use the
ADDRESS keyword instruction (see item ADDRESS ) to change the
environment to another environment as long as the environment is
defined in the host command environment table.    Use the SUBCOM
command to determine whether the environment is defined in the host
command environment table for the current language processor
environment.    You can use the ADDRESS built-in function to determine
the name of the environment to which host commands are currently
being submitted (see item ADDRESS ).

Operand: The one operand for the SUBCOM command is:

envname
      the name of the host command environment for which SUBCOM is to
      search.

When you invoke an exec from TSO/E, the following default host
command environments are available:

o     TSO (the default environment)
o     CONSOLE
o     CPICOMM
o     LU62
o     MVS
o     LINK
o     ATTACH
o     LINKPGM
o     ATTCHPGM
o     LINKMVS
o     ATTCHMVS

When you run an exec in a non-TSO/E address space, the following
default host command environments are available:

o     MVS (the default environment)
o     CPICOMM
o     LU62
o     LINK
o     ATTACH
o     LINKPGM
o     ATTCHPGM
o     LINKMVS
o     ATTCHMVS

When you invoke an exec from ISPF, the following default host
command environments are available:

o     TSO (the default environment)
o     CONSOLE
o     ISPEXEC
o     ISREDIT
o     CPICOMM
o     LU62
o     MVS
o     LINK
o     ATTACH
o     LINKPGM
o     ATTCHPGM
o     LINKMVS
o     ATTCHMVS

The SUBCOM command sets the REXX special variable RC to indicate the
existence of the specified environment.

+--------------------------------------------------------------------------+
| RC Value           | Description                                         |
+------------------+-------------------------------------------------------|
| 0                  | The host command environment exists.                |
+------------------+-------------------------------------------------------|
| 1                  | The host command environment does not exist.        |
+--------------------------------------------------------------------------+

Example

To check whether the ISPEXEC environment is available before using
the ADDRESS instruction to change the environment, use the SUBCOM
command as follows:

    "SUBCOM ispexec"
    IF RC = 0 THEN
      ADDRESS ispexec
    ELSE NOP
=SUBSTR (Substring)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SUBSTR(string,n-------------------------------)----------------->< |
|                        +-,-----------------------+                     |
|                            +-length-+  +-,pad-+                        |
|                                                                        |
+------------------------------------------------------------------------+

Returns the substring of string that begins at the nth character and
is of length length, padded with pad if necessary.    The n must be a
positive whole number.    If n is greater than LENGTH(string), then
only pad characters are returned.

If you omit length, the rest of the string is returned.    The default
pad character is a blank.

Here are some examples:

    SUBSTR('abc',2)          ->    'bc'
    SUBSTR('abc',2,4)        ->    'bc  '
    SUBSTR('abc',2,6,'.')    ->    'bc....'

Note:    In some situations the positional (numeric) patterns of
         parsing templates are more convenient for selecting
         substrings, especially if more than one substring is to be
         extracted from a string.  See also the LEFT and RIGHT
         functions.
=SUBWORD
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SUBWORD(string,n---------------)-------------------------------->< |
|                         +-,length-+                                    |
|                                                                        |
+------------------------------------------------------------------------+

Returns the substring of string that starts at the nth word, and is
up to length blank-delimited words.    The n must be a positive whole
number.    If you omit length, it defaults to the number of remaining
words in string.    The returned string never has leading or trailing
blanks, but includes all blanks between the selected words.

Here are some examples:

    SUBWORD('Now is the  time',2,2)    ->    'is the'
    SUBWORD('Now is the  time',3)      ->    'the  time'
    SUBWORD('Now is the  time',5)      ->    ''
=SYMBOL
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SYMBOL(name)---------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the state of the symbol named by name.    Returns BAD if name
is not a valid REXX symbol.    Returns VAR if it is the name of a
variable (that is, a symbol that has been assigned a value).
Otherwise returns LIT, indicating that it is either a constant
symbol or a symbol that has not yet been assigned a value (that is,
a literal).

As with symbols in REXX expressions, lowercase characters in name
are translated to uppercase and substitution in a compound name
occurs if possible.

You should specify name as a literal string (or it should be derived
from an expression) to prevent substitution before it is passed to
the function.

Here are some examples:

    /* following: Drop A.3;  J=3 */
    SYMBOL('J')      ->   'VAR'
    SYMBOL(J)        ->   'LIT' /* has tested "3"     */
    SYMBOL('a.j')    ->   'LIT' /* has tested A.3     */
    SYMBOL(2)        ->   'LIT' /* a constant symbol  */
    SYMBOL('*')      ->   'BAD' /* not a valid symbol */
=SYSCPUS
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SYSCPUS(cpus_stem)---------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

SYSCPUS places, in a stem variable, information about those CPUs
that are online.

The number of online CPUs is returned in variable cpus_stem.0.    The
serial numbers of each of those CPUs are returned in variables whose
names are derived by appending a number (1 through cpus_stem.0) to
the stem.    Trailing blanks are removed.  The serial number is
obtained from the field PCCACPID in the MVS control block IHAPCCA.
On a z990 machine or later, all CPU numbers are identical;
therefore, SYSCPUS returns the same value for all CPUs.

The SYSCPUS function runs in any MVS address space.

Function Codes

The SYSCPUS function replaces the function call by the following
function codes.

+------------------------------------------------------------------------+
| Table B.    SYSCPUS Function Codes                                     |
+------------------------------------------------------------------------|
| Function      | Description                                            |
| Code          |                                                        |
+-------------+----------------------------------------------------------|
| 0             | SYSCPUS processing was successful.                     |
+-------------+----------------------------------------------------------|
| 4             | SYSCPUs processing was successful.  However, the       |
|               | function detected some inconsistency during            |
|               | processing, for example when the number of online      |
|               | CPUs varies or becomes zero during processing.  This   |
|               | can happen when the operator changes an online CPU     |
|               | to offline while the function is in process.  In       |
|               | this case, it may be advisable to repeat the           |
|               | function call.                                         |
+------------------------------------------------------------------------+

Example:

Consider a system with two online CPUs.    Their serial numbers are
FF0000149221 and FF1000149221.    Assuming you issue the following
sequence of statements

    /* REXX */
    x = SYSCPUS('CPUS.')
    say '0, if function performed okay: ' x
    say 'Number of on-line CPUs is ' CPUS.0
    do i = 1 to CPUS.0
      say 'CPU' i ' has CPU info ' CPUS.i
    end

you get the following output:

    0, if function performed okay: 0
    Number of on-line CPUs is 2
    CPU 1 has CPU info FF0000149221
    CPU 2 has CPU info FF1000149221
                      /* |     |                         */
                      /* |     4 digits = model number   */
                      /* 6 digits       = CPU ID         */
=SYSDSN
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SYSDSN(dsname)-------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

SYSDSN returns one of the following messages indicating whether the
specified dsname exists and is available for use.    The dsname can be
the name of any cataloged data set or cataloged partitioned data set
with a member name.    Additionally, if you specify a member of a
partitioned data set, SYSDSN checks to see if you have access to the
data set.

You can use SYSDSN to obtain information about a data set that is
available on DASD.    SYSDSN does not directly support data that is on
tape.    SYSDSN supports generation data group (GDG) data sets when
using absolute generation names, but does not support relative GDG
names.

To suppress TSO/E messages issued by the SYSDSN function, use the
MSG("OFF") function.    For information about the MSG function, see
item MSG.

    OK                          /* data set or member is available */
    MEMBER NOT FOUND
    MEMBER SPECIFIED, BUT DATASET IS NOT PARTITIONED
    DATASET NOT FOUND
    ERROR PROCESSING REQUESTED DATASET
    PROTECTED DATASET           /* a member was specified and RACF
                                   prevents this user from accessing
                                   this data set */
    VOLUME NOT ON SYSTEM
    INVALID DATASET NAME, dsname
    MISSING DATASET NAME
    UNAVAILABLE DATASET         /* another user has an exclusive ENQ
                                   on the specified data set */

After a data set is available for use, you may find it useful to get
more detailed information.    For example, if you later need to invoke
a service that requires a specific data set organization, then use
the LISTDSI function.    For a description of the LISTDSI function,
see "LISTDSI"    in item LISTDSI.

You can use the SYSDSN function only in REXX execs that run in the
TSO/E address space.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use SYSDSN only in environments that are             |
| integrated into TSO/E.                                                 |
|                                                                        |
+------------------------------------------------------------------------+

You can specify the dsname in any of the following ways:

o     Fully-qualified data set name -- The extra quotation marks
      prevent TSO/E from adding your prefix to the data set name.

        x = SYSDSN("'sys1.proj.new'")
        x = SYSDSN('''sys1.proj.new''')

o     Non fully-qualified data set name that follows the naming
      conventions -- When there is only one set of quotation marks or
      no quotation marks, TSO/E adds your prefix to the data set
      name.

        x = SYSDSN('myrexx.exec')
        x = SYSDSN(myrexx.exec)

o     Variable name that represents a fully-qualified or non
      fully-qualified data set name -- The variable name must not be
      enclosed in quotation marks because quotation marks prevent
      variable substitution.

        variable = "exec"
        x = SYSDSN(variable)       /* looks for 'userid.exec'      */
        y = SYSDSN('variable')     /* looks for 'userid.variable'  */
        z = SYSDSN("'"variable"'") /* looks for 'exec'             */

If the specified data set has been migrated, SYSDSN attempts to
recall it.

Examples:

The following are some examples of using SYSDSN.

1.    To determine the availability of prefix.PROJ.EXEC(MEM1):

        x = SYSDSN("proj.exec(mem1)")
        IF x = 'OK' THEN
          CALL routine1
        ELSE
          CALL routine2

2.    To determine the availability of DEPT.REXX.EXEC:

        s = SYSDSN("'dept.rexx.exec'")
        say s

3.    To suppress TSO/E messages:

        /*  REXX  */
        dsname = 'abcdefghij'
        y = MSG("OFF")
        x = SYSDSN(dsname)
        y = MSG(y)
=SYSVAR
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--SYSVAR(arg_name)------------------------------------------------>< |
|                                                                        |
+------------------------------------------------------------------------+

SYSVAR returns information about MVS, TSO/E, and the current
session, such as levels of software available, your logon procedure,
and your user ID.    The information returned depends on the arg_name
value specified on the function call.    The arg_name values are
divided into the following categories of information:    user,
terminal, exec, system, language, and console session information.
The different categories are described below.

For information about system variables not being listed below, see
"MVSVAR"    in item MVSVAR.

User Information

Use the following arguments to obtain information related to the user.

SYSPREF     the prefix as defined in the user profile.  The prefix is
            the string that is prefix to data set names that are not
            fully-qualified.  The prefix is usually the user's user
            ID.  You can use the TSO/E PROFILE command to change the
            prefix.

SYSPROC     the name of the logon procedure for the current session.
            You can use the SYSPROC argument to determine whether
            certain programs, such as the TSO/E Session Manager, are
            available to the user.  For example, suppose your
            installation has the logon procedure SMPROC for the
            Session Manager.  The exec can check that the user logged
            on using SMPROC before invoking a routine that uses
            Session Manager.  Otherwise, the exec can display a
            message telling the user to log on using the SMPROC logon
            procedure.

            SYSPROC returns the following values:

            o   When the REXX exec is invoked in the foreground
                (SYSVAR('SYSENV') returns 'FORE'), SYSVAR('SYSPROC')
                will return the name of the current LOGON procedure.

            o   When the REXX exec is invoked in batch (for example,
                from a job submitted by using the SUBMIT command),
                SYSVAR('SYSPROC') will return the value 'INIT', which
                is the ID for the initiator.

            o   When the REXX exec is invoked from a Started Task (for
                example, an address space that is started by using the
                Start operator command), SYSVAR('SYSPROC') will return
                the ID of the started task.  If 'S procname' is issued
                from the operator console, the SYSVAR('SYSPROC')
                function will return the value 'procname'.

SYSUID      the user ID under which the current TSO/E session is
            logged on.  The SYSUID argument returns the same value
            that the USERID built-in function returns in a TSO/E
            address space.

Terminal Information

Use the following arguments to obtain information related to the
terminal.

SYSLTERM    number of lines available on the terminal screen. In the
            background, SYSLTERM returns 0.

SYSWTERM    width of the terminal screen. In the background, SYSWTERM
            returns 132.

Exec Information

Use the following arguments to obtain information related to the exec.

SYSENV      indicates whether the exec is running in the foreground or
            background.  SYSENV returns the following values:

            o   FORE - exec is running in the foreground
            o   BACK - exec is running in the background

            You can use the SYSENV argument to make logical decisions
            based on foreground or background processing.

SYSICMD     the name by which the user implicitly invoked the exec
            that is currently processing.  If the user invoked the
            exec explicitly, SYSICMD returns a null value.

SYSISPF     indicates whether ISPF dialog manager services are
            available for the exec.  SYSISPF returns the following
            values:

            o   ACTIVE - ISPF services are available.  If the exec was
                invoked under ISPF by using the TSOEXEC interface, no
                ISPF services are available.

            o   NOT ACTIVE - ISPF services are not available

SYSNEST     indicates whether the exec was invoked from another
            program, such as an exec or CLIST.  The invocation could
            be either implicit or explicit.  SYSNEST returns YES if
            the exec was invoked from another program; otherwise, it
            returns NO.

SYSPCMD     the name or abbreviation of the TSO/E command processor
            that the exec most recently processed.

            The initial value that SYSPCMD returns depends on how you
            invoked the exec.  If you invoked the exec using the TSO/E
            EXEC command, the initial value returned is EXEC.  If you
            invoked the exec using the EXEC subcommand of the TSO/E
            EDIT command, the initial value returned is EDIT.

            You can use the SYSPCMD argument with the SYSSCMD argument
            for error and attention processing to determine where an
            error or attention interrupt occurred.

SYSSCMD     the name or abbreviation of the TSO/E subcommand processor
            that the exec most recently processed.

            The initial value that SYSSCMD returns depends on how you
            invoked the exec.  If you invoked the exec using the TSO/E
            EXEC command, the initial value returned is null.  If you
            invoked the exec using the EXEC subcommand of the TSO/E
            EDIT command, the initial value returned is EXEC.

            The SYSPCMD and SYSSCMD arguments are interdependent.
            After the initial invocation, the values that SYSPCMD and
            SYSSCMD return depend on the TSO/E command and subcommand
            processors that were most recently processed.  For
            example, if SYSSCMD returns the value EQUATE, which is a
            subcommand unique to the TEST command, the value that
            SYSPCMD returns would be TEST.

            You can use the SYSPCMD and SYSSCMD arguments for error
            and attention processing to determine where an error or
            attention interrupt occurred.

System Information

Use the following arguments to obtain information related to the
system.

SYSCPU      the number of seconds of central processing unit (CPU)
            time used during the session in the form:
            seconds.hundredths-of-seconds.

            You can use the SYSCPU argument and the SYSSRV argument,
            which returns the number of system resource manager (SRM)
            service units, to evaluate the:

            o   Performance of applications
            o   Duration of a session.

SYSHSM      indicates the level of the Data Facility Storage
            Management Subsystem Hierarchical Storage Manager
            (DFSMShsm).  SYSHSM returns the following values:

            o   A character string of four two-digit decimal numbers
                separated by periods if DFSMShsm for OS/390 V2R10 or
                higher is active with PTF UW77424 applied.  This
                represents the four-byte level in the MQCT_VRM field
                of the ARCQCT.  For example, if DFSMShsm for OS/390
                V2R10 is active with PTF UW77424 applied, SYSHSM
                returns:  02.02.10.00

                Note:  For a description of the MQCT_VRM field in the
                       ARCQCT control block, see OS/390 V2R10.

            o   A character string of four decimal digits if DFSMShsm
                before OS/390 V2R10 is installed and active.  This
                represents the level of DFSMShsm.  For example, if
                DFSMShsm 1.5.0 is installed and active, SYSHSM
                returns:  1050

            o   A null string if the Hierarchical Storage Manager is
                not active.

SYSJES      name and level of the JES installed on your system:

            o   A character string indicating name of the JES plus its
                version, release and modification level, for example

                  JES2 OS 2.10

                where JES2 is the JES name and OS 2.10 is the JES
                level.  These two strings are separated by a blank
                character.  If either the JES name or the level
                returns an empty character string, then no blank
                character is inserted.  Trailing blanks are removed.

            o   -INACTIVE- (please note the delimiters) if the
                subsystem is not active.

            o   -DOWNLEVEL- (please note the delimiters) if the
                subsystem is neither JES2 SP4.3 or later, nor JES3
                SP5.1.1 or later.

SYSLRACF    indicates the level of RACF installed on the system.  If
            RACF is not installed, SYSLRACF contains a null value.

SYSNODE     network node name of your installation's JES.  This name
            identifies the local JES in a network of systems or system
            complexes being used for network job entry (NJE) tasks.
            The name that is returned derives from the NODE
            initialization statement of JES.

            The SYSNODE value is returned as either of the following:

            o   A character string indicating the node name, for
                example BOE9.

            o   -INACTIVE- (please note the delimiters) if the
                subsystem is not active.

            o   -DOWNLEVEL- (please note the delimiters) if the
                subsystem is neither JES2 SP4.3 or later, nor JES3
                SP5.1.1 or later.

SYSRACF     indicates the status of RACF. SYSRACF returns the following
            values:

            o   AVAILABLE if RACF is installed and available

            o   NOT AVAILABLE if RACF is installed but is not available

            o   NOT INSTALLED if RACF is not installed.

SYSSRV      the number of system resource manager (SRM) service units
            used during the session.

            You can use the SYSSRV argument and the SYSCPU argument,
            which returns the number of seconds of CPU time used, to
            evaluate the:

            o   Performance of applications
            o   Duration of a session.

SYSTERMID the terminal ID of the terminal where the REXX exec was
            started.

            o   A character string indicating the terminal ID. Trailing
                blanks are removed.

            o   A null string if TSO runs in the background.

SYSTSOE     the level of TSO/E installed on the system.  For OS/390
            Version 2, Release 4 and later, SYSTSOE returns 2060.

Language Information

Use the following arguments to obtain information related to the
display of information in different languages.

SYSDTERM    indicates whether the user's terminal supports Double-Byte
            Character Set (DBCS).  SYSDTERM returns the following
            values:

            o   YES - Terminal supports DBCS
            o   NO - Terminal does not support DBCS

            The SYSDTERM argument is useful if you want to display
            messages or other information to the user and the
            information contains DBCS characters.

SYSKTERM    indicates whether the user's terminal supports Katakana.
            SYSKTERM returns the following values:

            o   YES - Terminal supports Katakana
            o   NO - Terminal does not support Katakana

            The SYSKTERM argument is useful if you want to display
            messages or other information to the user and the
            information contains Katakana characters.

SYSPLANG    a three character code that indicates the user's primary
            language stored in the user profile table (UPT).  For more
            information, see "Using the SYSPLANG and SYSSLANG
            Arguments".

SYSSLANG    a three character code that indicates the user's secondary
            language stored in the user profile table (UPT).  For more
            information, see "Using the SYSPLANG and SYSSLANG
            Arguments".

Using the SYSPLANG and SYSSLANG Arguments:    Your installation can
customize TSO/E to display certain types of information at the
terminal in different languages.    Your installation can define a
primary and secondary language for the display of information.    The
language codes for the primary and secondary language are stored in
the user profile table (UPT).    You can use the TSO/E PROFILE command
to change the languages specified in the UPT.

The SYSPLANG and SYSSLANG arguments return the three character
language codes for the user's primary and secondary language that
are stored in the UPT.    The arguments are useful if you want to
display messages or other information to the user in the primary or
secondary language.    The language codes that SYSVAR returns depend
on the language support and codes that your installation has
defined.    z/OS TSO/E Customization describes how to customize TSO/E
for different languages, the types of information that are displayed
in different languages, and language codes.

TSO/E also provides the SETLANG external function that lets you
determine and set the language in which REXX messages are
displayed.    SETLANG has no effect on the languages that are stored
in the UPT.    However, you can use both SETLANG and SYSVAR together
for language processing.    For example, you can use the SYSVAR
function with the SYSPLANG or SYSSLANG argument to determine the
language code stored in the UPT.    You can then use the SETLANG
function to set the language in which REXX messages are displayed to
the same language as the user's primary or secondary language.    See
"SETLANG"    in item SETLANG for more information.

Console Session Information

The console session arguments let you obtain information related to
running an extended MCS console session that you have established
using the TSO/E CONSOLE command.

The SOLDISP, UNSDISP, SOLNUM, and UNSNUM arguments provide
information about the options that have been specified for a console
session.    The arguments relate to keywords on the TSO/E CONSPROF
command.    You can use the arguments to determine what options are in
effect before you issue MVS system or subsystem commands or use the
GETMSG function to retrieve a message.

The MFTIME, MFOSNM, MFJOB, and MFSNMJBX arguments provide
information about messages that are issued during a console
session.    These arguments are useful if you use the GETMSG external
function to retrieve messages that are not displayed at the terminal
and you want to display a particular message that was retrieved.
The arguments indicate whether certain types of information should
be displayed with the message, such as the time stamp.

For information about console sessions, see "Writing REXX
Execs to Perform MVS Operator Activities" in item -MVS-OPS.

SOLDISP     indicates whether solicited messages that are routed to a
            user's console during a console session are to be
            displayed at the user's terminal.  Solicited messages are
            responses from MVS system and subsystem commands that are
            issued during a console session.  SOLDISP returns the
            following values:

            o   YES - solicited messages are displayed
            o   NO - solicited messages are not displayed

UNSDISP     indicates whether unsolicited messages that are routed to
            a user's console during a console session are to be
            displayed at the user's terminal.  Unsolicited messages
            are messages that are not direct responses from MVS system
            and subsystem commands that are issued during a console
            session.  UNSDISP returns the following values:

            o   YES - unsolicited messages are displayed
            o   NO - unsolicited messages are not displayed

SOLNUM      the size of the message table that contains solicited
            messages (that is, the number of solicited messages that
            can be stored).  The system stores the messages in the
            table during a console session if you specify that
            solicited messages are not to be displayed at the
            terminal.  You can use the TSO/E CONSPROF command to
            change the size of the table.  For more information, see
            z/OS TSO/E System Programming Command Reference.

UNSNUM      the size of the message table that contains unsolicited
            messages (that is, the number of unsolicited messages that
            can be stored).  The system stores the messages in the
            table during a console session if you specify that
            unsolicited messages are not to be displayed at the
            terminal.  You can use the TSO/E CONSPROF command to
            change the size of the table.  For more information, see
            z/OS TSO/E System Programming Command Reference.

MFTIME      indicates whether the user requested that the time stamp
            should be displayed with system messages.  MFTIME returns
            the following values:

            o   YES - time stamp should be displayed
            o   NO - time stamp should not be displayed

MFOSNM      indicates whether the user requested that the originating
            system name should be displayed with system messages.
            MFOSNM returns the following values:

            o   YES - originating system name should be displayed
            o   NO - originating system name should not be displayed

MFJOB       indicates whether the user requested that the originating
            job name or job ID of the issuer should be displayed with
            system messages.  MFJOB returns the following values:

            o   YES - originating job name should be displayed
            o   NO - originating job name should not be displayed

MFSNMJBX    indicates whether the user requested that the originating
            system name and job name should not be displayed with
            system messages.  MFSNMJBX returns the following values:

            o   YES - originating system name and job name should not
                be displayed
            o   NO - originating system name and job name should be
                displayed

            MFSNMJBX is intended to override the values of MFOSNM and
            MFJOB.  The value for MFSNMJBX may not be consistent with
            the values for MFOSNM and MFJOB.

You can use the SYSVAR function only in REXX execs that run in the
TSO/E address space.    Use SYSVAR to determine various
characteristics to perform different processing within the exec.

+--- Environment Customization Considerations ---------------------------+
|                                                                        |
| If you use IRXINIT to initialize language processor environments,      |
| note that you can use SYSVAR only in environments that are             |
| integrated into TSO/E.                                                 |
|                                                                        |
+------------------------------------------------------------------------+

Examples:

The following are some examples of using SYSVAR.

1.    To display whether the exec is running in the foreground or
      background:

        SAY SYSVAR("sysenv")         /* Displays FORE or BACK */

2.    To find out the level of RACF installed:

        level = SYSVAR("syslracf")   /* Returns RACF level */

3.    To determine if the prefix is the same as the user ID:

        IF SYSVAR("syspref") = SYSVAR("sysuid") THEN
          .
          .
          .
        ELSE
          .
          .
          .
        EXIT

4.    Suppose you want to use the GETMSG external function to retrieve
      a solicited message.  Before using GETMSG, you want to save the
      current setting of message displaying and use the TSO/E CONSPROF
      command so that solicited messages are not displayed.  After
      GETMSG processing, you want to restore the previous setting of
      message displaying.

        /*  REXX program ...   */
          .
          .
          .
        mdisp = SYSVAR("SOLDISP")   /* Save current message settin   */
        "CONSPROF SOLDISPLAY(NO)"   /* Inhibit message display       */
          .
          .
          .
        msg = GETMSG('cons','sol','APP0096',,60) /* Retrieve message */
          .
          .
          .
        "CONSPROF SOLDISPLAY("mdisp")" /* Restore message setting    */
          .
          .
          .
        EXIT

Relationship of CLIST Control Variables and SYSVAR Function

The information that the SYSVAR external function returns is similar
to the information stored in CLIST control variables for TSO/E
CLISTs.    The SYSVAR external function does not support all the CLIST
control variables.    SYSVAR supports only the arg_name values
described in this item.

Some CLIST control variables do not apply to REXX.    Other CLIST
control variables duplicate other REXX functions.    SYSVAR does not
support the following CLIST control variables.    However, for these
CLIST control variables, there is an equivalent function in REXX,
which is listed below.

    SYSDATE   ===>  DATE(usa)
    SYSJDATE  ===>  DATE(julian)
    SYSSDATE  ===>  DATE(ordered)
    SYSSTIME  ===>  SUBSTR(TIME(normal),1,5)
    SYSTIME   ===>  TIME(normal) or TIME()
=TE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--TE-------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

TE (Trace End) is an immediate command you can use to end tracing
REXX execs.    The TE immediate command is available if an exec is
running in TSO/E and you press the attention interrupt key to enter
attention mode.    You can enter TE in response to the REXX attention
prompting message, IRX0920I.    The exec continues processing, but
tracing is off.

TE is also a TSO/E REXX command you can use in a REXX exec that runs
in any address space.    That is, TE is available from the TSO and MVS
host command environments.

If you are running in interactive debug, you can also use TE without
entering attention mode to end tracing.

Example

You have an exec that calls an internal subroutine.    The subroutine
is not processing correctly and you want to trace it.    At the
beginning of the subroutine, you can insert a TS command to start
tracing.    At the end of the subroutine, before the RETURN
instruction, insert the TE command to end tracing before control
returns to the main exec.
=TIME
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--TIME(----------------)------------------------------------------>< |
|               +-option-+                                               |
|                                                                        |
+------------------------------------------------------------------------+

Returns the local time in the 24-hour clock format: hh:mm:ss (hours,
minutes, and seconds) by default, for example, 04:41:37.

You can use the following options to obtain alternative formats, or
to gain access to the elapsed-time clock.    (Only the capitalized and
highlighted letter is needed; all characters following it are
ignored.)

Civil       returns the time in Civil format:  hh:mmxx.  The hours may
            take the values 1 through 12, and the minutes the values
            00 through 59.  The minutes are followed immediately by
            the letters am or pm.  This distinguishes times in the
            morning (12 midnight through 11:59 a.m.--appearing as
            12:00am through 11:59am) from noon and afternoon (12 noon
            through 11:59 p.m.--appearing as 12:00pm through
            11:59pm).  The hour has no leading zero.  The minute field
            shows the current minute (rather than the nearest minute)
            for consistency with other TIME results.

Elapsed     returns sssssssss.uuuuuu, the number of
            seconds.microseconds since the elapsed-time clock
            (described later) was started or reset.  The number has no
            leading zeros or blanks, and the setting of NUMERIC DIGITS
            does not affect the number.  The fractional part always
            has six digits.

Hours       returns up to two characters giving the number of hours
            since midnight in the format:  hh (no leading zeros or
            blanks, except for a result of 0).

Long        returns time in the format:  hh:mm:ss.uuuuuu (uuuuuu is
            the fraction of seconds, in microseconds).  The first
            eight characters of the result follow the same rules as
            for the Normal form, and the fractional part is always six
            digits.

Minutes     returns up to four characters giving the number of minutes
            since midnight in the format:  mmmm (no leading zeros or
            blanks, except for a result of 0).

Normal      returns the time in the default format hh:mm:ss, as
            described previously.  The hours can have the values 00
            through 23, and minutes and seconds, 00 through 59.  All
            these are always two digits.  Any fractions of seconds are
            ignored (times are never rounded up).  This is the
            default.

Reset       returns sssssssss.uuuuuu, the number of
            seconds.microseconds since the elapsed-time clock
            (described later) was started or reset and also resets the
            elapsed-time clock to zero.  The number has no leading
            zeros or blanks, and the setting of NUMERIC DIGITS does
            not affect the number.  The fractional part always has six
            digits.

Seconds     returns up to five characters giving the number of seconds
            since midnight in the format:  sssss (no leading zeros or
            blanks, except for a result of 0).

Here are some examples, assuming that the time is 4:54 p.m.:

    TIME()       ->   '16:54:22'
    TIME('C')    ->   '4:54pm'
    TIME('H')    ->   '16'
    TIME('L')    ->   '16:54:22.123456'   /* Perhaps */
    TIME('M')    ->   '1014'           /* 54 + 60*16 */
    TIME('N')    ->   '16:54:22'
    TIME('S')    ->   '60862'  /* 22 + 60*(54+60*16) */

The elapsed-time clock:    You can use the TIME function to measure
real (elapsed) time intervals.    On the first call in a program to
TIME('E') or TIME('R'), the elapsed-time clock is started, and
either call returns 0.    From then on, calls to TIME('E') and to
TIME('R') return the elapsed time since that first call or since the
last call to TIME(ÛRÛ).

The clock is saved across internal routine calls, which is to say
that an internal routine inherits the time clock its caller
started.    Any timing the caller is doing is not affected, even if an
internal routine resets the clock.    An example of the elapsed-time
clock:

    time('E')    ->    0          /* The first call */
    /* pause of one second here */
    time('E')    ->    1.002345   /* or thereabouts */
    /* pause of one second here */
    time('R')    ->    2.004690   /* or thereabouts */
    /* pause of one second here */
    time('R')    ->    1.002345   /* or thereabouts */
Restriction:    See the note under DATE about consistency of times
within a single clause.    The elapsed-time clock is synchronized to
the other calls to TIME and DATE, so multiple calls to the
elapsed-time clock in a single clause always return the same
result.    For the same reason, the interval between two usual
TIME/DATE results may be calculated exactly using the elapsed-time
clock.

Implementation maximum:    If the number of seconds in the elapsed
time exceeds nine digits (equivalent to over 31.6 years), an error
results.
=TRACE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--TRACE----------------------------------------;------------------>< |
|              |  +-number-+                      |                      |
|              |               +-Normal--------+  |                      |
|              +---------------+---------------+--+                      |
|                 | <-----+ |  +-All-----------|                         |
|                 +----?----+  +-Commands------|                         |
|                    +-!-+     +-Error---------|                         |
|                              +-Failure-------|                         |
|                              +-Intermediates-|                         |
|                              +-Labels--------|                         |
|                              +-Off-----------|                         |
|                              +-Results-------|                         |
|                              +-Scan----------+                         |
|                                                                        |
+------------------------------------------------------------------------+

Or, alternatively:

+------------------------------------------------------------------------+
|                                                                        |
| >>--TRACE-----------------------------;----------------------------->< |
|              +-string----------------|                                 |
|              +-symbol----------------|                                 |
|              +------------expression-+                                 |
|                 +-VALUE-+                                              |
|                                                                        |
+------------------------------------------------------------------------+

TRACE controls the tracing action (that is, how much is displayed to
the user) during processing of a REXX program.    (Tracing describes
some or all of the clauses in a program, producing descriptions of
clauses as they are processed.) TRACE is mainly used for debugging.
Its syntax is more concise than that of other REXX instructions
because TRACE is usually entered manually during interactive
debugging.    (This is a form of tracing in which the user can
interact with the language processor while the program is running.)
For this use, economy of key strokes is especially convenient.

If specified, the number must be a whole number.

The string or expression evaluates to:

o     A numeric option
o     One of the valid prefix or alphabetic character (word) options
      described later
o     Null

The symbol is taken as a constant, and is, therefore:

o     A numeric option
o     One of the valid prefix or alphabetic character (word) options
      described later

The option that follows TRACE or the result of evaluating expression
determines the tracing action.    You can omit the subkeyword VALUE if
expression does not begin with a symbol or a literal string (that
is, if it starts with a special character, such as an operator or
parenthesis).

TRACE

+------------------------------------------------------------------------+
|                                                                        |
| >>--TRACE(----------------)----------------------------------------->< |
|                +-option-+                                              |
|                                                                        |
+------------------------------------------------------------------------+

returns trace actions currently in effect and, optionally, alters
the setting.

If you specify option, it selects the trace setting.    It must be one
of the valid prefixes ?    or !  or one of the alphabetic character
options associated with the TRACE instruction (that is, starting
with A, C, E, F, I, L, N, O, R, or S) or both.    (See the TRACE
instruction on item -TRACE-WORD- for full details.)

Unlike the TRACE instruction, the TRACE function alters the trace
action even if interactive debug is active.    Also unlike the TRACE
instruction, option cannot be a number.

Here are some examples:

    TRACE()       ->   '?R' /* maybe */
    TRACE('O')    ->   '?R' /* also sets tracing off    */
    TRACE('?I')   ->   'O'  /* now in interactive debug */
=TRANSLATE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--TRANSLATE(string-------------------------------------------------> |
|                                                                        |
| >--------------------------------------------------)---------------->< |
|      +-,------------------------------------------+                    |
|          +-tableo-+  +-,-----------------------+                       |
|                          +-tablei-+  +-,pad-+                          |
|                                                                        |
+------------------------------------------------------------------------+

Returns string with each character translated to another character
or unchanged.    You can also use this function to reorder the
characters in string.

The output table is tableo and the input translation table is
tablei.    TRANSLATE searches tablei for each character in string.  If
the character is found, then the corresponding character in tableo
is used in the result string; if there are duplicates in tablei, the
first (leftmost) occurrence is used.    If the character is not found,
the original character in string is used.    The result string is
always the same length as string.

The tables can be of any length.    If you specify neither translation
table and omit pad, string is simply translated to uppercase (that
is, lowercase a-z to uppercase A-Z), but, if you include pad, the
language processor translates the entire string to pad characters.
tablei defaults to XRANGE('00'x,'FF'x), and tableo defaults to the
null string and is padded with pad or truncated as necessary.    The
default pad is a blank.

Here are some examples:

    TRANSLATE('abcdef')                    ->    'ABCDEF'
    TRANSLATE('abbc','&','b')              ->    'a&&c'
    TRANSLATE('abcdef','12','ec')          ->    'ab2d1f'
    TRANSLATE('abcdef','12','abcd','.')    ->    '12..ef'
    TRANSLATE('APQRV',,'PR')               ->    'A Q V'
    TRANSLATE('APQRV',XRANGE('00'X,'Q'))   ->    'APQ  '
    TRANSLATE('4123','abcd','1234')        ->    'dabc'

The last example shows how to use the TRANSLATE function to reorder
the characters in a string.    In the example, the last character of
any four-character string specified as the second argument would be
moved to the beginning of the string.
=TRUNC (Truncate)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--TRUNC(number----------)----------------------------------------->< |
|                     +-,n-+                                             |
|                                                                        |
+------------------------------------------------------------------------+

Returns the integer part of number and n decimal places.    The
default n is 0 and returns an integer with no decimal point.    If you
specify n, it must be a positive whole number or zero.    The number
is first rounded according to standard REXX rules, just as though
the operation number+0 had been carried out.    The number is then
truncated to n decimal places (or trailing zeros are added if needed
to make up the specified length).    The result is never in
exponential form.

Here are some examples:

    TRUNC(12.3)           ->    12
    TRUNC(127.09782,3)    ->    127.097
    TRUNC(127.1,3)        ->    127.100
    TRUNC(127,2)          ->    127.00

The number is rounded according to the current setting of NUMERIC
DIGITS if necessary before the function processes it.
=TS
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--TS-------------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

TS (Trace Start) is an immediate command you can use to start
tracing REXX execs.    Tracing lets you control the execution of an
exec and debug problems.    The TS immediate command is available if
an exec is running in TSO/E and you press the attention interrupt
key to enter attention mode.    You can enter TS in response to the
REXX attention prompting message, IRX0920I.    The exec continues
processing and tracing is started.

TS is also a TSO/E REXX command you can use in a REXX exec that runs
in any address space.    That is, TS is available from the TSO and MVS
host command environments.

In TSO/E foreground, trace output is written to the terminal.    In
TSO/E background, trace output is written to the output stream,
SYSTSPRT.    In non-TSO/E address spaces, trace output is written to
the output stream as defined by the OUTDD field in the module name
table.  The system default is SYSTSPRT.

To end tracing, you can use the TRACE OFF instruction or the TE
immediate command.    You can also use TE in the exec to stop tracing
at a specific point.    If you are running in interactive debug, you
can use TE without entering attention mode to end tracing.

For more information about tracing, see the TRACE instruction on
item TRACE and Debug Aids in item -DEBUG-AIDS

Example

You are running an exec in TSO/E and the exec is not processing
correctly.    To start tracing the exec, press the attention interrupt
key.    The system issues the REXX attention prompting message that
asks you to enter either a null line to continue or an immediate
command.    Enter TS to start tracing.
=UPPER
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
|              <--------+                                                |
| >>--UPPER---variable---;-------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

UPPER translates the contents of one or more variables to
uppercase.    The variables are translated in sequence from left to
right.

The variable is a symbol, separated from any other variables by one
or more blanks or comments.    Specify only simple symbols and
compound symbols.

Using this instruction is more convenient than repeatedly invoking
the TRANSLATE built-in function.

Example:

    a1='Hello';  b1='there'
    Upper a1 b1
    say a1 b1     /* Displays "HELLO THERE" */

An error is signalled if a constant symbol or a stem is
encountered.    Using an uninitialized variable is not an error, and
has no effect, except that it is trapped if the NOVALUE condition
(SIGNAL ON NOVALUE) is enabled.
=USERID
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--USERID()-------------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the TSO/E user ID, if the REXX exec is running in the TSO/E
address space. For example:

    USERID()    ->    'ARTHUR' /* Maybe */

If the exec is running in a non-TSO/E address space, USERID returns
one of the following values:

o     User ID specified (provided that the value specified is between
      one and seven characters in length)
o     Stepname specified
o     Jobname specified

The value that USERID returns is the first one that does not have a
null value.    For example, if the user ID is null but the stepname is
specified, USERID returns the value of the stepname.

=UNTIL (Conditional Phrase)
)F Function -
A conditional phrase can modify the iteration of a repetitive DO
loop.    It may cause the termination of a loop.  It can follow any of
the forms of repetitor (none, FOREVER, simple, or controlled).    If
you specify WHILE or UNTIL, exprw or expru, respectively, is
evaluated each time around the loop using the latest values of all
variables (and must evaluate to either 0 or 1), and the loop is
ended if exprw evaluates to 0 or expru evaluates to 1.

For a WHILE loop, the condition is evaluated at the top of the group
of instructions.    For an UNTIL loop, the condition is evaluated at
the bottom--before the control variable has been stepped.

Example:

    Do I=1 to 10 by 2 until i>6
      say i
      end
    /* Displays: "1" "3" "5" "7" */

Tip:    You can also modify the execution of repetitive loops by using
the LEAVE or ITERATE instructions.
=VALUE
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--VALUE(name-------------------)---------------------------------->< |
|                   +-,--newvalue-+                                      |
|                                                                        |
+------------------------------------------------------------------------+

Returns the value of the symbol that name (often constructed
dynamically) represents and optionally assigns it a new value.    By
default, VALUE refers to the current REXX-variables environment.    If
you use the function to refer to REXX variables, then name must be a
valid REXX symbol.    (You can confirm this by using the SYMBOL
function.) Lowercase characters in name are translated to
uppercase.    Substitution in a compound name (see "Compound Symbols"
in item -SYMBOL-COMPND ) occurs if possible.

If you specify newvalue, then the named variable is assigned this
new value.    This does not affect the result returned; that is, the
function returns the value of name as it was before the new
assignment.

Here are some examples:

    /* After: Drop A3; A33=7; K=3; fred='K'; list.5='Hi' */
    VALUE('a'k)     ->  'A3' /* looks up A3     */
    VALUE('fred')   ->  'K'  /* looks up FRED   */
    VALUE(fred)     ->  '3'  /* looks up K      */
    VALUE(fred,5)   ->  '3'  /* looks up K and  */
                             /* then sets K=5   */
    VALUE(fred)     ->  '5'  /* looks up K      */
    VALUE('LIST.'k) ->  'Hi' /* looks up LIST.5 */

Guideline:    If the VALUE function refers to an uninitialized REXX
variable then the default value of the variable is always returned;
the NOVALUE condition is not raised.    If you specify the name as a
single literal the symbol is a constant and so the string between
the quotation marks can usually replace the whole function call.
(For example, fred=VALUE('k'); is identical with the assignment
fred=k;, unless the NOVALUE condition is being trapped.    See
"Conditions and Condition Traps"    in item -CONDS-TRAPS )
=VERIFY
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--VERIFY(string,reference---------------------------------)------->< |
|                                +-,-------------------------+           |
|                                    +-option-+  +-,start-+              |
|                                                                        |
+------------------------------------------------------------------------+

Returns a number that, by default, indicates whether string is
composed only of characters from reference; returns 0 if all
characters in string are in reference, or returns the position of
the first character in string not in reference.

The option can be either Nomatch (the default) or Match.    (Only the
capitalized and highlighted letter is needed.    All characters
following it are ignored, and it can be in upper- or lowercase, as
usual.) If you specify Match, the function returns the position of
the first character in string that is in reference, or returns 0 if
none of the characters are found.

The default for start is 1; thus, the search starts at the first
character of string.    You can override this by specifying a
different start point, which must be a positive whole number.

If string is null, the function returns 0, regardless of the value
of the third argument.    Similarly, if start is greater than
LENGTH(string), the function returns 0.    If reference is null, the
function returns 0 if you specify Match; otherwise the function
returns the start value.

Here are some examples:

    VERIFY('123','1234567890')             ->    0
    VERIFY('1Z3','1234567890')             ->    2
    VERIFY('AB4T','1234567890')            ->    1
    VERIFY('AB4T','1234567890','M')        ->    3
    VERIFY('AB4T','1234567890','N')        ->    1
    VERIFY('1P3Q4','1234567890',,3)        ->    4
    VERIFY('123','',N,2)                   ->    2
    VERIFY('ABCDE','',,3)                  ->    3
    VERIFY('AB3CD5','1234567890','M',4)    ->    6
=WHILE (Conditional Phrase)
)F Function -
A conditional phrase can modify the iteration of a repetitive DO
loop.    It may cause the termination of a loop.  It can follow any of
the forms of repetitor (none, FOREVER, simple, or controlled).    If
you specify WHILE or UNTIL, exprw or expru, respectively, is
evaluated each time around the loop using the latest values of all
variables (and must evaluate to either 0 or 1), and the loop is
ended if exprw evaluates to 0 or expru evaluates to 1.

For a WHILE loop, the condition is evaluated at the top of the group
of instructions.    For an UNTIL loop, the condition is evaluated at
the bottom--before the control variable has been stepped.

Example:

    Do I=1 to 10 by 2 until i>6
      say i
      end
    /* Displays: "1" "3" "5" "7" */

Tip:    You can also modify the execution of repetitive loops by using
the LEAVE or ITERATE instructions.
=WORD
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--WORD(string,n)-------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the nth blank-delimited word in string or returns the null
string if fewer than n words are in string.    The n must be a
positive whole number.    This function is exactly equivalent to
SUBWORD(string,n,1).

Here are some examples:

    WORD('Now is the time',3)    ->    'the'
    WORD('Now is the time',5)    ->    ''
=WORDINDEX
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--WORDINDEX(string,n)--------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the position of the first character in the nth
blank-delimited word in string or returns 0 if fewer than n words
are in string.    The n must be a positive whole number.

Here are some examples:

    WORDINDEX('Now is the time',3)    ->    8
    WORDINDEX('Now is the time',6)    ->    0
=WORDLENGTH
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--WORDLENGTH(string,n)-------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the length of the nth blank-delimited word in string or
returns 0 if fewer than n words are in string.    The n must be a
positive whole number.

Here are some examples:

    WORDLENGTH('Now is the time',2)       ->    2
    WORDLENGTH('Now comes the time',2)    ->    5
    WORDLENGTH('Now is the time',6)       ->    0
=WORDPOS (Word Position)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--WORDPOS(phrase,string--------------)---------------------------->< |
|                              +-,start-+                                |
|                                                                        |
+------------------------------------------------------------------------+

Returns the word number of the first word of phrase found in string
or returns 0 if phrase contains no words or if phrase is not found.
Multiple blanks between words in either phrase or string are treated
as a single blank for the comparison, but otherwise the words must
match exactly.

By default the search starts at the first word in string.    You can
override this by specifying start (which must be positive), the word
at which to start the search.

Here are some examples:

    WORDPOS('the','now is the time')              ->  3
    WORDPOS('The','now is the time')              ->  0
    WORDPOS('is the','now is the time')           ->  2
    WORDPOS('is   the','now is the time')         ->  2
    WORDPOS('is   time ','now is   the time')     ->  0
    WORDPOS('be','To be or not to be')            ->  2
    WORDPOS('be','To be or not to be',3)          ->  6

=WORDS
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--WORDS(string)--------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns the number of blank-delimited words in string.

Here are some examples:

    WORDS('Now is the time')    ->    4
    WORDS(' ')                  ->    0
=XRANGE (Hexadecimal Range)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--XRANGE(-------------------------)------------------------------->< |
|                 +-start-+   +-,end-+                                   |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string of all valid 1-byte encodings (in ascending order)
between and including the values start and end.    The default value
for start is '00'x, and the default value for end is 'FF'x.    If
start is greater than end, the values wrap from 'FF'x to '00'x.    If
specified, start and end must be single characters.

Here are some examples:

    XRANGE('a','f')      ->   'abcdef'
    XRANGE('03'x,'07'x)  ->   '0304050607'x
    XRANGE(,'04'x)       ->   '0001020304'x
    XRANGE('i','j')      ->   '898A8B8C8D8E8F9091'x  /* EBCDIC */
    XRANGE('FE'x,'02'x)  ->   'FEFF000102'x
    XRANGE('i','j')      ->   'ij'                   /* ASCII  */
=X2B (Hexadecimal to Binary)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--X2B(hexstring)-------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string, in character format, that represents hexstring
converted to binary.    The hexstring is a string of hexadecimal
characters.    It can be of any length.  Each hexadecimal character is
converted to a string of four binary digits.    You can optionally
include blanks in hexstring (at byte boundaries only, not leading or
trailing) to aid readability; they are ignored.

The returned string has a length that is a multiple of four, and
does not include any blanks.

If hexstring is null, the function returns a null string.

Here are some examples:

    X2B('C3')        ->  '11000011'
    X2B('7')         ->  '0111'
    X2B('1 C1')      ->  '000111000001'

You can combine X2B with the functions D2X and C2X to convert
numbers or character strings into binary form.

Here are some examples:

    X2B(C2X('C3'x))  ->  '11000011'
    X2B(D2X('129'))  ->  '10000001'
    X2B(D2X('12'))   ->  '1100'
=X2C (Hexadecimal to Character)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--X2C(hexstring)-------------------------------------------------->< |
|                                                                        |
+------------------------------------------------------------------------+

Returns a string, in character format, that represents hexstring
converted to character.    The returned string is half as many bytes
as the original hexstring.    hexstring can be of any length.  If
necessary, it is padded with a leading 0 to make an even number of
hexadecimal digits.

You can optionally include blanks in hexstring (at byte boundaries
only, not leading or trailing) to aid readability; they are
ignored.

If hexstring is null, the function returns a null string.

Here are some examples:

    X2C('F7F2 A2')    ->    '72s'   /*  EBCDIC                     */
    X2C('F7f2a2')     ->    '72s'   /*  EBCDIC                     */
    X2C('F')          ->    ' '     /*  '0F' is unprintable EBCDIC */
=X2D (Hexadecimal to Decimal)
)F Function -
+------------------------------------------------------------------------+
|                                                                        |
| >>--X2D(hexstring----------)---------------------------------------->< |
|                      +-,n-+                                            |
|                                                                        |
+------------------------------------------------------------------------+

Returns the decimal representation of hexstring.    The hexstring is a
string of hexadecimal characters.    If the result cannot be expressed
as a whole number, an error results.    That is, the result must not
have more digits than the current setting of NUMERIC DIGITS.

You can optionally include blanks in hexstring (at byte boundaries
only, not leading or trailing) to aid readability; they are
ignored.

If hexstring is null, the function returns 0.

If you do not specify n, hexstring is processed as an unsigned
binary number.

Here are some examples:

    X2D('0E')
    ->    14
    X2D('81')        ->    129
    X2D('F81')       ->    3969
    X2D('FF81')      ->    65409
    X2D('F0')        ->    240
    X2D('c6 f0'X)    ->    240     /* 'C6 F0'X is equivalent
                                      to'F0'.                        */
                                   /* See discussion elsewhere of
                                      hexadecimal strings.           */
    X2D('C6F0')      ->    61646   /* 'C6F0'is a 4 digit hex number. */

If you specify n, the string is taken as a signed number expressed
in n hexadecimal digits.    If the leftmost bit is off, then the
number is positive; otherwise, it is a negative number in two's
complement notation.    In both cases it is converted to a whole
number, which may, therefore, be negative.    If n is 0, the function
returns 0.

If necessary, hexstring is padded on the left with 0 characters
(note, not "sign-extended"), or truncated on the left to n
characters.

Here are some examples:

    X2D('81',2)      ->    -127
    X2D('81',4)      ->    129
    X2D('F081',4)    ->    -3967
    X2D('F081',3)    ->    129
    X2D('F081',2)    ->    -127
    X2D('F081',1)    ->    1
    X2D('0031',0)    ->    0

Implementation maximum:    The input string may not have more than 500
hexadecimal characters that will be significant in forming the final
result.    Leading sign characters (0 and F) do not count towards this
total.
